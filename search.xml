<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记录一次在uni-app中使用echarts的坑</title>
      <link href="/2024/10/15/echart-uni-20241015/"/>
      <url>/2024/10/15/echart-uni-20241015/</url>
      
        <content type="html"><![CDATA[<h1>背景</h1><p>在 uni-app 的内置组件和官方扩展组件中，是没有支持图表的组件的。通过<code>内置组件-画布-canvas</code>的页面内容，可以找到官方文档对图表使用的解释：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/image-20241015203614690.png" alt="image-20241015203614690"></p><p>一开始准备直接尝试使用uChart的，看到微信扫一扫就劝退了。反正我只需要基础的图表功能，也不太在乎性能，再加上之前在Vue项目写过echarts代码，对echarts官方的文档说明比较了解，就选择了另一个插件：<a href="https://ext.dcloud.net.cn/plugin?id=4899">echarts</a> 。</p><p>这个插件主要就是为了让 uni-app 能兼容echarts，所有图表相关语法都是直接用echarts的，所以上手就比较简单些。</p><h1>开始使用</h1><p>在插件文档的代码演示中，找到Vue3版本的示例代码，直接拷贝，运行项目，图表正常展示。</p><p>现在就是需要自定义自己的图表样式了，我做的图表是一个饼图，也没什么样式要求，整个option的结构定义如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  series<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    type<span class="punctuation">:</span> &#x27;pie&#x27;<span class="punctuation">,</span></span><br><span class="line">    data<span class="punctuation">:</span> data<span class="punctuation">,</span></span><br><span class="line">    radius<span class="punctuation">:</span> &#x27;<span class="number">80</span>%&#x27;<span class="punctuation">,</span></span><br><span class="line">    label<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      position<span class="punctuation">:</span> &#x27;inside&#x27;<span class="punctuation">,</span></span><br><span class="line">      formatter<span class="punctuation">:</span> &#x27;<span class="punctuation">&#123;</span>b<span class="punctuation">&#125;</span>\n<span class="punctuation">&#123;</span>d<span class="punctuation">&#125;</span>%&#x27;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>所以只需要搞定data数据的异步加载和更新就可以了。</p><p>因为我做的功能是要求饼图能根据页面选择的日期加载指定日期的统计数据，所以饼图是需要刷新变化的，按照echarts的说法，可以直接对chart实例调用<code>setOption</code>方法，将整个option重新赋值就可以了。</p><p>但是，事与愿违，无论我怎么尝试，图表始终展示的都是第一次渲染的data数据。期间通过GPT、Google、echarts官方文档、插件文档等多种途径寻找问题根源，以下是我发起的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">以下是我在uni-app项目中，一个vue文件关于echarts的部分代码，在交互触发searchData()导致数据变化后，图表并没有发生变化。</span><br><span class="line">&lt;view style=&quot;width:100%; height:750rpx&quot;&gt;&lt;l-echart ref=&quot;chartRef&quot;&gt;&lt;/l-echart&gt;&lt;/view&gt;</span><br><span class="line">const echarts = require(&#x27;../../uni_modules/lime-echart/static/echarts.min&#x27;);</span><br><span class="line">// 支出分类数据。包括图表和分类排行的数据</span><br><span class="line">const categoryData = reactive(&#123;</span><br><span class="line">  chartList: [],</span><br><span class="line">  categoryList: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const categoryDataRef = ref(&#123;</span><br><span class="line">  chartList: []  // 确保 chartList 是响应式的</span><br><span class="line">&#125;);</span><br><span class="line">// 图表数据</span><br><span class="line">const chartRef = ref(null)</span><br><span class="line">// 监控 chartList 的变化</span><br><span class="line">watch(() =&gt; categoryDataRef.value.chartList, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">  if (myChart.value) &#123;</span><br><span class="line">    renderChart();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; deep: true &#125;);  // 确保深度监控</span><br><span class="line">/**</span><br><span class="line"> * 查询数据</span><br><span class="line"> */</span><br><span class="line">function searchData() &#123;</span><br><span class="line">  statistics.pageDto.currentMonth = $&#123;currentMonth.value&#125;-01</span><br><span class="line">  statistics.pageDto.isQueryLastMonth = compareLastMonth.value</span><br><span class="line">  Promise.all([loadTotalStatisticsData(), loadRankStatisticsData(), loadCategoryStatisticsData()])</span><br><span class="line">    .then(([result1, result2, result3]) =&gt; &#123;</span><br><span class="line">      console.log(&quot;进入111&quot;);</span><br><span class="line">      // renderChart()</span><br><span class="line">      categoryDataRef.value.chartList = categoryData.chartList</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((error) =&gt; &#123;</span><br><span class="line">      console.error(&#x27;请求失败:&#x27;, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myChart = ref(null)</span><br><span class="line"></span><br><span class="line">function renderChart() &#123;</span><br><span class="line">  console.log(&quot;进入方法&quot;);</span><br><span class="line">  console.log(categoryData.chartList);</span><br><span class="line">  myChart.value.setOption(&#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">      type: &#x27;pie&#x27;,</span><br><span class="line">      data: categoryDataRef.value.chartList,</span><br><span class="line">      radius: &#x27;80%&#x27;,</span><br><span class="line">      label: &#123;</span><br><span class="line">        position: &#x27;inside&#x27;,</span><br><span class="line">        formatter: &#x27;&#123;b&#125;\n&#123;d&#125;%&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onReady(() =&gt; &#123;</span><br><span class="line">  // 组件能被调用必须是组件的节点已经被渲染到页面上</span><br><span class="line">  setTimeout(async () =&gt; &#123;</span><br><span class="line">    if (!chartRef.value) return</span><br><span class="line">    myChart.value = await chartRef.value.init(echarts)</span><br><span class="line"></span><br><span class="line">    searchData()</span><br><span class="line">  &#125;, 300)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>GPT的答复中，给出了多方面的检查和调整思路：</p><ol><li><strong>图表实例的初始化与数据更新时机</strong></li></ol><p><code>myChart</code> 可能未在数据变化时正确初始化。如果 <code>searchData</code> 在图表初始化之前触发，数据将不会被正确渲染。</p><p>在 <code>searchData</code> 触发前确保 <code>myChart</code> 已被初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onReady(() =&gt; &#123;</span><br><span class="line">  setTimeout(async () =&gt; &#123;</span><br><span class="line">    if (!chartRef.value) return;</span><br><span class="line">    myChart.value = await chartRef.value.init(echarts);</span><br><span class="line">    </span><br><span class="line">    // 确保图表实例化后才调用 searchData</span><br><span class="line">    searchData();</span><br><span class="line">  &#125;, 300);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>数据响应式处理</strong></li></ol><p>虽然你使用了 <code>reactive</code> 和 <code>ref</code>，但是在 <code>Promise.all</code> 中直接更新 <code>categoryDataRef.value.chartList</code> 可能没有触发 <code>watch</code>。尝试通过 <code>Vue.set</code> 方式强制数据更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categoryDataRef.value.chartList = [...categoryData.chartList]; // 确保数据发生变化</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>watch</code> 的深度监听</strong></li></ol><p><code>watch</code> 中使用了 <code>&#123; deep: true &#125;</code>，但由于 <code>categoryDataRef.value.chartList</code> 是数组，Vue 有时不会捕捉到数组内部的变化。为了确保监控到变化，可以尝试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch(() =&gt; categoryDataRef.value.chartList.slice(), (newVal, oldVal) =&gt; &#123;</span><br><span class="line">  if (myChart.value) &#123;</span><br><span class="line">    renderChart();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; deep: true &#125;);</span><br></pre></td></tr></table></figure><p>使用 <code>slice()</code> 方法创建新数组，触发 Vue 的响应式系统。</p><ol start="4"><li><strong><code>setOption</code> 强制更新</strong></li></ol><p>你已经使用了 <code>setOption</code> 的强制更新参数 <code>true</code>，这一点是正确的，可以保证即使数据小幅更新，图表也会重新渲染。</p><p>确保 <code>renderChart</code> 确实在数据变更后被正确调用，检查日志输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function renderChart() &#123;</span><br><span class="line">  console.log(&quot;进入方法&quot;);</span><br><span class="line">  console.log(categoryDataRef.value.chartList);</span><br><span class="line">  myChart.value.setOption(&#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">      type: &#x27;pie&#x27;,</span><br><span class="line">      data: categoryDataRef.value.chartList,</span><br><span class="line">      radius: &#x27;80%&#x27;,</span><br><span class="line">      label: &#123;</span><br><span class="line">        position: &#x27;inside&#x27;,</span><br><span class="line">        formatter: &#x27;&#123;b&#125;\n&#123;d&#125;%&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>可以尝试以下步骤：</p><ol><li>确保 <code>myChart</code> 初始化在 <code>searchData</code> 调用之前。</li><li>通过 <code>slice()</code> 或者使用 <code>Vue.set</code> 强制触发 <code>watch</code> 的响应式更新。</li><li>在 <code>renderChart</code> 中检查数据是否正确传递给 <code>setOption</code>。</li></ol><p>如果这些调整都没有效果，可以在 <code>renderChart</code> 内部打印日志以进一步调试数据更新的时机与流程。</p><p>---- 分段 ----</p><p>通过上述思路，我首先在 <code>renderChart</code> 方法中，增加了打印 option 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentOption = myChart.<span class="property">value</span>.<span class="title function_">getOption</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setOption 后的 series.data:&quot;</span>, currentOption.<span class="property">series</span>[<span class="number">0</span>].<span class="property">data</span>);</span><br></pre></td></tr></table></figure><p>通过打印发现，series的data数据确实没有更新，说明<code>myChart.value.setOption</code>没有生效。</p><p>第1点，图表实例的初始化与数据更新时机，这个其实只要自己代码逻辑清晰，数据更新时机是肯定没问题的，至于实例初始化问题，第一次渲染的数据图表都出来，所以初始化也没有问题。</p><p>第2点，认为数据可能没有触发<code>watch</code>，其实通过日志打印，是可以看到每次数据发生变化后，触发了<code>watch</code>方法的。之前我没有使用监听方法，而是在每次加载数据后手动调用<code>renderChart</code>方法，但总是出现一些莫名其妙的问题，于是就改成监听方式了。</p><p>第3点，<code>watch</code>的深度监听，这个跟第2点一样，是可以忽略的，因为打印了日志，说明能监听到数据变化。</p><p>然后我根据资料解释，一度怀疑是echarts没有触发更新，于是尝试了echarts的<code>clear</code>、<code>dispose</code>、<code>notMerge: true</code>等方法，直到解决问题后才幡然醒悟，属性数据都没有发生变化，echarts图表肯定不会重新渲染，所以不存在第4点说的问题。</p><p>最后，我重整思绪，基本可以确定是<code>myChart.value.setOption</code>这段代码出现了问题，但是实在是想不通这样有什么不对，因为<code>myChart</code>确实就是echarts的对象实例啊，而且第一次加载的数据也渲染出来了。</p><p>整段代码中，其实都很好理解，因为都是vue或者echarts的语法内容，可以确定没问题，问题的关键还是在这个插件上，<code>chartRef.value.init(echarts)</code>方法，顾名思义就是初始化，但我没有看到任何关于这个<code>init</code>方法的解释，于是产生怀疑，<code>init</code>方法返回的对象可能并不是echarts实例对象。</p><p>于是，我又在插件文档上反复浏览，发现了下面这一段内容：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/image-20241015211809598.png" alt="image-20241015211809598"></p><p>文档说明<code>init</code>方法还有第二个参数的，第二个参数是回调函数，回调函数的参数才是chart实例。这是其一，还有一个很重要的观察点，既然这个方法都列在一起，说明它们的调用对象是同一个！！！而<code>init</code>方法的调用对象是<code>chartRef.value</code>，那么是不是说明<code>setOption</code>方法的调用对象也是<code>chartRef.value</code>，于是<code>renderChart</code>方法代码改成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderChart</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> option = &#123;</span><br><span class="line">    <span class="attr">series</span>: [&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: categoryDataRef.<span class="property">value</span>.<span class="property">chartList</span>,</span><br><span class="line">      <span class="attr">radius</span>: <span class="string">&#x27;80%&#x27;</span>,</span><br><span class="line">      <span class="attr">label</span>: &#123;</span><br><span class="line">        <span class="attr">position</span>: <span class="string">&#x27;inside&#x27;</span>,</span><br><span class="line">        <span class="attr">formatter</span>: <span class="string">&#x27;&#123;b&#125;\n&#123;d&#125;%&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chartRef.<span class="property">value</span>.<span class="title function_">setOption</span>(option)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次启动项目，图表重新渲染成功！</p><p>所以～关键点就是<code>setOption</code>的调用对象搞错了。。。</p><p>但也留下了一个疑问，为什么第一次渲染时，使用<code>myChart.value.setOption</code>却可以。</p>]]></content>
      
      
      <categories>
          
          <category> ECharts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECharts </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 5.x在SpringBoot中的上手使用过程</title>
      <link href="/2024/10/13/rocketmq-springboot-simple/"/>
      <url>/2024/10/13/rocketmq-springboot-simple/</url>
      
        <content type="html"><![CDATA[<h1>准备环境</h1><ul><li>JDK 17</li><li>Spring Boot 3.2.3</li><li>RocketMQ（服务端） 5.3.1</li><li>rocketmq-v5-client-spring-boot-starter（客户端） 2.3.1</li></ul><p>在 SpringBoot 项目中依赖如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-v5-client-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果还未搭建服务端，可以先看<strong>第5节-服务器环境搭建</strong>。</p><h1>参数配置</h1><p>按照 SpringBoot 的约定习俗，在上手一个新的 <code>spring-boot-starter</code>项目时，想要知道怎么使用它，看它的 AutoConfiguration 就对了。</p><p>在 <code>rocketmq-v5-client-spring-boot</code>中，对应的 AutoConfiguration 类为 <code>RocketMQAutoConfiguration</code>，其类定义部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RocketMQProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123;MessageConverterConfiguration.class, ListenerContainerConfiguration.class, ExtTemplateResetConfiguration.class,</span></span><br><span class="line"><span class="meta">        ExtConsumerResetConfiguration.class, RocketMQTransactionConfiguration.class, RocketMQListenerConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;MessageConverterConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;RocketMQTransactionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">  <span class="comment">// ... 省略</span></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Bean(PRODUCER_BUILDER_BEAN_NAME)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(ProducerBuilderImpl.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;&quot;producer.endpoints&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ProducerBuilder <span class="title function_">producerBuilder</span><span class="params">(RocketMQProperties rocketMQProperties)</span> &#123;</span><br><span class="line">      <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean(SIMPLE_CONSUMER_BUILDER_BEAN_NAME)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(SimpleConsumerBuilder.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;&quot;simple-consumer.endpoints&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> SimpleConsumerBuilder <span class="title function_">simpleConsumerBuilder</span><span class="params">(RocketMQProperties rocketMQProperties)</span> &#123;</span><br><span class="line">       <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(ProducerOrConsumerPropertyCondition.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = ROCKETMQ_TEMPLATE_DEFAULT_GLOBAL_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQClientTemplate <span class="title function_">rocketMQClientTemplate</span><span class="params">(RocketMQMessageConverter rocketMQMessageConverter)</span> &#123;</span><br><span class="line">       <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，在<code>rocketmq-v5-client-spring-boot</code>中，根据 RocketMQ 5.x 在架构上做的改进，使用了 <code>endpoints</code> 来替代传统的 <code>namesrvAddr</code>，以支持更灵活的网络拓扑和云原生架构。<code>endpoints</code> 通常指向 RocketMQ 的 <strong>Broker 或 Nameserver</strong> 地址，用于生产者与 RocketMQ 集群建立连接。<strong>endpoints</strong> 是一个 URL 或 IP 地址（ip:host）列表（使用<code>;</code>分割）。</p><blockquote><p>⚠️注意：在 RocketMQ 5.x 中，现已默认使用gRPC作为通信协议，entpoints更建议指向 <strong>Proxy</strong> 地址，一般默认端口为8081。</p></blockquote><p>因此，现在想要启用默认的生产者（ProducerBuilder），只需要配置<code>rocketmq.producer.endpoints</code>即可。</p><p>想要启用默认的消费者（SimpleConsumerBuilder），只需要配置<code>rocketmq.simple-consumer.endpoints</code>即可。</p><p>而<code>RocketMQClientTemplate</code>则是通过判断当前应用上下文是否含有<code>ProducerBuilder</code>或<code>SimpleConsumerBuilder</code> Bean对象生成而来。它属于<code>rocketmq-v5-client-spring-boot</code>模块下，也就是说它利用了Spring特性，提供了Spring风格的API，方便开发者通过 Spring 的编程模型来进行消息发送和接收。</p><p>既然是原生态的简易使用教程，那么就尽可能在不写多的代码的情况下，实现生产环境中使用MQ。</p><p>因此，本次项目就只配置 <code>rocketmq.producer.endpoints</code> 用于启用默认的生产者，消费者使用Push消费模式，所以配置<code>rocketmq.push-consumer.endpoints</code>。配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">endpoints:</span> <span class="string">localhost:8081</span></span><br><span class="line">  <span class="attr">push-consumer:</span></span><br><span class="line">  <span class="attr">endpoints:</span> <span class="string">localhost:8081</span></span><br></pre></td></tr></table></figure><p><code>topic</code>在代码中指定，不使用<code>rocketmq.producer.topic</code>和<code>rocketmq.push-consumer.topic</code>配置默认的topic。</p><blockquote><p>tips: 在启动客户端服务时，topic需要先创建，否则会启动报错。</p></blockquote><h1>生产者生产消息</h1><p>生产消息通过SpringBoot自动装配的<code>RocketMQClientTemplate</code>对象实现，发送<code>Message</code>对象，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RocketMQClientTemplate rocketMQClientTemplate;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">byte</span>[] bytes = <span class="string">&quot;这是一个字符串&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">      Message&lt;<span class="type">byte</span>[]&gt; message = MessageBuilder.withPayload(bytes).build();</span><br><span class="line">      rocketMQClientTemplate.send(<span class="string">&quot;MyTopic&quot;</span>, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️注意：在 RocketMQ 5.x 中，<code>Message</code>对象已从自定义对象改为<code>spring-messaging</code>包中的<code>Message</code>对象。一般通过<code>MessageBuilder</code>构建，实例对象类型为<code>GenericMessage</code>。</p></blockquote><h1>消费者消费消息</h1><p>消费者通过<code>@RocketMQMessageListener</code>注解，并实现<code>RocketMQListener</code>接口消费消息，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(consumerGroup = &quot;MyTopic-service&quot;, topic = &quot;MyTopic&quot;, tag = &quot;*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 MessageView 中获取 ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> messageView.getBody();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换 ByteBuffer 为字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] body = <span class="keyword">new</span> <span class="title class_">byte</span>[byteBuffer.remaining()];</span><br><span class="line">        byteBuffer.get(body);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理字节数组，例如转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">messageBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费消息内容：&quot;</span> + messageBody);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>服务端环境搭建</h1><ol><li><p>下载二进制包</p><p>在 <a href="https://rocketmq.apache.org/zh/docs/quickStart/01quickstart">Apache RocketMQ 本地部署 RocketMQ</a> 文档中，可以找到最新的二进制包，位置如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/image-20241014163749567.png" alt="image-20241014163749567"></p><p>如果想保持跟本文相同版本，可以直接点击<a href="https://dist.apache.org/repos/dist/release/rocketmq/5.3.1/rocketmq-all-5.3.1-bin-release.zip">链接</a>下载RocketMQ 5.3.1版本。</p></li><li><p>启动NameServer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 启动namesrv</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证namesrv是否启动成功</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure></li><li><p>本地模式启动Broker+Proxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 先启动broker</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 --enable-proxy &amp;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/proxy.log</span> </span><br><span class="line">The broker[broker-a,192.169.1.2:10911] boot success...</span><br></pre></td></tr></table></figure><p><code>mqbroker</code>脚本默认会读取 <code>conf/broker.conf</code> 配置用于Broker服务。在 <code>conf/rmq-proxy.json</code> 中是Proxy服务的配置，通过 <code>--enable-proxy</code> 命令启动时，需要加上 <code>-pc conf/rmq-proxy.json</code> 参数指定配置文件位置。</p><p><code>broker.conf</code>的监听端口key为<code>listenPort</code>，管理端口key为<code>brokerAdminPort</code>。</p><p><code>rmq.proxy.json</code>的gRPC请求端口key为<code>grpcServerPort</code>，传统的消息发送和接收请求的端口key为<code>remotingListenPort</code>。</p></li></ol><p>关于RocketMQ的管理命令可以参考<a href="https://rocketmq.apache.org/zh/docs/deploymentOperations/02admintool">Admin Tool</a>。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fail2Ban使用心得</title>
      <link href="/2024/09/23/fail2ban-use/"/>
      <url>/2024/09/23/fail2ban-use/</url>
      
        <content type="html"><![CDATA[<h1>起因</h1><p>最近租了两个“肉鸡”服务器用于个人开发学习，因为有公网暴露，频繁被机器人恶意登录，导致经常会出现如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There were * failed login attempts since the last successful login.</span><br></pre></td></tr></table></figure><p>通过修改 <code>/etc/ssh/sshd_config</code> 禁止root用户密码登录也拦不住，于是就找到一个第三方工具 - Fail2Ban。</p><h1>介绍</h1><p>Fail2Ban 是一个开源的入侵防御软件，主要用于防止恶意的暴力破解攻击。</p><p>它通过监控系统日志文件（例如 <code>/var/log/auth.log</code>、<code>/var/log/apache2/error.log</code> 等）中的可疑行为（如重复的登录失败、异常的 IP 请求等），根据预定义的规则识别出恶意行为，然后对恶意 IP 地址采取临时封禁措施。Fail2ban 主要通过修改防火墙规则来实现这一点。</p><h1>安装</h1><p>Linux下执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y fail2ban</span><br></pre></td></tr></table></figure><h1>配置</h1><p>Fail2Ban 有一个名为 <code>jail.conf</code> 的主（默认）配置文件，它可以与 <code>jail.local</code> 配置文件共存，<code>jail.local</code> 配置优先级高于 <code>jail.conf</code>。</p><p>建议不要修改 <code>jail.conf</code> 配置文件，推荐将 <code>jail.conf</code> 文件复制到名为 <code>jail.local</code> 的文件中，然后在 <code>jail.local</code> 文件中自定义自己的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local</span><br></pre></td></tr></table></figure><p><code>jail.local</code> 文件中的每个监狱定义由一组 <code>[监狱名称]</code> 标记组成，包含一系列指令来指定监控服务、日志路径、过滤器规则、封禁时长等。</p><h2 id="常用配置字段"><a class="header-anchor" href="#常用配置字段"></a>常用配置字段</h2><ol><li><p><strong>[监狱名称]</strong>每个监狱名称标识 Fail2ban 应监控的服务或日志源。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sshd]</span><br></pre></td></tr></table></figure><p>该部分用于定义 SSH 服务的监控规则。</p></li><li><p><strong>enabled</strong>该字段用于启用或禁用某个监狱。如果要启用某个监狱，设置为 <code>true</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enabled = true</span><br></pre></td></tr></table></figure></li><li><p><strong>port</strong>指定监控的端口号或服务名称。可以是具体的端口号，也可以使用协议名称（如 <code>ssh</code>、<code>http</code> 等）。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port = ssh</span><br></pre></td></tr></table></figure><p>或者指定端口号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port = 22</span><br></pre></td></tr></table></figure></li><li><p><strong>filter</strong>该字段指定 Fail2ban 用于分析日志的过滤器文件名。过滤器定义了如何解析日志文件中的特定模式。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter = sshd</span><br></pre></td></tr></table></figure><p>这会使用 <code>/etc/fail2ban/filter.d/sshd.conf</code> 中定义的过滤规则。</p></li><li><p><strong>logpath</strong>定义日志文件的路径，Fail2ban 将监控这些文件并根据过滤器规则分析其内容。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logpath = /var/log/auth.log</span><br></pre></td></tr></table></figure></li><li><p><strong>maxretry</strong>指定在指定时间段内失败的最大次数，超过该次数后 Fail2ban 将封禁对应 IP 地址。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxretry = 5</span><br></pre></td></tr></table></figure><p>表示在超过 5 次登录失败后触发封禁。</p></li><li><p><strong>bantime</strong>设置封禁的时间（秒为单位）。如果不需要永久封禁，可以设置一个合理的时间长度，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bantime = 3600</span><br></pre></td></tr></table></figure><p>该设置表示封禁时间为 1 小时（3600 秒）。如果希望永久封禁，可以将其设置为负数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bantime = -1</span><br></pre></td></tr></table></figure></li><li><p><strong>findtime</strong>该字段定义检测攻击行为的时间窗口（单位为秒）。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findtime = 600</span><br></pre></td></tr></table></figure><p>这表示在 600 秒（10 分钟）内，如果有 <code>maxretry</code> 次失败，则封禁 IP。</p></li><li><p><strong>action</strong>定义在封禁时执行的操作，通常是修改防火墙规则封禁 IP，也可以发送邮件通知等。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action = iptables[name=SSH, port=ssh, protocol=tcp]</span><br></pre></td></tr></table></figure><p>或者使用默认的 <code>action_</code> 操作模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action = %(action_mw)s</span><br></pre></td></tr></table></figure><p><code>action_mw</code> 表示发送邮件通知管理员，并封禁 IP。</p></li></ol><h2 id="配置示例"><a class="header-anchor" href="#配置示例"></a>配置示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认封禁时间为 1 小时</span></span><br><span class="line">bantime = 3600</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 10 分钟内检测到 5 次失败则封禁</span></span><br><span class="line">findtime = 600</span><br><span class="line">maxretry = 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送邮件通知管理员</span></span><br><span class="line">destemail = admin@example.com</span><br><span class="line">sender = fail2ban@example.com</span><br><span class="line">action = %(action_mw)s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监控 SSH 服务</span></span><br><span class="line">[sshd]</span><br><span class="line">enabled = true</span><br><span class="line">port = ssh</span><br><span class="line">filter = sshd</span><br><span class="line">logpath = /var/log/auth.log</span><br><span class="line">maxretry = 3</span><br><span class="line">bantime = -1</span><br></pre></td></tr></table></figure><p>提示：每次修改 <code>jail.local</code> 文件后，记得重启 Fail2ban 服务以应用更改。</p><h1>命令</h1><ol><li><p>启动 Fail2ban 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start fail2ban</span><br></pre></td></tr></table></figure></li><li><p>配置开机启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable fail2ban</span><br></pre></td></tr></table></figure></li><li><p>查看服务状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status fail2ban</span><br></pre></td></tr></table></figure></li><li><p>列出当前所有活动的监狱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fail2ban-client status</span><br></pre></td></tr></table></figure></li><li><p>查看某个监狱的详细信息（如 SSH）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fail2ban-client status sshd</span><br></pre></td></tr></table></figure></li><li><p>解封 IP 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fail2ban-client unban &lt;IP地址&gt;</span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart fail2ban</span><br></pre></td></tr></table></figure></li><li><p>检查配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检查配置文件的语法，并输出任何配置错误</span><br><span class="line">sudo fail2ban-client -d</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Fail2Ban </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot集成Redis使用心得</title>
      <link href="/2024/08/26/spring-boot-redis-use/"/>
      <url>/2024/08/26/spring-boot-redis-use/</url>
      
        <content type="html"><![CDATA[<p>记录一下最近在从零搭建项目时集成Redis的使用心得，主要内容如下：</p><ol><li>SpringBoot如何引入Redis；</li><li>SpringBoot引入Redis依赖后，为什么不能直接注入RedisTemplate；</li><li>SpringBoot中Redis的序列化方式；</li><li>自动装配默认使用的Redis客户端为什么是Lettuce；</li></ol><h1>SpringBoot如何引入Redis</h1><p>首先，如果作为初次在SpringBoot项目中使用Redis的人，可以按照如下方法查找关于Redis的依赖包。</p><ol><li><p>浏览器打开spring官网，找到SpringBoot项目。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240826160335356.png" alt="image-20240826160335356"></p></li><li><p>点击当前版本（CURRENT）SpringBoot的参考资料（Reference Doc.）。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240826160737190.png" alt="image-20240826160737190"></p></li><li><p>进入文档后，在搜索栏（Search）搜索Redis，一般第一个就是对应的文档目录。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240826161026006.png" alt="image-20240826161026006"></p></li><li><p>根据文档内容，可以了解到SpringBoot提供了一个 <code>spring-boot-starter-data-redis</code> 依赖包用于管理SpringBoot中关于Redis的依赖配置。并且在文档中还有大致的使用说明和示例。</p></li></ol><p>因此，要想使用Redis，只需要在SpringBoot项目中引入如下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-starter-data-redis</code> 依赖的版本号在 <code>spring-boot-dependencies</code> 有依赖管理。</p><p>如果想要开启Redis连接池，则需要依赖 <code>commons-pool2</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样的，<code>commons-pool2</code> 依赖的版本号在 <code>spring-boot-dependencies</code> 有依赖管理。</p><h1>SpringBoot项目为什么不能直接注入RedisTemplate</h1><p>这个问题有一点歧义，其实SpringBoot项目在引入<code>spring-boot-starter-data-redis</code>依赖后，是可以直接注入的，通过 <code>RedisAutoConfiguration</code> 源码分析可知，它默认注册了两个RedisTemplate类型的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(RedisConnectionDetails.class)</span></span><br><span class="line">PropertiesRedisConnectionDetails <span class="title function_">redisConnectionDetails</span><span class="params">(RedisProperties properties)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertiesRedisConnectionDetails</span>(properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring依赖注入的原理是基于Bean类型+名称确定，通过<code>@Autowried</code>注入唯一RedisTemplate对象时，可以注入下面两种：</p><ul><li>RedisTemplate&lt;Object, Object&gt; redisTemplate;</li><li>StringRedisTemplate stringRedisTemplate;</li></ul><p><code>StringRedisTemplate</code> 继承于<code>RedisTemplate&lt;String, String&gt;</code>，因此从Spring容器获取所有RedisTemplate的Bean对象时，<code>StringRedisTemplate</code>也会在其中。</p><p>细心点可以发现，<code>StringRedisTemplate</code>和<code>RedisTemplate&lt;Object, Object&gt;</code>主要是范型类型不一样，所以这里就涉及到一个知识点。</p><blockquote><p>在Java中，尽管泛型类型在运行时会被擦除，但在 Spring 的上下文中，Bean 的定义还是会包含泛型信息，这样可以在自动装配时进行更加精确的匹配。</p><p>因此，通过<code>@Autowired</code>自动注入Bean时，Spring会尝试匹配 Bean 的类型和泛型参数。</p></blockquote><p>所以，回到问题本身，如果在项目代码中，使用如下方式注入，就会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，因为SpringBoot自动装配注册的Bean为RedisTemplate&lt;Object, Object&gt;类型</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></pre></td></tr></table></figure><p>如果想要具备<code>RedisTemplate&lt;String, Object&gt;</code>类型的Bean，就得手动注册一个。</p><h1>SpringBoot中Redis的序列化方式</h1><p>准确来说，应该是<code>RedisTemplate</code>的序列化方式，在 Spring Data Redis 中，RedisTemplate 使用序列化器（Serializer）将 Java 对象序列化为二进制数据（字节数组），并反序列化为 Java 对象。</p><p>默认情况下，<code>RedisTemplate</code> 会使用 <code>JdkSerializationRedisSerializer</code> 来序列化 <code>key</code> 和 <code>value</code>，这意味着对象会使用 Java 自带的序列化机制（<code>Serializable</code> 接口）进行序列化。</p><p>序列化器的接口为 <code>RedisSerializer</code>，Spring Data Redis中默认实现了几种序列化方式，常见的有：</p><ul><li><p><strong>StringRedisSerializer</strong>：将字符串序列化为字节数组，常用于序列化 <code>key</code>，因为 Redis 的 <code>key</code> 通常是字符串类型。</p></li><li><p><strong>JdkSerializationRedisSerializer</strong>：使用 Java 序列化机制，将对象序列化为字节数组，这也是默认的 <code>RedisTemplate</code> 序列化方式。</p></li><li><p><strong>Jackson2JsonRedisSerializer</strong>：使用 Jackson 库将对象序列化为 JSON 字符串，适合存储和读取 JSON 数据。</p></li><li><p><strong>GenericJackson2JsonRedisSerializer</strong>：类似于 <code>Jackson2JsonRedisSerializer</code>，但更通用，可以处理泛型类型。</p></li><li><p><strong>GenericToStringSerializer</strong>：将对象的 <code>toString()</code> 方法的结果进行序列化，适用于可以通过 <code>toString()</code> 表达的简单对象。</p></li></ul><p>再看SpringBoot自动装配中提供的 <code>StringRedisTemplate</code> Bean对象，就会发现它使用的全部是 <code>StringRedisSerializer</code> 序列化器，它要求调用 <code>RedisTemplate</code> 存储键值对时，数据类型都为 <code>String</code> ，然后在序列化时，直接调用 <code>String</code> 类的<code>getBytes</code>方法，反序列化时则通过<code>new String(bytes)</code>方式。</p><h1>自动装配默认使用的Redis客户端为什么是Lettuce</h1><p>Spring Boot Starter Redis 默认使用 Lettuce 作为 Redis 客户端，是基于其性能优势、异步与反应式支持、线程安全性、集群与高可用性支持等多方面的优点。关键原因如下：</p><ol><li>Lettuce 的异步与反应式支持：Lettuce可以让应用程序以非阻塞的方式处理 Redis 操作。</li><li>线程安全：Lettuce 是一个线程安全的 Redis 客户端，允许多个线程共享同一个连接实例进行操作。</li><li>高可用与集群支持：Lettuce 支持 Redis 集群模式和分片（Sharding），并且能够处理主从复制架构中的故障转移情况，确保应用程序在 Redis 节点故障时仍然能够正常运行。</li><li>轻量且无第三方依赖：Lettuce 是一个轻量级的客户端，并且不依赖于 Netty 之外的第三方库。</li></ol><p>再说 Jedis ，它与 Lettuce 相比具有如下限制：</p><ol><li>同步 API：Jedis 是一个传统的同步 Redis 客户端，不支持异步操作，因此在处理高并发请求时，性能可能不如 Lettuce。</li><li>连接池依赖：Jedis 依赖于连接池来管理 Redis 连接，这在一些高并发场景中可能导致性能瓶颈或连接池耗尽的问题。</li></ol><p>因此，Lettuce 更适合现代微服务架构和高并发场景，使其成为 Spring Boot 的首选 Redis 客户端。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-“手撕”Class文件结构</title>
      <link href="/2024/07/03/java-jvm-readClassFile/"/>
      <url>/2024/07/03/java-jvm-readClassFile/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>在上一章节 <a href="https://blog.itwray.com/2024/06/30/java-jvm-classFileStructure/">Java-JVM类文件结构</a> 中描述了Class文件的组成，为了加深影响，这章将进行手动实践，编写一个Java示例文件，对编译生成后的Class文件进行一个一个字节的分析。</p><h1>Java文件</h1><p>以下是示例文件的Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itwray.study.advance.jvm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节码分析类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;wray&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        main.num++;</span><br><span class="line">        main.print(name + main.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Class文件</h1><p>通过 <code>javac Main.java</code> 命令生成Class文件，文件内容如下（本文使用Sublime Text）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0034 003e 0a00 0f00 2507</span><br><span class="line">0026 0a00 0200 2509 0002 0027 0700 280a</span><br><span class="line">0005 0025 0800 290a 0005 002a 0a00 0500</span><br><span class="line">2b0a 0005 002c 0a00 0200 2d09 002e 002f</span><br><span class="line">0800 300a 0031 0032 0700 3301 0003 6e75</span><br><span class="line">6d01 0001 4901 0004 6e61 6d65 0100 124c</span><br><span class="line">6a61 7661 2f6c 616e 672f 5374 7269 6e67</span><br><span class="line">3b01 000d 436f 6e73 7461 6e74 5661 6c75</span><br><span class="line">6501 0006 3c69 6e69 743e 0100 0328 2956</span><br><span class="line">0100 0443 6f64 6501 000f 4c69 6e65 4e75</span><br><span class="line">6d62 6572 5461 626c 6501 0012 4c6f 6361</span><br><span class="line">6c56 6172 6961 626c 6554 6162 6c65 0100</span><br><span class="line">0474 6869 7301 0023 4c63 6f6d 2f69 7477</span><br><span class="line">7261 792f 7374 7564 792f 6164 7661 6e63</span><br><span class="line">652f 6a76 6d2f 4d61 696e 3b01 0004 6d61</span><br><span class="line">696e 0100 1628 5b4c 6a61 7661 2f6c 616e</span><br><span class="line">672f 5374 7269 6e67 3b29 5601 0004 6172</span><br><span class="line">6773 0100 135b 4c6a 6176 612f 6c61 6e67</span><br><span class="line">2f53 7472 696e 673b 0100 0570 7269 6e74</span><br><span class="line">0100 1528 4c6a 6176 612f 6c61 6e67 2f53</span><br><span class="line">7472 696e 673b 2956 0100 0361 7267 0100</span><br><span class="line">0a53 6f75 7263 6546 696c 6501 0009 4d61</span><br><span class="line">696e 2e6a 6176 610c 0015 0016 0100 2163</span><br><span class="line">6f6d 2f69 7477 7261 792f 7374 7564 792f</span><br><span class="line">6164 7661 6e63 652f 6a76 6d2f 4d61 696e</span><br><span class="line">0c00 1000 1101 0017 6a61 7661 2f6c 616e</span><br><span class="line">672f 5374 7269 6e67 4275 696c 6465 7201</span><br><span class="line">0004 7772 6179 0c00 3400 350c 0034 0036</span><br><span class="line">0c00 3700 380c 0020 0021 0700 390c 003a</span><br><span class="line">003b 0100 0648 656c 6c6f 2007 003c 0c00</span><br><span class="line">3d00 2101 0010 6a61 7661 2f6c 616e 672f</span><br><span class="line">4f62 6a65 6374 0100 0661 7070 656e 6401</span><br><span class="line">002d 284c 6a61 7661 2f6c 616e 672f 5374</span><br><span class="line">7269 6e67 3b29 4c6a 6176 612f 6c61 6e67</span><br><span class="line">2f53 7472 696e 6742 7569 6c64 6572 3b01</span><br><span class="line">001c 2849 294c 6a61 7661 2f6c 616e 672f</span><br><span class="line">5374 7269 6e67 4275 696c 6465 723b 0100</span><br><span class="line">0874 6f53 7472 696e 6701 0014 2829 4c6a</span><br><span class="line">6176 612f 6c61 6e67 2f53 7472 696e 673b</span><br><span class="line">0100 106a 6176 612f 6c61 6e67 2f53 7973</span><br><span class="line">7465 6d01 0003 6f75 7401 0015 4c6a 6176</span><br><span class="line">612f 696f 2f50 7269 6e74 5374 7265 616d</span><br><span class="line">3b01 0013 6a61 7661 2f69 6f2f 5072 696e</span><br><span class="line">7453 7472 6561 6d01 0007 7072 696e 746c</span><br><span class="line">6e00 2100 0200 0f00 0000 0200 0200 1000</span><br><span class="line">1100 0000 1a00 1200 1300 0100 1400 0000</span><br><span class="line">0200 0700 0300 0100 1500 1600 0100 1700</span><br><span class="line">0000 2f00 0100 0100 0000 052a b700 01b1</span><br><span class="line">0000 0002 0018 0000 0006 0001 0000 0009</span><br><span class="line">0019 0000 000c 0001 0000 0005 001a 001b</span><br><span class="line">0000 0009 001c 001d 0001 0017 0000 006d</span><br><span class="line">0003 0002 0000 002d bb00 0259 b700 034c</span><br><span class="line">2b59 b400 0404 60b5 0004 2bbb 0005 59b7</span><br><span class="line">0006 1207 b600 082b b400 04b6 0009 b600</span><br><span class="line">0ab7 000b b100 0000 0200 1800 0000 1200</span><br><span class="line">0400 0000 1000 0800 1100 1200 1200 2c00</span><br><span class="line">1300 1900 0000 1600 0200 0000 2d00 1e00</span><br><span class="line">1f00 0000 0800 2500 1c00 1b00 0100 0200</span><br><span class="line">2000 2100 0100 1700 0000 5200 0300 0200</span><br><span class="line">0000 1ab2 000c bb00 0559 b700 0612 0db6</span><br><span class="line">0008 2bb6 0008 b600 0ab6 000e b100 0000</span><br><span class="line">0200 1800 0000 0a00 0200 0000 1600 1900</span><br><span class="line">1700 1900 0000 1600 0200 0000 1a00 1a00</span><br><span class="line">1b00 0000 0000 1a00 2200 1300 0100 0100</span><br><span class="line">2300 0000 0200 24</span><br></pre></td></tr></table></figure><h2 id="魔数"><a class="header-anchor" href="#魔数"></a>魔数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure><p>从魔数开始，魔数是u4的无符号数，对应字节为 <code>cafe babe</code>。</p><h2 id="版本号"><a class="header-anchor" href="#版本号"></a>版本号</h2><pre><code>u2             minor_version;//Class 的小版本号u2             major_version;//Class 的大版本号</code></pre><p>Class的小版本号是u2的无符号数，对应字节为 <code>0000</code> ，表示小版本号为0。</p><p>Class的大版本号是u2的无符号数，对应字节为 <code>0034</code> ，表示大版本号为52，即Java 8版本。</p><h2 id="常量池"><a class="header-anchor" href="#常量池"></a>常量池</h2><pre><code>u2             constant_pool_count;//常量池的数量cp_info        constant_pool[constant_pool_count-1];//常量池</code></pre><p>常量池的数量是u2的无符号数，对应字节为 <code>003e</code> ，对应十进制为62，表示常量池中有61个常量。</p><p>因此，在<code>003e</code>后面的cp_info对应有61个常量，按照常量特性，第一个u1无符号数表示标志位，用于确定常量类型，接下来一个一个的列举出来。</p><ol><li><p><code>0a</code>对应十进制为10，代表 CONSTANT_Methodref_info ，表示类中方法的符号引用，它对应的结构定义为如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240730135800638.png" alt="image-20240730135800638"></p><p>那么后面对应的值就是<code>000f</code>和<code>0025</code>，十进制为15和37，分别表示方法返回类型的Class常量索引为15，方法的名称和描述符的常量索引为37。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 = Methodref          #15.#37        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></li><li><p><code>07</code>对应十进制为7，代表 CONSTANT_Class_info ，表示类或接口的符号引用，它对应的结构定义如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240730141438882.png" alt="image-20240730141438882"></p><p>后面对应的值就是<code>0026</code>，十进制为38，表示这个类的全限定名的常量索引为38。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2 = Class              #38            // com/itwray/study/advance/jvm/Main</span><br></pre></td></tr></table></figure><blockquote><p>可以发现，每个常量的名称，无论是全限定名还是简单名称，到最后都会指向 CONSTANT_Utf8_info 常量，表示字符串的意思。</p></blockquote></li><li><p><code>0a</code>同第1个常量的类型一样，代表 CONSTANT_Methodref_info ，对应为<code>0002</code>和<code>0025</code>，十进制为2和37，分别表示方法返回类型的Class常量索引为2，方法的名称和描述符的常量索引为37。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#3 = Methodref          #2.#37         // com/itwray/study/advance/jvm/Main.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure><blockquote><p>通过第一个常量和第三个常量，可以发现它们的名称和描述符指向了同一个常量，说明Class文件中允许多个不同的方法有相同的名称和描述符，只要返回值不同，也是可以在一个Class文件中共存，这点与Java代码的重载（Overload）有点不同。</p></blockquote></li><li><p><code>09</code>对应十进制为9，代表 CONSTANT_Fieldref_info ，表示字段的符号引用，它对应的结构定义如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240730143401427.png" alt="image-20240730143401427"></p><p>那么后面对应的值就是<code>0002</code>和<code>0027</code>，十进制为2和39，分别表示字段所在的Class常量索引为2，字段的名称和描述符的常量索引为39。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#4 = Fieldref           #2.#39         // com/itwray/study/advance/jvm/Main.num:I</span><br></pre></td></tr></table></figure></li><li><p><code>07</code>同第2个常量的类型一样，代表 CONSTANT_Class_info ，对应的值是<code>0028</code>，十进制为40，表示这个类的全限定名的常量索引为40。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#5 = Class              #40            // java/lang/StringBuilder</span><br></pre></td></tr></table></figure></li><li><p><code>0a</code>同第1个常量的类型一样，代表 CONSTANT_Methodref_info ，对应为<code>0005</code>和<code>0025</code>，十进制为5和37，分别表示方法返回类型的Class常量索引为5，方法的名称和描述符的常量索引为37。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#6 = Methodref          #5.#37         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></li><li><p><code>08</code>对应十进制为8，代表 CONSTANT_String_info ，表示字符串类型字面量，它的结构定义如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240730160946175.png" alt="image-20240730160946175"></p><p>对应的值就是<code>0029</code>，十进制为41，表示这个字符串对应的 CONSTANT_Utf8_info 索引为41。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#7 = String             #41            // wray</span><br></pre></td></tr></table></figure></li><li><p><code>0a</code>同第1个常量的类型一样，代表 CONSTANT_Methodref_info ，对应为<code>0005</code>和<code>002a</code>，十进制为5和42，分别表示方法返回类型的Class常量索引为5，方法的名称和描述符的常量索引为42。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#8 = Methodref          #5.#42         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br></pre></td></tr></table></figure></li><li><p><code>0a</code>同第1个常量的类型一样，代表 CONSTANT_Methodref_info ，对应为<code>0005</code>和<code>002b</code>，十进制为5和43，分别表示方法返回类型的Class常量索引为5，方法的名称和描述符的常量索引为43。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#9 = Methodref          #5.#43         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br></pre></td></tr></table></figure></li><li><p><code>0a</code>同第1个常量的类型一样，代表 CONSTANT_Methodref_info ，对应为<code>0005</code>和<code>002c</code>，十进制为5和44，分别表示方法返回类型的Class常量索引为5，方法的名称和描述符的常量索引为44。</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#10 = Methodref          #5.#44         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br></pre></td></tr></table></figure><ol start="11"><li><p><code>0a</code>同第1个常量的类型一样，代表 CONSTANT_Methodref_info ，对应为<code>0002</code>和<code>002d</code>，十进制为2和45，分别表示方法返回类型的Class常量索引为2，方法的名称和描述符的常量索引为45。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#11 = Methodref          #2.#45         // com/itwray/study/advance/jvm/Main.print:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure></li><li><p><code>09</code>同第4个常量的类型一样，代表 CONSTANT_Fieldref_info ，对应为<code>002e</code>和<code>002f</code>，十进制为46和47，分别表示字段所在的Class常量索引为46，字段的名称和描述符的常量索引为47。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#12 = Fieldref           #46.#47        // java/lang/System.out:Ljava/io/PrintStream;</span><br></pre></td></tr></table></figure></li><li><p><code>08</code>同第7个常量的类型一样，代表 CONSTANT_String_info ，对应值为<code>0030</code>，十进制为48，表示这个字符串对应的 CONSTANT_Utf8_info 索引为48。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#13 = String             #48            // Hello</span><br></pre></td></tr></table></figure></li><li><p><code>0a</code>同第1个常量的类型一样，代表 CONSTANT_Methodref_info ，对应为<code>0031</code>和<code>0032</code>，十进制为49和50，分别表示方法返回类型的Class常量索引为49，方法的名称和描述符的常量索引为50。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#14 = Methodref          #49.#50        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure></li><li><p><code>07</code>同第2个常量的类型一样，代表 CONSTANT_Class_info ，对应的值是<code>0033</code>，十进制为51，表示这个类的全限定名的常量索引为51。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#15 = Class              #51            // java/lang/Object</span><br></pre></td></tr></table></figure></li><li><p><code>01</code>对应十进制为1，代表 CONSTANT_Utf8_info，表示UTF-8编码的字符串，它的结构定义如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240730163314160.png" alt="image-20240730163314160"></p><p>对应的length选项值为<code>0003</code>，对应十进制为3，说明bytes选项的无符号数长度为3，即<code>6e756d</code>，对应的字符串为<code>num</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#16 = Utf8               num</span><br></pre></td></tr></table></figure></li><li><p>从第17个常量到第36个常量，以及索引为38、40、41、48、51～61的常量，同第16个常量的类型一样，代表 CONSTANT_Utf8_info，它们对应的字符串如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#17 = Utf8               I</span><br><span class="line">#18 = Utf8               name</span><br><span class="line">#19 = Utf8               Ljava/lang/String;</span><br><span class="line">#20 = Utf8               ConstantValue</span><br><span class="line">#21 = Utf8               &lt;init&gt;</span><br><span class="line">#22 = Utf8               ()V</span><br><span class="line">#23 = Utf8               Code</span><br><span class="line">#24 = Utf8               LineNumberTable</span><br><span class="line">#25 = Utf8               LocalVariableTable</span><br><span class="line">#26 = Utf8               this</span><br><span class="line">#27 = Utf8               Lcom/itwray/study/advance/jvm/Main;</span><br><span class="line">#28 = Utf8               main</span><br><span class="line">#29 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">#30 = Utf8               args</span><br><span class="line">#31 = Utf8               [Ljava/lang/String;</span><br><span class="line">#32 = Utf8               print</span><br><span class="line">#33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">#34 = Utf8               arg</span><br><span class="line">#35 = Utf8               SourceFile</span><br><span class="line">#36 = Utf8               Main.java</span><br><span class="line">#38 = Utf8               com/itwray/study/advance/jvm/Main</span><br><span class="line">#40 = Utf8               java/lang/StringBuilder</span><br><span class="line">#41 = Utf8               wray</span><br><span class="line">#48 = Utf8               Hello</span><br><span class="line">#51 = Utf8               java/lang/Object</span><br><span class="line">#52 = Utf8               append</span><br><span class="line">#53 = Utf8            (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">#54 = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">#55 = Utf8               toString</span><br><span class="line">#56 = Utf8               ()Ljava/lang/String;</span><br><span class="line">#57 = Utf8               java/lang/System</span><br><span class="line">#58 = Utf8               out</span><br><span class="line">#59 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">#60 = Utf8               java/io/PrintStream</span><br><span class="line">#61 = Utf8               println</span><br></pre></td></tr></table></figure></li><li><p>第37个常量，对应的字节码位置如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240730172445090.png" alt="image-20240730172445090"></p><p><code>0c</code>的十进制为12，代表 CONSTANT_NameAndType_info ，表示字段或方法的部分符号引用，它的结构定义如下：<img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240730172707842.png" alt="image-20240730172707842"></p><p>对应的值是<code>0015</code>和<code>0016</code>，十进制为21和22，分别表示对应的 CONSTANT_Utf8_info 常量的索引为21和22。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#37 = NameAndType        #21:#22        // &quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure><blockquote><p>关于如何在字节码文件中快速定位数据所处的字节码位置：在已知该项数据的上一个数据的值的情况下，可以根据数据的类型和值 反算出16进制编码，然后在编辑器中Ctrl + F搜索即可。（最好结合javap -verbose Xxx命令判断，避免找错）</p></blockquote></li><li><p>常量索引为39、42、43、44、45、47、50的常量，均同第37个常量的类型一样，代表 CONSTANT_NameAndType_info ，它们对应的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#39 = NameAndType        #16:#17        // num:I</span><br><span class="line">#42 = NameAndType        #52:#53        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">#43 = NameAndType        #52:#54        // append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">#44 = NameAndType        #55:#56        // toString:()Ljava/lang/String;</span><br><span class="line">#45 = NameAndType        #32:#33        // print:(Ljava/lang/String;)V</span><br><span class="line">#47 = NameAndType        #58:#59        // out:Ljava/io/PrintStream;</span><br><span class="line">#50 = NameAndType        #61:#33        // println:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure></li><li><p>第46个常量同第2个常量的类型一样，代表 CONSTANT_Class_info ，其对应的16进制字节码位置可以按照前面的搜索逻辑查询，16进制结果为39，十进制为57，表示这个类的全限定名的常量索引为57。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#46 = Class              #57            // java/lang/System</span><br></pre></td></tr></table></figure></li><li><p>第49个常量同第2个常量的类型一样，代表 CONSTANT_Class_info ，16进制结果为3c，十进制为60，表示这个类的全限定名的常量索引为60。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#49 = Class              #60            // java/io/PrintStream</span><br></pre></td></tr></table></figure></li></ol><p>至此，61个常量就分析完了。确定常量池最后在字节码文件中结束的位置如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240730174718030.png" alt="image-20240730174718030"></p><p><code>01 0007 7072 696e 746c6e</code>是最后一个 CONSTANT_Utf8_info 常量的字节码内容，对应的字符串为<code>println</code>。</p><h2 id="访问标志"><a class="header-anchor" href="#访问标志"></a>访问标志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure><p>访问标志是一个u2无符号数，对应的字节码是<code>0021</code>，通过标志位表查询的结果为：ACC_PUBLIC、ACC_SUPER。</p><h2 id="类索引、父类索引、接口索引集合"><a class="header-anchor" href="#类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h2><pre><code>u2             this_class;//类索引u2             super_class;//父类索引u2             interfaces_count;//接口数量u2             interfaces[interfaces_count];//一个类可以实现多个接口</code></pre><p>类索引是u2无符号数，对应字节码为<code>0002</code>，十进制为2，表示当前类文件的类对应为常量池中索引为2的常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2 = Class              #38            // com/itwray/study/advance/jvm/Main</span><br></pre></td></tr></table></figure><p>父类索引是u2无符号数，对应字节码为<code>000f</code>，十进制为15，表示当前类文件的父类对应为常量池中索引为15的常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#15 = Class              #51            // java/lang/Object</span><br></pre></td></tr></table></figure><p>接口索引集合的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             interfaces_count;<span class="comment">//接口数量</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure><p>对应字节码为<code>0000</code>，十进制为0，表示当前类文件没有接口。</p><h2 id="字段表集合"><a class="header-anchor" href="#字段表集合"></a>字段表集合</h2><pre><code>u2             fields_count;//字段数量field_info     fields[fields_count];//一个类可以有多个字段</code></pre><p>字段表是先以一个u2无符号数表示字段数量，对应字节码为<code>0002</code>，十进制为2，表示类中有2个字段。</p><p>字段的结构定义固定如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725171340663.png" alt="image-20240725171340663"></p><p>access_flags的标志字典如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725172852283.png" alt="image-20240725172852283"></p><p>接下来一个个字段的分析：</p><ol><li><p>access_flags对应字节码为<code>0002</code>，表示ACC_PRIVATE；</p><p>name_index对应字节码为<code>0010</code>，十进制为16，表示字段的简单名称对应常量池的索引为16，即<code>\#16 = Utf8        num</code>；</p><p>descriptor_index对应字节码为<code>0011</code>，十进制为17，表示字段的描述符对应常量池的索引为17，即<code>\#17 = Utf8        I</code>；</p><p>attributes_count对应字节码为<code>0000</code>，说明该字段没有属性信息，即没有attributes_info。</p><p>通过匹配常量池的索引，该字段为：<code>private int num</code> 。</p></li><li><p>access_flags对应字节码为<code>001a</code>，<code>0010</code>表示ACC_FINAL，<code>000a</code>则是<code>0002</code>和<code>0008</code>的按位或运算结果，所以还表示ACC_PRIVATE、ACC_STATIC。</p><p>name_index对应字节码为<code>0012</code>，十进制为18，表示字段的简单名称对应常量池的索引为18，即<code>\#18 = Utf8        name</code>；</p><p>descriptor_index对应字节码为<code>0013</code>，十进制为19，表示字段的描述符对应常量池的索引为19，即<code>\#19 = Utf8        Ljava/lang/String;</code>；</p><p>attributes_count对应字节码为<code>0001</code>，说明该字段有1个属性信息，根据属性表的结构定义，开始是一个u2无符号数，表示属性名称在常量池中的索引，对应字节码为<code>0014</code>，十进制为20，对应常量池的<code>\#20 = Utf8        ConstantValue</code>。<code>ConstantValue</code>的属性结构如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240731151436047.png" alt="image-20240731151436047"></p><p>根据属性结构得出紧接着后面是一个u4无符号数，表述属性的长度，对应字节码<code>0000 0002</code>，表示该属性的长度是2个u1（与属性结构中的第三个u2刚好对应上）。对应的属性长度的字节码为<code>0007</code>，通过<code>ConstantValue</code>标志表示这个字段是一个常量属性，然后通过属性长度的字段找到常量池中索引为7的常量，内容为<code>\#7 = String       #41      // wray</code>，说明这个常量字段的值是一个字符串，字符串内容对应常量池中索引41，即<code>\#41 = Utf8        wray</code>。</p><p>最后通过匹配常量池的索引，该字段为：<code>private static final String name = &quot;wray&quot;</code> 。</p></li></ol><h2 id="方法表集合"><a class="header-anchor" href="#方法表集合"></a>方法表集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有多个方法</span></span><br></pre></td></tr></table></figure><p>方法表同字段表的结构几乎一样，先是以一个u2无符号数表示方法数量，对应字节码为<code>0003</code>，表示当前类有3个方法。方法表的结构定义与字段表一样：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729160002172.png" alt="image-20240729160002172"></p><p>只是access_flags访问标志有一点区别，访问标志字典如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729160514905.png" alt="image-20240729160514905"></p><p>接下来一个个方法的分析：</p><ol><li><p>access_flags对应字节码为<code>0001</code>，表示ACC_PUBLIC；</p><p>name_index对应字节码为<code>0015</code>，十进制为21，表示字段的简单名称对应常量池的索引为21，即<code>\#21 = Utf8        &lt;init&gt;</code>；</p><p>descriptor_index对应字节码为<code>0016</code>，十进制为22，表示字段的描述符对应常量池的索引为22，即<code>\#22 = Utf8        ()V</code>；</p><p>从上面三个标志可知，这是当前类无参构造函数。</p><p>attributes_count对应字节码为<code>0001</code>，说明该字段有1个属性信息，根据属性表的结构定义，开始是一个u2无符号数，表示属性名称在常量池中的索引，对应字节码为<code>0017</code>，十进制为23，对应常量池的<code>\#23 = Utf8        Code</code>。<code>Code</code>属性的结构定义如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240731151714048.png" alt="image-20240731151714048"></p><p><code>Code</code>属性较为复杂，接下来一个个类型再分析：</p><ol><li>attribute_name_index 在<code>Code</code>属性中肯定对应的是常量池中的<code>Code</code>常量，也就是属性最开始的u2无符号数，即<code>0017</code>。</li><li>attribute_lenth表示属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。对应字节码为<code>0000 002f</code>，十进制为47，所以属性值长度为41。</li><li>max_stack代表操作数栈深度的最大值，</li><li>在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。对应字节码为<code>0001</code>。</li><li>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。对应字节码为<code>0001</code>。</li></ol><blockquote><p>对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</p><p>注意，并不是在方法中用了多少个局部变量，就把这些局部变量所占变量槽数量之和作为max_locals的值，操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</p></blockquote><ol start="6"><li><p>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。</p><p>code_lenth对应字节码为<code>0000 0005</code>，说明code有5个u1，那么code对应字节码为<code>2ab7 0001 b1</code>。每一个u1对应一个字节码指令，具体指令可以参考《深入理解Java虚拟机》附录C“虚拟机字节码指令表”。</p></li><li><p>exception_table_length和exception_table表示方法的异常表，异常表有自己的表结构定义（从上到下、从左到右）：<img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240731154308343.png" alt="image-20240731154308343"></p><p>exception_table_length对应字节码为<code>0000</code>，表示没有异常表，所以exception_table为空。</p></li><li><p>attributes_count和attributes则表示属性表（attribute_info），说明<code>Code</code>属性内部可以包含其他属性，例如<code>LineNumberTable</code>和<code>LocalVariableTable</code>等子属性。attributes_count对应字节码为<code>0002</code>，表示有两个属性表，属性表结构如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240731180451803.png" alt="image-20240731180451803"></p><p>接下来一个个属性分析：</p><ol><li><p>attribute_name_index对应字节码为<code>0018</code>，十进制为24，说明该属性的类型在常量池索引为24中，即<code> \#24 = Utf8        LineNumberTable</code>。<code>LineNumberTable</code>属性的结构这里就不在过多分析了。</p><blockquote><p>！！！只需要记住，在属性表结构中通过attribute_lenth确定了长度，attribute_length个u1就是这个属性的总长度，无论这个属性的内部结构怎么变，最后的总长度就是 u2 + u4 + attribute_length个u1。</p></blockquote><p>再看attribute_lenth对应字节码为<code>0000 0006</code>，表示info的长度为6，对应字节码为<code>0001 0000 0009</code>。</p></li><li><p>attribute_name_index对应字节码为<code>0019</code>，十进制为25，说明该属性的类型在常量池索引为25中，即<code>\#25 = Utf8        LocalVariableTable</code>。attribute_lenth对应字节码为<code>0000 000c</code>，表示info的长度为12，对应字节码为<code>0001 0000 0005 001a 001b 0000</code>。</p></li></ol></li></ol></li><li><p>接下来是第二个方法，access_flags对应字节码为<code>0009</code>，对应的字节码标志值为<code>0001</code>和<code>0008</code>，即表示ACC_PUBLIC、ACC_STATIC；</p><p>name_index对应字节码为<code>001c</code>，十进制为28，表示字段的简单名称对应常量池的索引为28，即<code>\#28 = Utf8        main</code>；</p><p>descriptor_index对应字节码为<code>001d</code>，十进制为29，表示字段的描述符对应常量池的索引为29，即<code>\#29 = Utf8        ([Ljava/lang/String;)V</code>；</p><p>从上面三个标志可知，该方法的定义为：<code>public static void main(String[] arg0)</code>。</p><blockquote><p>其中<code>arg0</code>参数名称是不被虚拟机关注的，可以通过方法对应的属性表找到<code>LocalVariableTable</code>属性以确定实际代码中的参数名称。</p></blockquote><p>attributes_count对应字节码为<code>0001</code>，说明该字段有1个属性信息，根据属性表的结构定义，开始是一个u2无符号数，表示属性名称在常量池中的索引，对应字节码为<code>0017</code>，十进制为23，对应常量池的<code>\#23 = Utf8        Code</code>。因为与第一个方法属性一样，就不再展开分析了，按照属性表的通用结构定义直接分析字节码，再次展示一遍属性表的结构定义：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240731180451803.png" alt="image-20240731180451803"></p><p>attribute_length对应字节码为<code>0000 006d</code>，十进制为109，说明info有109个u1无符号数，对应字节码如下（灰色选中区域）：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240801103318748.png" alt="image-20240801103318748"></p></li><li><p>第三个方法，access_flags对应字节码为<code>0002</code>，表示ACC_PRIVATE；</p><p>name_index对应字节码为<code>0020</code>，十进制为32，表示字段的简单名称对应常量池的索引为32，即<code>\#32 = Utf8        print</code>；</p><p>descriptor_index对应字节码为<code>0021</code>，十进制为33，表示字段的描述符对应常量池的索引为33，即<code>\#33 = Utf8        (Ljava/lang/String;)V</code>；</p><p>从上面三个标志可知，该方法的定义为：<code>private void print(String arg0)</code>。</p><p>attributes_count对应字节码为<code>0001</code>，说明该字段有1个属性信息，根据属性表的结构定义，开始是一个u2无符号数，表示属性名称在常量池中的索引，对应字节码为<code>0017</code>，十进制为23，对应常量池的<code>\#23 = Utf8        Code</code>。同前两个方法一样，直接看attribute_length对应字节码为<code>00 0000 52</code>，十进制为82，info对应的82个字节码如下（灰色选中区域）：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240801104128103.png" alt="image-20240801104128103"></p></li></ol><h2 id="属性表集合"><a class="header-anchor" href="#属性表集合"></a>属性表集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>首先第一个u2无符号数表示属性表的属性数，对应字节码为<code>0001</code>，表示有一个属性。</p><p>同分析方法表中的属性一样，再次根据attribute_info（属性表）的结构定义分析：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240731180451803.png" alt="image-20240731180451803"></p><p>attribute_name_index对应字节码为<code>0023</code>，十进制为35，对应常量池中索引为35的常量，即<code>\#35 = Utf8        SourceFile</code>。</p><p>接下来是attribute_length，对应字节码为<code>00 0000 02</code>，表示info的长度为2。</p><p>info对应的字节码为<code>00 24</code>。</p><p>至此，这个Class文件分析完毕（完结撒花～）。</p><h1>总结</h1><p>从魔数到最后的属性表集合，一个个u1无符号数分析下来，不得不感慨Class文件结构的紧凑，因为它真的没有任何一个分隔符，但即使文件结构紧凑，仍然提供了很多可扩展的特性，并且通过《Java虚拟机规范》实现了平台无关性、语言无关性。</p><p>而且，这还是从Java初版到至今，仍然维持Class文件结构几乎不变，且功能稳定实用。</p><p>再次佩服Java语言设计者们的智慧。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JVM类文件结构</title>
      <link href="/2024/06/30/java-jvm-classFileStructure/"/>
      <url>/2024/06/30/java-jvm-classFileStructure/</url>
      
        <content type="html"><![CDATA[<h1>简介</h1><p>在Java中，被 JVM 可以理解的代码称为<code>字节码</code>，即扩展名为 <code>.class</code> 的文件，这种文件被称为字节码文件，也可以称为类文件或者Class文件。</p><p>Java使用Java编译器（javac）可以将Java代码编译为字节码存储的Class文件，其他语言也可以使用自己的编译器将代码编译成Class文件，例如JRuby通过jrubyc编译器生成、Groovy通过groovyc编译器生成、Kotlin通过kotlinc编译器生成等。</p><p>编译生成后的Class文件被JVM虚拟机执行，不受操作系统平台影响，因此具有“一次编译，到处运行”的特性。</p><p><em><strong>🔔温馨提示</strong>：本章内容偏硬核，基本就是一个硬背字典的概念，建议结合 <a href="https://blog.itwray.com/2024/07/03/java-jvm-readClassFile/">“手撕”Class文件结构</a> 一起阅读，边看边上手最好。</em></p><h1>类文件结构</h1><p>任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。</p><p>Class文件是一组紧凑排列的二进制流，，各个数据项目按照顺序排列，没有分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。</p><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由如下所示的数据项按严格顺序排列构成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标志</span></span><br><span class="line">    u2             this_class;<span class="comment">//类索引</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类索引</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段数量</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。用一张图可以更加清晰的了解Class文件的组成。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240723151123554.png" alt="image-20240723151123554"></p><h2 id="魔数"><a class="header-anchor" href="#魔数"></a>魔数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p><p>Java 规范规定魔数为固定值：0xCAFEBABE。如果读取的文件不是以这个魔数开头，Java 虚拟机将拒绝加载它。</p><h2 id="Class文件的版本号"><a class="header-anchor" href="#Class文件的版本号"></a>Class文件的版本号</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></table></figure><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。</p><p>Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p><h2 id="常量池"><a class="header-anchor" href="#常量池"></a>常量池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure><p>常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</p><p><strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>。即如果<code>constant_pool_count</code>的十进制值为10，那么<code>cp_info</code>中实际的常量有9个。</p><p>Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。</p><p>常量池中主要存放两大类常量：<strong>字面量</strong>（Literal）和<strong>符号引用</strong>（Symbolic References）。</p><ul><li>字面量（Literals）：字面量是不变的数据，主要包括数值（如整数、浮点数）和字符串字面量。例如，一个整数100或一个字符串&quot;Hello World&quot;，在源代码中直接赋值，编译后存储在常量池中。</li><li>符号引用（Symbolic References）：符号引用是对类、接口、字段、方法等的引用，它们不是由字面量值给出的，而是通过符号名称（如类名、方法名）和其他额外信息（如类型、签名）来表示。这些引用在类文件中以一种抽象的方式存在，它们在类加载时被虚拟机解析为具体的内存地址。</li></ul><p>常量池中每一种常量都是一个表，这些表都有一个共同特点，就是表结构起始的第一位是u1类型的标志位（tag），代表着当前常量属于哪种常量类型。常见的常量类型如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725161908360.png" alt="image-20240725161908360"></p><p>每一种常量池的表结构也是不一样的，例如CONSTANT_Utf8_info类型的结构如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725162126812.png" alt="image-20240725162126812"></p><p>如果tag位对应十进制为1时，后面紧接着的2个字节是字符串的长度，然后length是字符串的字节长度。</p><p>因为常量类型过多，表结构不一致，并且随着Java迭代升级，常量类型越来越多，所以JDK提供了<code>javap</code>工具用于分析Class文件字节码，使用 <code>javap -verbose Xxx</code> 命令即可查看Xxx.class文件的字节码内容。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725163420489.png" alt="image-20240725163420489"></p><p>如上图所示，Constant pool表示常量池，拿第一个常量进行分析：</p><p>#1表示第一个常量，Methodref表示它的类型（对应标志位为10，描述是“类中方法的符号引用”），#15.#37表示该常量的值，在Methodref类型中表示指向常量Class #15 和 NameAndType #37，后面的 // ... 内容是注释内容，提示用户这个常量的含义是 引用了<code>java/lang/Object</code>类的构造方法<code>&lt;init&gt;</code>，方法签名为<code>()V</code>，即无参数，返回类型为void。</p><blockquote><p>仔细看一下会发现，其中有些常量似乎从来没有在代码中出现过，如“I”“V”“&lt;init&gt;”“LineNumberTable”“LocalVariableTable”等，这些看起来在源代码中不存在的常量是哪里来的？这部分常量的确不来源于Java源代码，它们都是编译器自动生成的，会被后面即将讲到的字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用，它们将会被用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么。因为Java中的“类”是无穷无尽的，无法通过简单的无符号数来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达。</p></blockquote><p>以下是部分常量类型的结构定义：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725164602204.png" alt="image-20240725164602204"></p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725164710997.png" alt="image-20240725164710997"></p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725164730738.png" alt="image-20240725164730738"></p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725164841168.png" alt="image-20240725164841168"></p><h2 id="访问标志"><a class="header-anchor" href="#访问标志"></a>访问标志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</p><p>具体的标志位以及标志的含义如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725165703996.png" alt="image-20240725165703996"></p><p>访问标志要求类文件中没有使用到的标志位一律为0，然后把使用到的标志值通过<strong>按位或运算</strong>计算得到一个u2长度的十六进制。</p><h2 id="类索引、父类索引、接口索引集合"><a class="header-anchor" href="#类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//类索引</span></span><br><span class="line">u2             super_class;<span class="comment">//父类索引</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口数量</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。</p><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。</p><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引和父类索引各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p><p>接口索引入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果容量为0，则索引集合为0，后面就没有对应的字节。</p><h2 id="字段表集合"><a class="header-anchor" href="#字段表集合"></a>字段表集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//字段数量</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br></pre></td></tr></table></figure><p>字段表（field_info）用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p>字段表的结构如下（从上到下、从左到右的顺序）：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725171340663.png" alt="image-20240725171340663"></p><ul><li><p><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</p><blockquote><p>字段中 access_flags 的取值如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240725172852283.png" alt="image-20240725172852283"></p></blockquote></li><li><p><strong>name_index:</strong> 对常量池的引用，表示的字段的简单名称。</p><blockquote><p>相较于“全限定名”，简单名称就是指没有类型和参数修饰的方法或者字段名称，全限定名则是把类全名中的“.“换成了“/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”号表示全限定名结束。</p></blockquote></li><li><p><strong>descriptor_index:</strong> 对常量池的引用，表示字段的描述符（同方法的descriptor_index描述符性质一样），描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p><blockquote><p>描述符一般用于字段和方法，它有如下一些规则：基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。</p><p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729154954973.png" alt="image-20240729154954973"></p></blockquote></li><li><p><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数。</p></li><li><p><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</p></li></ul><h2 id="方法表集合"><a class="header-anchor" href="#方法表集合"></a>方法表集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有多个方法</span></span><br></pre></td></tr></table></figure><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729160002172.png" alt="image-20240729160002172"></p><p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见如下表。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729160514905.png" alt="image-20240729160514905"></p><p>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，而方法里的Java代码经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，然后通过属性索引在属性表中查找。</p><p>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器“&lt;clinit&gt;()”方法和实例构造器“&lt;init&gt;()”方法。</p><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p><h2 id="属性表集合"><a class="header-anchor" href="#属性表集合"></a>属性表集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>在 Class 文件中，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><p>《Java虚拟机规范》有一些预定属性，要求所有Java虚拟机实现都应该能识别这些属性，部分属性如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729162021636.png" alt="image-20240729162021636"></p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729162037395.png" alt="image-20240729162037395"></p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729162107799.png" alt="image-20240729162107799"></p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729162133065.png" alt="image-20240729162133065"></p><p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足下表中所定义的结构。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240729162201397.png" alt="image-20240729162201397"></p><h1>参考</h1><ul><li>《深入理解Java虚拟机》（第三版）</li><li><a href="https://javaguide.cn/java/jvm/class-file-structure.html">https://javaguide.cn/java/jvm/class-file-structure.html</a></li><li><a href="https://coolshell.cn/articles/9229.html">https://coolshell.cn/articles/9229.html</a></li><li><a href="https://javabetter.cn/jvm/class-file-jiegou.html">https://javabetter.cn/jvm/class-file-jiegou.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JVM基础</title>
      <link href="/2024/06/18/java-jvm-basic/"/>
      <url>/2024/06/18/java-jvm-basic/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>JVM是Java进阶之路中非常重要的一步，因此写下本文，用一篇文章对JVM知识点做一个总结。</p><p>JVM知识体系比较多，本文将采用“想到什么说什么“的思维编写，个人感觉这样更容易引发学习思考，面对有难度的知识点，可以由浅入深，一点点的了解。</p><p>最后，再大概了解完JVM的所有知识点后，再做一个核心知识点总结，用于整理归纳。</p><h1>JVM是什么</h1><p>首先，在听到一个新单词时，不禁会产生疑问，它是什么？所以JVM是什么呢？</p><p>JVM全名 Java Virtual Machine ，中文名 Java虚拟机。顾名思义，它是一个虚拟化的计算机。</p><p>Q：<strong>JVM作为虚拟化机器，能做什么呢？</strong></p><p>它能执行Java字节码，将Java字节码翻译成机器代码，供操作系统执行，实现Java“一次编译，到处运行“的特性。</p><p>Q：<strong>出现了新单词 - Java字节码，什么是Java字节码呢？</strong></p><p>Java字节码（Java Bytecode）是Java编程语言编译后生成的一种中间表示形式。它是与平台无关的<strong>二进制代码</strong>，JVM能够直接理解和执行它。反过来说，Java字节码需要JVM进行解释，才能够被机器直接执行。</p><p>Q：<strong>Java字节码是怎么产生的呢？</strong></p><p>它是由Java源代码（.java文件）经过Java编译器（javac）编译后生成的，生成的文件后缀名为 .class 。</p><blockquote><p>需要注意的是，Java字节码对于JVM来说都应该被叫做 JVM字节码 ，因为.class文件是为了便于JVM识别和执行的。只是因为JVM最初是为运行Java程序而设计的，因此Java语言是第一个也是最广泛使用的编译生成JVM字节码的语言。由于Java的普及和影响力，JVM字节码通常被称为“Java字节码”。虽然JVM最初是为Java设计的，但它已经发展成为一个多语言平台。许多其他编程语言（如Scala、Kotlin、Groovy、Clojure等）也可以编译成JVM字节码并在JVM上运行。因此，用“JVM字节码”这个术语更能反映现代JVM生态系统的多样性和广泛应用。</p></blockquote><p>Q：<strong>既然知道是通过JVM执行的Java字节码，那JVM的执行机制又是怎样的？</strong></p><p>这个问题有点偏面试的问法了，换成下面白话文的形式：</p><p>现在有如下一段代码，它是怎么运行起来的，JVM在执行Java字节码的过程中做了哪些操作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发人员只看源代码的情况下，瞟一眼就知道系统执行后会输出“Hello”语句。</p><p>那么操作系统是如何知道要输出“Hello”语句的，就涉及到Java代码的执行过程了，执行过程一般分为编译期和运行时。</p><p>首先Java源代码（.java文件）经过编译器（javac）生成为Java字节码（.class文件），在 IDEA 上双击Hello.class文件，可以看到如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by   decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.itwray.study.advance.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hello</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注释可以看出，IDEA 默认使用了 FernFlower 反编译工具将字节码文件反编译为我们看得懂的 Java 源代码。</p><p>那么，真实的.class文件是什么样子的呢，建议使用 Sublime Text 工具直接打开.class文件，打开后的文件内容如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240619165037574.png" alt="image-20240619165037574"></p><p>从右下角的 Binary 可以看出，Sublime Text 识别到.class文件为二进制文件，只不过在展示时将其转换为了十六进制。</p><p>有了字节码文件后，就可以启动JVM运行字节码文件了（启动方式的本质是使用<code>java</code>命令工具）。</p><p>JVM在运行时的执行过程如下：</p><ol><li><strong>类加载</strong>：通过类加载器加载Hello类。</li><li><strong>字节码验证</strong>：验证Hello.class文件的合法性。</li><li><strong>内存分配</strong>：在堆上为Hello类的对象分配内存。</li><li><strong>解释执行</strong>：JVM解释执行Hello的main方法中的字节码指令。</li><li><strong>即时编译</strong>：如果main方法是热点代码，JIT编译器将其编译为本地机器码，提升执行效率。</li><li><strong>输出结果</strong>：调用本地方法（java.io.FileOutputStream#writeBytes），通过JNI与操作系统交互，输出“Hello”到控制台。</li></ol><p>看完JVM的执行机制，突然发现了很多新词汇，在一个一个分析之前，需要先了解了解JVM的组成部分。</p><h1>JVM的组成</h1><p>Q：<strong>JVM的组成部分有哪些？</strong></p><p>JVM大致可以分为类加载器、运行时数据区、执行引擎三个部分，下面是它的组成图。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240624172938.png" alt="20240624172938"></p><p>其实在执行引擎之后还有两个组成部分，分别是本地方法接口（JNI）和本地方法库（Native Method Libraries）。可以从上图看出，JVM分析字节码文件的执行过程大致就是按照它的组成部分从上往下执行的。</p><p>类加载器是JVM运行Java程序的第一关，主要负责加载类文件（.class文件），如果类文件加载失败，就不会进入到运行时数据区和执行引擎了。类加载器将类文件加载到内存中后，会经过加载、连接、初始化三个主要阶段。</p><p>运行时数据区负责存储类的元数据、对象实例、方法调用信息和线程执行状态等。方法区存储类信息和静态数据，堆存储对象实例，Java虚拟机栈和本地方法栈分别管理方法调用和本地方法调用的状态信息，程序计数器记录当前执行的字节码指令地址。这些区域协同工作，确保Java程序能够高效、正确地执行。</p><p>执行引擎负责执行Java字节码，将Java字节码指令转换为机器指令，并执行这些指令。它的主要职责包括解释执行、即时编译（JIT）、垃圾回收、以及各种优化技术。</p><p>总结：在JVM中，类加载器负责加载类文件并生成<code>Class</code>对象，而为Class对象分配内存空间和初始化是由运行时数据区中的方法区完成的。执行引擎负责解释执行字节码或将其编译为本地机器码并执行。这些组件协同工作，确保类文件被正确加载、分配内存、初始化并执行。</p><h1>类加载机制</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p><h2 id="类加载时机"><a class="header-anchor" href="#类加载时机"></a>类加载时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240710161054762.png" alt="image-20240710161054762"></p><h2 id="类加载过程"><a class="header-anchor" href="#类加载过程"></a>类加载过程</h2><h3 id="加载"><a class="header-anchor" href="#加载"></a>加载</h3><p>加载阶段负责<strong>将类文件从不同来源（如本地文件系统、网络等）加载到内存中，并生成类的<code>Class</code>对象</strong>。这个阶段包括以下步骤：</p><ul><li><strong>查找并加载类的二进制数据</strong>：类加载器首先在类路径（classpath）中查找类文件。如果找不到，会继续使用其他方式（如网络下载或自定义加载器）查找类文件。</li><li><strong>生成类的<code>Class</code>对象</strong>：将加载的类文件的二进制数据解析为JVM内部数据结构，并创建对应的<code>Class</code>对象。</li></ul><p>Q：<strong>查找类文件的依据是什么？或者说JVM使用什么数据查找的类文件？</strong></p><p>类加载器根据类的全限定名称来查找类文件。全限定名称包括包名和类名，例如：<code>com.example.MyClass</code>。</p><p>类的全限定名称通常映射到文件路径。例如：类<code>com.example.MyClass</code>映射到文件路径<code>com/example/MyClass.class</code>。</p><p>Q：<strong>加载类文件的来源一般有哪些？</strong></p><ul><li>Classpath：<ul><li>本地文件系统：通常类文件会放在本地文件系统的特定目录中，这些目录通过classpath设置。</li><li>JAR文件：类文件可以打包在JAR文件中，通过classpath包含这些JAR文件。</li></ul></li><li>网络：类加载器可以从网络上加载类文件，特别是自定义的类加载器可以从指定的URL或远程服务器上加载类文件。</li><li>内存：类文件可以直接从内存中加载。例如，一些框架会生成类文件的字节码并直接加载到JVM中。</li><li>其他存储：类文件可以存储在数据库中，某些类加载器可以从数据库中读取和加载类文件。</li></ul><p>Q：<strong>类加载器有哪些？</strong></p><p>以Java 8为例，类加载器一般分为4种：（前三个<code>ClassLoader</code>为内置类加载器）</p><ol><li>引导类加载器（Bootstrap ClassLoader）：加载核心Java类库（通常位于&lt;JAVA_HOME&gt;/lib目录下），如java.lang.*包中的类。</li><li>扩展类加载器（Extension ClassLoader）：加载扩展库（通常位于&lt;JAVA_HOME&gt;/lib/ext目录下）的类。</li><li>应用程序类加载器（AppClassLoader）：加载应用程序类路径（classpath）中的类，这是最常用的类加载器。</li><li>自定义类加载器：用户可以定义自己的类加载器，以便从特定位置或以特定方式加载类。</li></ol><p>Q：<strong>怎么确定类文件应该由哪个类加载器加载呢？</strong></p><p><code>ClassLoader</code>采用双亲委派模型搜索类和资源，<code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。委派机制如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240627173246953.png" alt="image-20240627173246953"></p><p>并且，双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p><p>Java内置的三个类加载器就是按照 BootstrapClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader 的层级设计的，BootstrapClassLoader作为顶层ClassLoader，是没有父类加载器的。</p><p>如果在代码中获取<code>ExtClassLoader</code>的parent ClassLoader，也会输出为空，因为BootstrapClassLoader是由C++实现的，这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p><p>提示：双亲委派模型并非是Java强制的约束，只是一种官方推荐的方式，在自定义类加载器中，可以重写<code>C lassLoad</code>的<code>loadClass</code>方法改为不采用双亲委派模型的方式。不过为了避免类重复加载以及Java核心API的安全，一般不建议重写<code>loadClass</code>方法，而是重写<code>findClass</code>方法实现自定义类的加载机制。</p><p>Q：<strong>类加载器是怎么解析的类文件的二进制数据呢？</strong></p><p>这个问题涉及到类文件的详细结构，后面单独出章节分析。目前只需要记住类文件的组成结构有如下部分：魔数（Magic Number）、版本号（Version Number）、常量池（Constant Pool）、访问标志（Access Flags）、类索引、父类索引和接口索引集合、字段表（Fields）、方法表（Methods）、属性表（Attributes）。</p><p>并且，这个组成结构的顺序是固定的，下面是一个类文件的字节码结构组成部分：(u后面的数字表示占用的字节数)</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ClassFile</span> &#123;</span><br><span class="line">    <span class="selector-tag">u4</span> <span class="selector-tag">magic</span>;                           <span class="comment">// 魔数</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">minor_version</span>;                   <span class="comment">// 次版本号</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">major_version</span>;                   <span class="comment">// 主版本号</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">constant_pool_count</span>;             <span class="comment">// 常量池计数</span></span><br><span class="line">    <span class="selector-tag">cp_info</span> <span class="selector-tag">constant_pool</span><span class="selector-attr">[constant_pool_count-1]</span>; <span class="comment">// 常量池</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">access_flags</span>;                    <span class="comment">// 访问标志</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">this_class</span>;                      <span class="comment">// 类索引</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">super_class</span>;                     <span class="comment">// 父类索引</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">interfaces_count</span>;                <span class="comment">// 接口计数</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">interfaces</span><span class="selector-attr">[interfaces_count]</span>;    <span class="comment">// 接口索引集合</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">fields_count</span>;                    <span class="comment">// 字段计数</span></span><br><span class="line">    <span class="selector-tag">field_info</span> <span class="selector-tag">fields</span><span class="selector-attr">[fields_count]</span>;    <span class="comment">// 字段表</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">methods_count</span>;                   <span class="comment">// 方法计数</span></span><br><span class="line">    <span class="selector-tag">method_info</span> <span class="selector-tag">methods</span><span class="selector-attr">[methods_count]</span>; <span class="comment">// 方法表</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">attributes_count</span>;                <span class="comment">// 属性计数</span></span><br><span class="line">    <span class="selector-tag">attribute_info</span> <span class="selector-tag">attributes</span><span class="selector-attr">[attributes_count]</span>; <span class="comment">// 属性表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q：<strong>创建的<code>Class</code>对象被存储到哪了？</strong></p><p>在类加载阶段，生成的<code>Class</code>对象被存放在JVM的<strong>方法区</strong>中。方法区是JVM运行时数据区的一部分，用于存储类的元数据、常量、静态变量和即时编译器编译后的代码等。</p><p>而<code>Class</code>在运行时被实例化的对象则是存放在<strong>堆</strong>中，通过这个对象实例可以访问到类的元数据（即<code>Object#getClass()</code>方法）。</p><h3 id="连接"><a class="header-anchor" href="#连接"></a>连接</h3><p>类连接主要包括三个子步骤：验证（Verification）、准备（Preparation）和解析（Resolution）。这些步骤确保类文件格式正确，分配必要的内存，并将符号引用转换为直接引用。</p><h4 id="验证"><a class="header-anchor" href="#验证"></a>验证</h4><p>验证阶段中<strong>JVM执行了一系列详细的验证规则，以确保类文件的格式和内容符合JVM规范</strong>，从而保证运行时的安全性和稳定性。验证规则主要由四部分组成：</p><ol><li><strong>文件格式验证</strong>：确保类文件的格式正确。<ul><li><strong>魔数</strong>：类文件的前四个字节是否为<code>0xCAFEBABE</code>。</li><li><strong>版本号</strong>：主次版本号是否在当前JVM的处理范围之内。例如，使用JDK8 javac编译的字节码文件，是不能在JAVA7 java命令下运行的。</li><li><strong>常量池</strong>：检查常量池中的每个常量项是否符合类型和格式的要求。例如，<code>CONSTANT_Class_info</code>项的格式是否正确。</li><li><strong>常量池索引</strong>：确保常量池中的索引是有效的，不超出常量池的边界。</li></ul></li><li><strong>元数据验证</strong>：确保类文件的元数据（类的结构信息）符合JVM规范。<ul><li><strong>类声明</strong>：检查类的访问标志（如<code>public</code>, <code>final</code>, <code>abstract</code>等）是否合法，确保不能同时使用互斥的标志。</li><li><strong>父类和接口</strong>：检查类的父类是否存在并且可访问，确保类实现的接口合法。</li><li><strong>字段和方法</strong>：检查字段和方法的声明是否合法，包括访问修饰符、类型、名称等。</li><li><strong>方法签名</strong>：确保方法的签名合法，包括参数和返回值类型是否合法。</li></ul></li><li><strong>字节码验证</strong>：确保类文件中的字节码正确。<ul><li><strong>数据流分析</strong>：<ul><li>检查局部变量和操作数栈的使用是否合法，确保操作数栈的深度不超过最大限制。</li><li>确保所有变量在使用前已经初始化。</li><li>确保方法调用的参数类型和数量正确。</li></ul></li><li><strong>控制流分析</strong>：<ul><li>确保所有的跳转指令跳转到有效的字节码位置，不会跳转到中间的指令或无效的位置。</li><li>确保异常处理块（<code>try-catch-finally</code>）的范围合法，不会跨越方法边界。</li><li>确保方法中的所有路径都正确处理了异常，确保异常处理器的类型和捕获类型匹配。</li></ul></li></ul></li><li><strong>符号引用验证</strong>：确保常量池中的符号引用能够被解析为合法的直接引用。<ul><li><strong>类引用</strong>：检查常量池中的类引用是否合法，确保引用的类存在并且可访问。</li><li><strong>字段引用</strong>：检查常量池中的字段引用是否合法，确保引用的字段在相应的类或接口中存在并且可访问。</li><li><strong>方法引用</strong>：检查常量池中的方法引用是否合法，确保引用的方法在相应的类或接口中存在并且可访问。</li></ul></li></ol><h4 id="准备"><a class="header-anchor" href="#准备"></a>准备</h4><p>准备阶段主要是<strong>为类的所有静态变量分配内存，并将其初始化为默认值</strong>。</p><p><strong>准备阶段与初始化阶段的区别</strong></p><ul><li><strong>准备阶段</strong>：分配静态变量的内存并将其初始化为默认值。这个过程只涉及默认值的设置，不执行任何用户代码（如静态初始化块和静态变量的显式赋值）。</li><li><strong>初始化阶段</strong>：执行类的静态初始化块和静态变量的显式赋值。这个过程是在准备阶段之后进行的，确保所有静态变量已经分配好内存并设置了默认值。</li></ul><p>注意：</p><ul><li>这些内存都是在方法区进行分配的，如果是JDK8及以后，方法区的实现是元空间。</li><li>类变量此时的初始化是指默认值初始化，而不是用户定义的赋值。默认值如下：<ul><li>整数类型（如<code>int</code>、<code>short</code>、<code>byte</code>、<code>long</code>）：默认值为<code>0</code>。</li><li>浮点类型（如<code>float</code>、<code>double</code>）：默认值为<code>0.0</code>。</li><li>字符类型（<code>char</code>）：默认值为<code>\u0000</code>（null字符）。</li><li>布尔类型（<code>boolean</code>）：默认值为<code>false</code>。</li><li>引用类型（如对象引用）：默认值为<code>null</code>。（引用类型包括String、Integer、枚举等）</li></ul></li><li>如果类变量被 final 关键字修饰，那就需要根据变量类型决定其何时被初始化。如果是基本类型和字符串常量，则在准备阶段就会被初始化赋值；如果是引用类型（包括Integer、枚举、自定义类等），则还是在初始化阶段被赋值，准备阶段仍为null。</li></ul><h4 id="解析"><a class="header-anchor" href="#解析"></a>解析</h4><p>解析阶段是<strong>Java虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p><strong>符号引用</strong>：<strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</strong>。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p><p><strong>直接引用</strong>：<strong>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</strong>。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p><p>在解析阶段，因为需要将符号引用替换为直接引用，所以在此阶段可能会抛出各种异常，例如：</p><ul><li>ClassNotFoundException：无法找到所需的类或接口。</li><li>NoSuchFieldError：无法找到所需的字段。</li><li>NoSuchMethodError：无法找到所需的方法。</li><li>IllegalAccessError：类或接口、字段、方法解析时，发现不具备访问权限。</li><li>IncompatibleClassChangeError：解析过程中发现类的结构与预期不符。</li></ul><p>Q：<strong>用一句话总结连接过程三个阶段主要做了什么。</strong></p><p>验证阶段确保类文件的字节码是否符合JVM规范，准备阶段就是为类变量分配内存并初始化为默认值的过程，解析阶段是JVM将常量池中的符号引用替换为直接引用的过程。</p><p>Q：<strong>这三个阶段是按照顺序执行的吗？</strong></p><p>从类加载过程来说，是顺序执行的。但对《Java虚拟机规范》而言，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。顺序按部就班地开始表示这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p><p>验证阶段保证了字节码的合法和安全，如果验证失败，整个类加载过程就会被中断，所以验证阶段是第一步。</p><p>准备阶段为静态变量分配内存并设置默认值，解析阶段是将常量池的符号引用替换为直接引用。从语义上来看，两个阶段在部分情况下可以并行执行，但是在JVM的实际实现中，为了保证类加载过程的逻辑清晰和实现简单，所以这两个阶段在实际情况下还是按照顺序执行的。</p><p>而至于为什么要把准备阶段放在解析阶段之前，主要是因为在解析过程中可能需要访问或验证静态变量的类型和内存布局。如果准备阶段未完成，这些信息可能不完整或不可用。所以解析阶段依赖于准备阶段。</p><h3 id="初始化"><a class="header-anchor" href="#初始化"></a>初始化</h3><p>初始化阶段是类加载过程的最后一个步骤，它的<strong>主要任务是执行类的初始化逻辑，即执行类构造器&lt;clinit&gt;()方法的过程</strong>。</p><p>&lt;clinit&gt;()并不是程序中编写的构造方法（实例的构造方法在JVM视角中称为&lt;init&gt;()方法），<strong>它是javac编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {}块）中语句 合并产生的</strong>，编译器收集的顺序是由语句在源文件中出现的顺序决定的。</p><p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问（不能直接使用变量名访问，但可以使用&lt;类名.变量名&gt;的方式访问）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">        System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">      System.out.println(InitializeDemo.i); <span class="comment">// 这句编译可以通过，并且可执行输出为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;clinit&gt;方法与类的构造方法不同，它不需要显式地调用父类&lt;clinit&gt;()方法，Java虚拟机会保证在子类的&lt;clinit&gt;()方法执行前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在Java虚拟机中第一个被执行的&lt;clinit&gt;()方法的类型肯定是java.lang.Object。</p><p>由于父类的&lt;clinit&gt;()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。例如如下示例中，输出的结果为2。</p><p>&lt;clinit&gt;()方法对于类或接口不是必需的，如果一个类中没有静态语句块和类变量赋值操作，那么javac编译器可以不为这个类生成&lt;clinit&gt;()方法。</p><p>接口虽然不能定义静态语句块，但可以有变量赋值操作，它属于类变量赋值操作。但接口与类不同，在初始化阶段，子接口不会先执行父接口的&lt;clinit&gt;()方法，只有当父接口定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也会执行接口的&lt;clinit&gt;()方法。</p><p>每个类的&lt;clinit&gt;()方法在类加载过程中只会执行一次，它通过对&lt;clinit&gt;()方法加锁实现，确保多线程环境中只会有其中一个线程去执行&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程的&lt;clinit&gt;()方法执行完毕。如果在类初始化过程中出现异常，该异常都会被封装成<code>ExceptionInInitializerError</code>异常抛出。</p><p>类的初始化阶段是惰性的，即在首次使用该类时才会触发。触发情况有如下几种：</p><ul><li>当创建类的新实例时（使用<code>new</code>关键字）。</li><li>当访问类的静态字段或调用静态方法时。</li><li>当反射机制调用类的方法时（例如，<code>Class.forName</code>）。</li><li>当初始化一个类的子类时，父类会先被初始化。</li><li>当虚拟机启动时，用户指定的主类会首先被初始化。</li></ul><p>因为初始化是惰性的，也间接说明了<strong>类在经过加载、连接阶段后，并不一定会马上执行初始化阶段</strong>。常见情况有如下几种：</p><ol><li><p>通过反射查询类信息，但不实际使用</p><p>使用反射机制查询类的信息，例如获取类的元数据（字段、方法等），这会触发类的加载和解析，但不会触发初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;Example&quot;</span>, <span class="literal">false</span>, Test.class.getClassLoader());</span><br><span class="line">        <span class="comment">// 仅查询类信息，不触发初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>仅仅解析类而未实际访问</p><p>某些情况下，JVM在运行过程中可能会预解析类以提高性能，但如果这些类没有被实际使用，则不会进入初始化阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Example.class;  <span class="comment">// 仅解析类，不触发初始化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用常量</p><p>使用类的常量字段（<code>final static</code> 修饰的基本类型或字符串）时，只会触发类的加载和解析，不会触发初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONST</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Example class static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Example.CONST;  <span class="comment">// 不会触发初始化</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="类加载器"><a class="header-anchor" href="#类加载器"></a>类加载器</h2><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p><h3 id="类与类加载器"><a class="header-anchor" href="#类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>换一句话说就是：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">myLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myLoader.loadClass(<span class="string">&quot;com.itwray.study.advance.jvm.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line">        <span class="comment">// 输出结果：class com.itwray.study.advance.jvm.ClassLoaderTest</span></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        <span class="comment">// 输出结果：false</span></span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> com.itwray.study.advance.jvm.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双亲委派模型"><a class="header-anchor" href="#双亲委派模型"></a>双亲委派模型</h3><p>JVM中内置了三个<code>ClassLoader</code>：</p><ul><li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JAVA_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向开发者的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240627173246953.png" alt="image-20240627173246953"></p><p>上图展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents DelegationModel）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p>双亲委派模型的好处是当一个类处于包含多个类加载器的JVM环境下时，可以保证加载出来的都是同一个类。即一个全限定名的类，在一个JVM下加载多次得到的Class类对象是相等的。</p><p>例如，手写一个rt.jar类库下的<code>java.lang.String</code>类，当通过<code>Class.forName()</code>方法加载时，并没有执行手写的String类的static块代码，说明没有加载这个类，而是加载的rt.jar类库下的String类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;custom String static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; stringClass = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        System.out.println(stringClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双亲委派模型的实现位于java.lang.ClassLoader的loadClass()方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码来自jdk8</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">              <span class="comment">// 如果父类加载器抛出ClassNotFoundException，说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在父类加载器无法加载时，再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块化下的类加载器"><a class="header-anchor" href="#模块化下的类加载器"></a>模块化下的类加载器</h2><p>JDK 9 之后为了适应模块化的发展，类加载器做了如下变化：</p><ul><li>仍维持三层类加载器和双亲委派的架构，但扩展类加载器被平台类加载器所取代；</li><li>当平台及应用程序类加载器收到类加载请求时，要首先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载；</li><li>启动类加载器、平台类加载器、应用程序类加载器全部继承自 <code>java.internal.loader.BuiltinClassLoader</code> ，BuiltinClassLoader 中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</li></ul><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240710173108681.png" alt="image-20240710173108681"></p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>JVM类加载机制是Java程序运行的基础，它通过加载、连接（验证、准备、解析）和初始化阶段将类文件动态加载到内存中，并通过双亲委派模型确保了类加载的安全性和一致性。</p><h1>运行时数据区</h1><p>运行时数据区隶属于Java 内存区域的一部分，主要讲述Java虚拟机对于内存区域的划分，这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240712152559344.png" alt="image-20240712152559344"></p><p>其中方法区和堆属于所有线程共享的数据区，而虚拟机栈、本地方法栈、程序计数器是线程隔离的数据区，也就是说隔离的数据区保证每个线程下都有对应的虚拟机栈、本地方法栈和程序计数器。</p><h2 id="程序计数器"><a class="header-anchor" href="#程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</p><p>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h2 id="Java虚拟机栈"><a class="header-anchor" href="#Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈（Java Virtual Machine Stack）又称为JVM栈，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p><p>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><h2 id="本地方法栈"><a class="header-anchor" href="#本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="Java堆"><a class="header-anchor" href="#Java堆"></a>Java堆</h2><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的内存区域，它可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。</p><p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p><h2 id="方法区"><a class="header-anchor" href="#方法区"></a>方法区</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>JDK 8 以后的方法区实现已经不再是永久代（Permanent Generation）了，而是使用元空间（Metaspace）来实现。</p><p>方法区也是可以存在垃圾收集的行为的，不过这个区域的回收效果一般微乎其微。因此，如果方法区无法满足新的内存分配需求时，同样会抛出 OutOfMemoryError 异常。</p><p>运行时常量池（Runtime Constant Pool）也是方法区的一部分，用于存放常量池表（Constant Pool Table），常量池表中存放了编译期生成的各种符号字面量和符号引用。</p><h1>字节码执行引擎</h1><p>JVM字节码执行引擎是Java虚拟机的核心组件之一，它负责执行已加载到内存中的Java字节码，并将其转换为具体的机器指令以执行程序。执行引擎的主要任务包括解释执行字节码、JIT编译、垃圾回收和线程调度等。</p><h2 id="解释执行字节码"><a class="header-anchor" href="#解释执行字节码"></a>解释执行字节码</h2><p>JVM字节码是一种与平台无关的中间表示形式。解释执行是将字节码逐条转换为相应的机器指令并执行。</p><p>字节码解释器：</p><ul><li>JVM内置的字节码解释器逐条读取字节码指令并执行相应的操作。</li><li>解释执行通常较慢，因为每条指令都需要解析和解释。</li></ul><h2 id="JIT（Just-In-Time）编译"><a class="header-anchor" href="#JIT（Just-In-Time）编译"></a>JIT（Just-In-Time）编译</h2><p>为了提高执行效率，JVM使用即时编译技术，将热点代码（被频繁执行的代码）编译为本地机器码，直接在硬件上运行。</p><ul><li>即时编译器（JIT Compiler）：<ul><li><strong>C1编译器</strong>：注重编译速度，用于编译简单和不太频繁的代码。</li><li><strong>C2编译器</strong>：注重优化性能，用于编译频繁执行的热点代码。</li></ul></li><li><strong>热点探测</strong>：JVM通过计数器统计方法的调用次数或循环次数，以识别热点代码。</li><li><strong>编译优化</strong>：包括内联、循环展开、逃逸分析等，进一步提高执行效率。</li></ul><h2 id="垃圾回收（Garbage-Collection）"><a class="header-anchor" href="#垃圾回收（Garbage-Collection）"></a>垃圾回收（Garbage Collection）</h2><p>JVM自动管理内存分配和回收，执行引擎中的垃圾回收器负责清理不再使用的对象，释放内存。</p><ul><li>垃圾回收算法：<ul><li><strong>标记-清除算法</strong>：标记所有可达对象，清除未标记对象。</li><li><strong>复制算法</strong>：将存活对象复制到新空间，清空旧空间。</li><li><strong>标记-压缩算法</strong>：标记所有可达对象，将存活对象压缩到一端，清除其他空间。</li></ul></li><li>垃圾回收器：<ul><li><strong>Serial GC</strong>：单线程垃圾回收器，适用于小型应用。</li><li><strong>Parallel GC</strong>：多线程垃圾回收器，适用于多核处理器。</li><li><strong>CMS GC</strong>：并发标记-清除垃圾回收器，减少停顿时间。</li><li><strong>G1 GC</strong>：分代垃圾回收器，平衡停顿时间和吞吐量。</li></ul></li></ul><h2 id="线程管理"><a class="header-anchor" href="#线程管理"></a>线程管理</h2><p>JVM执行引擎负责管理Java线程的生命周期，包括线程的创建、调度和销毁。</p><ul><li>线程调度：<ul><li>JVM使用操作系统的线程调度机制来管理Java线程。</li><li>线程的状态包括新建、就绪、运行、阻塞、等待和终止。</li></ul></li><li>同步和并发：<ul><li>JVM提供了关键字<code>synchronized</code>和<code>volatile</code>，以及<code>java.util.concurrent</code>包，支持多线程编程和并发控制。</li></ul></li></ul><h2 id="方法调用和返回"><a class="header-anchor" href="#方法调用和返回"></a>方法调用和返回</h2><p>执行引擎负责处理Java方法的调用和返回，包括静态方法、实例方法、构造方法等。</p><ul><li>方法调用：<ul><li><strong>静态绑定</strong>：在编译时确定调用的方法（如静态方法和私有方法）。</li><li><strong>动态绑定</strong>：在运行时根据对象的实际类型确定调用的方法（如实例方法）。</li></ul></li><li><strong>方法返回</strong>：处理方法的返回值和返回指令，管理方法调用栈帧的创建和销毁。</li></ul><h2 id="异常处理"><a class="header-anchor" href="#异常处理"></a>异常处理</h2><p>执行引擎处理Java程序中的异常，包括捕获和抛出异常。</p><ul><li><strong>异常捕获</strong>：使用<code>try-catch</code>块捕获异常。</li><li><strong>异常抛出</strong>：使用<code>throw</code>语句抛出异常。</li><li><strong>异常处理机制</strong>：遍历调用栈，查找匹配的异常处理器。</li></ul><h2 id="本地方法调用"><a class="header-anchor" href="#本地方法调用"></a>本地方法调用</h2><p>JVM执行引擎通过本地方法接口（JNI）调用本地代码，实现与平台相关的功能。</p><ul><li><strong>JNI（Java Native Interface）</strong>：允许Java程序调用本地C/C++代码。</li><li><strong>本地方法库</strong>：加载和执行本地方法库（如<code>.dll</code>或<code>.so</code>文件）。</li></ul><h2 id="总结-2"><a class="header-anchor" href="#总结-2"></a>总结</h2><p>JVM字节码执行引擎主要包括以下功能：</p><ol><li><strong>解释执行字节码</strong>：逐条解释和执行字节码指令。</li><li><strong>JIT编译</strong>：将热点代码编译为本地机器码，提高执行效率。</li><li><strong>垃圾回收</strong>：自动管理内存，回收不再使用的对象。</li><li><strong>线程管理</strong>：管理Java线程的生命周期和调度。</li><li><strong>方法调用和返回</strong>：处理方法的调用、执行和返回。</li><li><strong>异常处理</strong>：捕获和处理Java异常。</li><li><strong>本地方法调用</strong>：通过JNI调用本地代码。</li></ol><h1>参考</h1><ul><li>《深入理解Java虚拟机》（第三版）</li><li><a href="https://javaguide.cn/java/jvm/class-file-structure.html">https://javaguide.cn/java/jvm/class-file-structure.html</a></li><li><a href="https://coolshell.cn/articles/9229.html">https://coolshell.cn/articles/9229.html</a></li><li><a href="https://javabetter.cn/jvm/class-file-jiegou.html">https://javabetter.cn/jvm/class-file-jiegou.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见SpringFox，你好SpringDoc</title>
      <link href="/2024/03/04/springdoc-hello/"/>
      <url>/2024/03/04/springdoc-hello/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>最近项目使用 SpringBoot 3 + Spring 6 搭建，接口文档准备一如既往的使用 Swagger 自动生成，引入 <code>springfox-boot-starter</code> 依赖，配置好相关的 Swagger 配置，结果启动报错，修改配置后启动不报错了，但是访问 swagger-ui/index.html 页面报404。</p><h2 id="问题分析"><a class="header-anchor" href="#问题分析"></a>问题分析</h2><p>一顿分析过后发现，最新的 springfox 3.0.0 （最后一次维护在2020年）仅支持 Spring 5.x，要想使用 springfox，最简单快捷的方式就是降版本，将 SpringBoot 的版本号从 3.x 修改为 2.7.x（或更低版本）。</p><p>新项目就是想体验最新的 SpringBoot 版本功能，这样一搞，岂不是本末倒置了，因此我就尝试了各种方法，企图通过修改 Spring Bean 属性等方式适配 Swagger ，结果发现 Spring 里面的对象属性是一层嵌一层，牵一发而动全身，菜鸡的我只好放弃。</p><p>企图尝试：</p><ol><li>注册 WebMvcConfigurer Bean，重写 <code>configurePathMatch(PathMatchConfigurer configurer)</code> 方法。</li><li>在 PathMatchConfigurer 对象中，修改 patternParser 属性为 null ，再修改 pathMatcher 属性不为空，使得 patternParser 为空并且 preferPathMatcher 等于 true。</li><li>从而会影响 WebMvcConfigurationSupport#initHandlerMapping 方法的条件判断，进而影响 AbstractHandlerMapping 的 patternParser 属性为空，而 pathMatcher 不为空。</li></ol><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240304165058399.png" alt="image-20240304165058399"></p><ol start="4"><li>AbstractHandlerMapping 的实例对象为 RequestMappingHandlerMapping ，其 afterPropertiesSet() 方法会根据 patternParser 属性作为条件判断，进而 RequestMappingInfo.BuilderConfiguration config 的 patternParser 属性为空并且 pathMatcher 属性不为空。</li></ol><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240304165617376.png" alt="image-20240304165617376"></p><ol start="5"><li>RequestMappingInfo.DefaultBuilder#build() 方法会调用 RequestMappingInfo.BuilderConfiguration#getPatternParserToUse() 方法，该方法会返回上一步配置的 patternParser 属性。从而影响 build() 方法的条件判断，实例化 PatternsRequestCondition 对象，最后在实例化 RequestMappingInfo 对象时，pathPatternsCondition 为空，而 patternsCondition 不为空。</li></ol><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240304165953003.png" alt="image-20240304165953003"></p><ol start="6"><li>然后，springfox 的 WebMvcRequestHandler#getPatternsCondition() 方法会拿取 RequestMappingInfo 的 patternsCondition 属性，作为参数实例化 WebMvcPatternsRequestConditionWrapper 对象。</li></ol><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240304170619406.png" alt="image-20240304170619406"></p><ol start="7"><li>最后，WebMvcPatternsRequestConditionWrapper#getPatterns() 方法在使用 PatternsRequestCondition 属性时就不会出现空指针情况，程序正常启动。</li></ol><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240304170853408.png" alt="image-20240304170853408"></p><h2 id="问题突破"><a class="header-anchor" href="#问题突破"></a>问题突破</h2><p>源码分析告一段落后，我就开始在网络遨游，寻找广大群众的力量，最终在 stackoverflow 上找到了解决方案，也是在此处第一次了解到 springdoc-openapi 。</p><p>先说解决方法的最核心东西，引入以下 maven 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果是 Spring Boot 1.x 或 2.x 的项目，springdoc-openapi 需要使用 1.x 的版本。</p><p>stackoverflow 帖子的链接地址：<a href="https://stackoverflow.com/questions/74614369/how-to-run-swagger-3-on-spring-boot-3">How to run Swagger 3 on Spring Boot 3</a></p><p>既然知道了可以使用 springdoc-openapi 解决，那就直接进入官方查看怎么使用。官方地址：<a href="https://springdoc.org/">springdoc.org</a></p><p>映入眼帘的介绍，让人为之心动，支持 SpringBoot 3 和 Swagger-ui ！！！</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240304171925138.png" alt="image-20240304171925138"></p><h2 id="使用SpringDoc-Openapi"><a class="header-anchor" href="#使用SpringDoc-Openapi"></a>使用SpringDoc Openapi</h2><p>第一步，引入 maven 依赖。</p><p>第二步，同 Swagger 一样，编写配置类，主要是 <code>GroupedOpenApi</code> 和 <code>OpenAPI</code> 两个类，详见 <a href="https://springdoc.org/#migrating-from-springfox">从 SpringFox 迁移</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GroupedOpenApi <span class="title function_">publicApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">            .group(<span class="string">&quot;springshop-public&quot;</span>)</span><br><span class="line">            .pathsToMatch(<span class="string">&quot;/public/**&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GroupedOpenApi <span class="title function_">adminApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">            .group(<span class="string">&quot;springshop-admin&quot;</span>)</span><br><span class="line">            .pathsToMatch(<span class="string">&quot;/admin/**&quot;</span>)</span><br><span class="line">            .addOpenApiMethodFilter(method -&gt; method.isAnnotationPresent(Admin.class))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OpenAPI <span class="title function_">springShopOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">            .info(<span class="keyword">new</span> <span class="title class_">Info</span>().title(<span class="string">&quot;SpringShop API&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;Spring shop sample application&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;v0.0.1&quot;</span>)</span><br><span class="line">            .license(<span class="keyword">new</span> <span class="title class_">License</span>().name(<span class="string">&quot;Apache 2.0&quot;</span>).url(<span class="string">&quot;http://springdoc.org&quot;</span>)))</span><br><span class="line">            .externalDocs(<span class="keyword">new</span> <span class="title class_">ExternalDocumentation</span>()</span><br><span class="line">            .description(<span class="string">&quot;SpringShop Wiki Documentation&quot;</span>)</span><br><span class="line">            .url(<span class="string">&quot;https://springshop.wiki.github.org/docs&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目仅有一个 <code>GroupedOpenApi</code> 配置类，那么可以直接配置在 application.properties 下，例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">springdoc.packagesToScan</span>=<span class="string">package1, package2</span></span><br><span class="line"><span class="attr">springdoc.pathsToMatch</span>=<span class="string">/v1, /api/balance/**</span></span><br></pre></td></tr></table></figure><p>第三步，对于 API Interface 和 API Model ，springdoc-openapi 与 swagger-annotation 略有不同，替换方案如下：</p><p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240304173127941.png" alt="image-20240304173127941"></p><p>其中 <code>@Schema</code> 注解等同于 Swagger 的 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 两个注解，不过在使用 <code>@Schema</code> 时需要注解，注解的 name 属性等同于 <code>@ApiModel</code> 的 value ，注解的 title 属性等同于 <code>@ApiModelProperty</code> 的 value 。</p><p>至此，springdoc-openapi 就配置完毕了，启动项目，访问 http://server:port/context-path/swagger-ui.html 。</p><p>springdoc-openapi 支持自定义访问路径，修改属性配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swagger-ui custom path</span></span><br><span class="line"><span class="attr">springdoc.swagger-ui.path</span>=<span class="string">/doc.html</span></span><br></pre></td></tr></table></figure><p>修改后，访问 http://server:port/context-path/doc.html 也是一样的效果，它都会转发为最终的地址 http://server:port/context-path/swagger-ui/index.html 。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springdoc </tag>
            
            <tag> swagger-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-Git内部原理</title>
      <link href="/2024/01/23/git-study-10/"/>
      <url>/2024/01/23/git-study-10/</url>
      
        <content type="html"><![CDATA[<h2 id="底层命令与上层命令"><a class="header-anchor" href="#底层命令与上层命令"></a>底层命令与上层命令</h2><p>Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统， 所以它还包含了一部分用于完成底层工作的子命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“上层（porcelain）”命令。</p><p>前面的章节中，探讨的都是上层命令，而在本章中，我们将主要面对底层命令。 因为，底层命令得以让你窥探 Git 内部的工作机制，也有助于说明 Git 是如何完成工作的，以及它为何如此运作。 多数底层命令并不面向最终用户：它们更适合作为新工具的组件和自定义脚本的组成部分。</p><p>当在一个新目录或已有目录执行 <code>git init</code> 时，Git 会创建一个 <code>.git</code> 目录。 这个目录包含了几乎所有 Git 存储和操作的东西。 如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。 本章探讨的所有内容，均位于这个目录内。 新初始化的 <code>.git</code> 目录的典型结构如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -F1</span></span><br><span class="line">config</span><br><span class="line">description</span><br><span class="line">HEAD</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></table></figure><p><code>description</code> 文件仅供 GitWeb 程序使用，我们无需关心。 <code>config</code> 文件包含项目特有的配置选项。 <code>info</code> 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 <code>.gitignore</code> 文件中的忽略模式（ignored patterns）。 <code>hooks</code> 目录包含客户端或服务端的钩子脚本（hook scripts）。</p><p>剩下的四个条目很重要：<code>HEAD</code> 文件、（尚待创建的）<code>index</code> 文件，和 <code>objects</code> 目录、<code>refs</code> 目录。 它们都是 Git 的核心组成部分。 <code>objects</code> 目录存储所有数据内容；<code>refs</code> 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针； <code>HEAD</code> 文件指向目前被检出的分支；<code>index</code> 文件保存暂存区信息。</p><h2 id="Git-对象"><a class="header-anchor" href="#Git-对象"></a>Git 对象</h2><p>Git 是一个内容寻址文件系统，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。</p><p>在一个 Git 版本库（尽量使用刚初始化的新版本库）下，用 <code>git hash-object</code> 创建一个新的数据对象并将它手动存入 Git 数据库中：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;test content&#x27;</span> | git hash-object -w --stdin</span></span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>在这种最简单的形式中，<code>git hash-object</code> 会接受你传给它的东西，而它只会返回可以存储在 Git 仓库中的唯一键。 <code>-w</code> 选项会指示该命令不要只返回键，还要将该对象写入数据库中。 最后，<code>--stdin</code> 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。</p><p>此命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。</p><p>使用 <code> find .git/objects -type f</code> 查看 Git 存储数据。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find .git/objects -<span class="built_in">type</span> f</span></span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>如果你再次查看 <code>objects</code> 目录，那么可以在其中找到一个与新内容对应的文件。 这就是开始时 Git 存储内容的方式——一个文件对应一条内容， 以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p><p>一旦你将内容存储在了对象数据库中，那么可以通过 <code>cat-file</code> 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 <code>cat-file</code> 指定 <code>-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span></span><br><span class="line">test content</span><br></pre></td></tr></table></figure><p>同样可以将这些操作应用于文件中的内容。 例如，可以对一个文件进行简单的版本控制。 首先，创建一个新文件并将其内容存入数据库：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;version 1&#x27;</span> &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git hash-object -w test.txt</span></span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></table></figure><p>接着，向文件里写入新内容，并再次将其存入数据库：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;version 2&#x27;</span> &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git hash-object -w test.txt</span></span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br></pre></td></tr></table></figure><p>对象数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find .git/objects -<span class="built_in">type</span> f</span></span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>现在可以在删掉 <code>test.txt</code> 的本地副本，然后用 Git 从对象数据库中取回它的第一个版本：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br><span class="line">version 1</span><br></pre></td></tr></table></figure><p>或者第二个版本：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br><span class="line">version 2</span><br></pre></td></tr></table></figure><p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为 <strong>数据对象（blob object）</strong>。 利用 <code>git cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span></span><br><span class="line">blob</span><br></pre></td></tr></table></figure><h3 id="树对象"><a class="header-anchor" href="#树对象"></a>树对象</h3><p>树对象（tree object）解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 <strong>所有内容均以树对象和数据对象的形式存储</strong>，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p><p>使用 <code>git cat-file -p main^&#123;tree&#125;</code> 命令，查看项目 main 分支下最新树对象。</p><p><img src="/2024/01/23/git-study-10/image-20240130152921901.png" alt="image-20240130152921901"></p><p>其中 lib 表示一个指针，其指向的是另一个树对象，通过 <code>git cat-file -p &lt;SHA-1&gt;</code> 查看树对象下的对象结构。</p><p><img src="/2024/01/23/git-study-10/image-20240130153109433.png" alt="image-20240130153109433"></p><p>通过 <code>git update-index</code> 命令，可以直接从底层创建树对象。通常情况下，Git 根据某一时刻暂存区（即 index 区域）所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录（某个时间段内）一系列的树对象。</p><p>可以通过底层命令 <code>git update-index</code> 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。 利用该命令，可以把 <code>test.txt</code> 文件的首个版本人为地加入一个新的暂存区。 必须为上述命令指定 <code>--add</code> 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）； 同样必需的还有 <code>--cacheinfo</code> 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。 同时，需要指定文件模式、SHA-1 与文件名：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git update-index --add --cacheinfo 100644 \</span></span><br><span class="line"><span class="language-bash">  83baae61804e65cc73a7201a7252750c76066a30 test.txt</span></span><br></pre></td></tr></table></figure><p>指定的文件模式为 <code>100644</code>，表明这是一个普通文件。 其他选择包括：<code>100755</code>，表示一个可执行文件；<code>120000</code>，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p><p>通过 <code>git write-tree</code> 命令将暂存区内容写入一个树对象。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git write-tree</span></span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span></span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</span><br></pre></td></tr></table></figure><p><code>git write-tree</code> 返回的 SHA-1 值是当前目录下的树对象值，通过 <code>git cat-file</code> 查看树对象，可以发现 test.txt 被添加到当前树对象下了，其 SHA-1 值就是 <code>git update-index</code> 指定的值。</p><p>再次进行操作，添加一个新文件，并对 test.txt 文件做修改后再暂存。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;new file&#x27;</span> &gt; new.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git update-index --add --cacheinfo 100644 \</span></span><br><span class="line"><span class="language-bash">  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git update-index --add new.txt</span></span><br></pre></td></tr></table></figure><p>暂存区现在包含了 <code>test.txt</code> 文件的新版本，和一个新文件：<code>new.txt</code>。 记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git write-tree</span></span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span></span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><p>我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（<code>1f7a7a</code>）是先前值的“第二版”。</p><h3 id="提交对象"><a class="header-anchor" href="#提交对象"></a>提交对象</h3><p>树对象的操作中，会出现不同版本的快照，每个快照会对应不用的 SHA-1 哈希值，在没有提交之前，是无法记录这些快照在什么时刻保存的，以及为什么保存这些快照的。</p><p>通过 <code>git commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;commit-tree 1&#x27;</span> | git commit-tree 2ed7</span> </span><br><span class="line">b4f6196421ede1205a6e8affdba8a23b741e762a</span><br></pre></td></tr></table></figure><p>由于创建时间和作者数据不同，你现在会得到一个不同的散列值。 请将本章后续内容中的提交和标签的散列值替换为你自己的校验和。 现在可以通过 <code>git cat-file</code> 命令查看这个新提交对象：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p b4f619</span></span><br><span class="line">tree 2ed706a25355ec1a647e0d54971bcc3426f6cfb6</span><br><span class="line">author Wray &lt;wray20156294@gmail.com&gt; 1706601067 +0800</span><br><span class="line">committer Wray &lt;wray20156294@gmail.com&gt; 1706601067 +0800</span><br><span class="line"></span><br><span class="line">commit-tree 1</span><br></pre></td></tr></table></figure><p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照； 然后是可能存在的父提交（前面描述的提交对象并不存在任何父提交）； 之后是作者/提交者信息（依据你的 <code>user.name</code> 和 <code>user.email</code> 配置来设定，外加一个时间戳）； 留空一行，最后是提交注释。</p><p>将 <code>2ed7</code> 树对象指定父对象为 <code>f9bba3</code> ，将提交记录挂载到父提交记录上。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;commit-tree 1&#x27;</span> | git commit-tree 2ed7 -p f9bba34</span></span><br><span class="line">3ffffc279924563d89505e654eb42bb8daa64a60</span><br></pre></td></tr></table></figure><p>通过 <code>git log</code> 查看 <code>3ffffc</code> 下的提交日志。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --<span class="built_in">stat</span> 3ffffc</span></span><br><span class="line">commit 3ffffc279924563d89505e654eb42bb8daa64a60</span><br><span class="line">Author: Wray &lt;wray20156294@gmail.com&gt;</span><br><span class="line">Date:   Tue Jan 30 15:54:31 2024 +0800</span><br><span class="line"></span><br><span class="line">    commit-tree 1</span><br><span class="line"></span><br><span class="line"> pro.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">commit f9bba34686b949ce2e359bdfbdc7c855d32dc811 (HEAD -&gt; main)</span><br><span class="line">Author: Wray &lt;wray20156294@gmail.com&gt;</span><br><span class="line">Date:   Tue Jan 30 15:29:08 2024 +0800</span><br><span class="line"></span><br><span class="line">    new lib dir</span><br><span class="line"></span><br><span class="line"> lib/a         | 1 +</span><br><span class="line"> lib/print.out | 1 +</span><br><span class="line"> test.txt      | 1 +</span><br><span class="line"> 3 files changed, 3 insertions(+)</span><br><span class="line"></span><br><span class="line">commit 46eee871bcaa6acbc3568b2e1af69fa5bca2500c</span><br><span class="line">Author: Wray &lt;wray20156294@gmail.com&gt;</span><br><span class="line">Date:   Tue Jan 23 16:13:14 2024 +0800</span><br><span class="line"></span><br><span class="line">    commit 1</span><br><span class="line"></span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>可以发现，在没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。 这就是每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。</p><p>这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 <code>.git/objects</code> 目录下。</p><h2 id="Git-引用"><a class="header-anchor" href="#Git-引用"></a>Git 引用</h2><p>如果你对仓库中从一个提交（比如 <code>1a410e</code>）开始往前的历史感兴趣，那么可以运行 <code>git log 1a410e</code> 这样的命令来显示历史，不过你需要记得 <code>1a410e</code> 是你查看历史的起点提交。 如果我们有一个文件来保存 SHA-1 值，而该文件有一个简单的名字， 然后用这个名字指针来替代原始的 SHA-1 值的话会更加简单。</p><p>在 Git 中，这种简单的名字被称为“引用（references，或简写为 refs）”。 你可以在 <code>.git/refs</code> 目录下找到这类含有 SHA-1 值的文件。 在目前的项目中，这个目录没有包含任何文件，但它包含了一个简单的目录结构：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find .git/refs</span></span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find .git/refs -<span class="built_in">type</span> f</span></span><br></pre></td></tr></table></figure><p>通过 <code>git update-ref</code> 更新引用，若想在第二个提交上创建一个分支，可以这么做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git update-ref refs/heads/test cac0ca</span></span><br></pre></td></tr></table></figure><p>这个分支将只包含从第二个提交开始往前追溯的记录：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline <span class="built_in">test</span></span></span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure><h3 id="HEAD文件"><a class="header-anchor" href="#HEAD文件"></a>HEAD文件</h3><p>现在的问题是，当你执行 <code>git branch &lt;branch&gt;</code> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p><p>HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的指针。</p><h3 id="标签引用"><a class="header-anchor" href="#标签引用"></a>标签引用</h3><p>前面我们刚讨论过 Git 的三种主要的对象类型（<strong>数据对象</strong>、<strong>树对象</strong> 和 <strong>提交对象</strong> ），然而实际上还有第四种。 <strong>标签对象（tag object）</strong> 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><h3 id="远程引用"><a class="header-anchor" href="#远程引用"></a>远程引用</h3><p>如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 <code>refs/remotes</code> 目录下。 例如，你可以添加一个叫做 <code>origin</code> 的远程版本库，然后把 <code>master</code> 分支推送上去：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin git@github.com:schacon/simplegit-progit.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br><span class="line">Counting objects: 11, done.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (7/7), 716 bytes, done.</span><br><span class="line">Total 7 (delta 2), reused 4 (delta 1)</span><br><span class="line">To git@github.com:schacon/simplegit-progit.git</span><br><span class="line">  a11bef0..ca82a6d  master -&gt; master</span><br></pre></td></tr></table></figure><p>此时，如果查看 <code>refs/remotes/origin/master</code> 文件，可以发现 <code>origin</code> 远程版本库的 <code>master</code> 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 <code>master</code> 分支所对应的 SHA-1 值：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .git/refs/remotes/origin/master</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure><p>远程引用和分支（位于 <code>refs/heads</code> 目录下的引用）之间最主要的区别在于，远程引用是只读的。 虽然可以 <code>git checkout</code> 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 <code>commit</code> 命令来更新远程引用。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p><h2 id="包文件"><a class="header-anchor" href="#包文件"></a>包文件</h2><p>Git 仓库最初的时候，Git 对同一个文件的不同版本会保留源文件，而不是只完整保存其中一个，再保存另一个对象与之前版本的差异内容。</p><p>但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。</p><p>Git 是如何做到这点的？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。 你可以查看包文件，观察它是如何节省空间的。 <code>git verify-pack</code> 这个底层命令可以让你查看已打包的内容。</p><h2 id="引用规范"><a class="header-anchor" href="#引用规范"></a>引用规范</h2><p>现在想要添加一个远程仓库：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin https://github.com/schacon/simplegit-progit</span></span><br></pre></td></tr></table></figure><p>运行上述命令会在你仓库中的 <code>.git/config</code> 文件中添加一个小节， 并在其中指定远程版本库的名称（<code>origin</code>）、URL 和一个用于获取操作的 <strong>引用规范（refspec）</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote &quot;origin&quot;]</span></span><br><span class="line"><span class="attr">url</span> = https://github.com/schacon/simplegit-progit</span><br><span class="line"><span class="attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure><p>引用规范的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成， 其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用； <code>&lt;dst&gt;</code> 是本地跟踪的远程引用的位置。 <code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p><p>默认情况下，引用规范由 <code>git remote add origin</code> 命令自动生成， Git 获取服务器中 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code> 中。 所以，如果服务器上有一个 <code>master</code> 分支，你可以在本地通过下面任意一种方式来访问该分支上的提交记录：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> origin/master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> remotes/origin/master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> refs/remotes/origin/master</span></span><br></pre></td></tr></table></figure><p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 <code>refs/remotes/origin/master</code>。</p><p>如果想让 Git 每次只拉取远程的 <code>master</code> 分支，而不是所有分支， 可以把（引用规范的）获取那一行修改为只引用该分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/master:refs/remotes/origin/master</span><br></pre></td></tr></table></figure><p>这仅是针对该远程版本库的 <code>git fetch</code> 操作的默认引用规范。 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规范。 若要将远程的 <code>master</code> 分支拉到本地的 <code>origin/mymaster</code> 分支，可以运行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin master:refs/remotes/origin/mymaster</span></span><br></pre></td></tr></table></figure><h2 id="传输协议"><a class="header-anchor" href="#传输协议"></a>传输协议</h2><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p><h3 id="哑协议"><a class="header-anchor" href="#哑协议"></a>哑协议</h3><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><h3 id="智能协议"><a class="header-anchor" href="#智能协议"></a>智能协议</h3><p>智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><p>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</p><p>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续传输的数据。</p><h2 id="维护与数据恢复"><a class="header-anchor" href="#维护与数据恢复"></a>维护与数据恢复</h2><p>有的时候，你需要对仓库进行清理——使它的结构变得更紧凑，或是对导入的仓库进行清理，或是恢复丢失的内容。</p><h3 id="维护"><a class="header-anchor" href="#维护"></a>维护</h3><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。 大多数时候，这个命令并不会产生效果。 然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 <code>git gc</code> 命令。 “gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中， 将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p><p>可以像下面一样手动执行自动垃圾回收：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git gc --auto</span></span><br></pre></td></tr></table></figure><p>就像上面提到的，这个命令通常并不会产生效果。 大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令。 你可以通过修改 <code>gc.auto</code> 与 <code>gc.autopacklimit</code> 的设置来改动这些数值。</p><h3 id="数据恢复"><a class="header-anchor" href="#数据恢复"></a>数据恢复</h3><p>在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支， 亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？</p><p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。 当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 引用日志（reflog）也可以通过 <code>git update-ref</code> 命令更新，我们在 <em>Git 引用</em> 有提到使用这个命令而不是是直接将 SHA-1 的值写入引用文件中的原因。</p><h3 id="移除对象"><a class="header-anchor" href="#移除对象"></a>移除对象</h3><p>Git 有很多很棒的功能，但是其中一个特性会导致问题，<code>git clone</code> 会下载整个项目的历史，包括每一个文件的每一个版本。 如果所有的东西都是源代码那么这很好，因为 Git 被高度优化来有效地存储这种数据。 然而，如果某个人在之前向项目添加了一个大小特别大的文件，即使你将这个文件从项目中移除了，每次克隆还是都要强制的下载这个大文件。 之所以会产生这个问题，是因为这个文件在历史中是存在的，它会永远在那里。</p><p><strong>警告：这个操作对提交历史的修改是破坏性的。</strong> 它会从你必须修改或移除一个大文件引用最早的树对象开始重写每一次提交。 如果你在导入仓库后，在任何人开始基于这些提交工作前执行这个操作，那么将不会有任何问题——否则， 你必须通知所有的贡献者他们需要将他们的成果变基到你的新提交上。</p><p>必须使用 <code>git rm --cached</code> 命令来移除文件，而不是通过类似 <code>rm file</code> 的命令——因为你需要从索引中移除它，而不是磁盘中。 还有一个原因是速度—— Git 在运行过滤器时，并不会检出每个修订版本到磁盘中，所以这个过程会非常快。</p><h2 id="环境变量"><a class="header-anchor" href="#环境变量"></a>环境变量</h2><p>Git 总是在一个 <code>bash</code> shell 中运行，并借助一些 shell 环境变量来决定它的运行方式。 有</p><h3 id="全局行为"><a class="header-anchor" href="#全局行为"></a>全局行为</h3><p>像通常的程序一样，Git 的常规行为依赖于环境变量。</p><p><strong><code>GIT_EXEC_PATH</code></strong> 决定 Git 到哪找它的子程序 （像 <code>git-commit</code>, <code>git-diff</code> 等等）。 你可以用 <code>git --exec-path</code> 来查看当前设置。</p><p>通常不会考虑修改 <strong><code>HOME</code></strong> 这个变量（太多其它东西都依赖它），这是 Git 查找全局配置文件的地方。 如果你想要一个包括全局配置的真正的便携版 Git， 你可以在便携版 Git 的 shell 配置中覆盖 <code>HOME</code> 设置。</p><p><strong><code>PREFIX</code></strong> 也类似，除了用于系统级别的配置。 Git 在 <code>$PREFIX/etc/gitconfig</code> 查找此文件。</p><p>如果设置了 <strong><code>GIT_CONFIG_NOSYSTEM</code></strong>，就禁用系统级别的配置文件。 这在系统配置影响了你的命令，而你又无权限修改的时候很有用。</p><p><strong><code>GIT_PAGER</code></strong> 控制在命令行上显示多页输出的程序。 如果这个没有设置，就会用 <code>PAGER</code> 。</p><p><strong><code>GIT_EDITOR</code></strong> 当用户需要编辑一些文本（比如提交信息）时， Git 会启动这个编辑器。 如果没设置，就会用 <code>EDITOR</code> 。</p><h3 id="版本库位置"><a class="header-anchor" href="#版本库位置"></a>版本库位置</h3><p>Git 用了几个变量来确定它如何与当前版本库交互。</p><p><strong><code>GIT_DIR</code></strong> 是 <code>.git</code> 目录的位置。 如果这个没有设置， Git 会按照目录树逐层向上查找 <code>.git</code> 目录，直到到达 <code>~</code> 或 <code>/</code>。</p><p><strong><code>GIT_CEILING_DIRECTORIES</code></strong> 控制查找 <code>.git</code> 目录的行为。 如果你访问加载很慢的目录（如那些磁带机上的或通过网络连接访问的），你可能会想让 Git 早点停止尝试，尤其是 shell 构建时调用了 Git 。</p><p><strong><code>GIT_WORK_TREE</code></strong> 是非空版本库的工作目录的根路径。 如果指定了 <code>--git-dir</code> 或 <code>GIT_DIR</code> 但未指定 <code>--work-tree</code>、<code>GIT_WORK_TREE</code> 或 <code>core.worktree</code>，那么当前工作目录就会视作工作树的顶级目录。</p><p><strong><code>GIT_INDEX_FILE</code></strong> 是索引文件的路径（只有非空版本库有）。</p><p><strong><code>GIT_OBJECT_DIRECTORY</code></strong> 用来指定 <code>.git/objects</code> 目录的位置。</p><p><strong><code>GIT_ALTERNATE_OBJECT_DIRECTORIES</code></strong> 一个冒号分割的列表（格式类似 <code>/dir/one:/dir/two:…</code>）用来告诉 Git 到哪里去找不在 <code>GIT_OBJECT_DIRECTORY</code> 目录中的对象。 如果你有很多项目有相同内容的大文件，这个可以用来避免存储过多备份。</p><h3 id="路径规则"><a class="header-anchor" href="#路径规则"></a>路径规则</h3><p>所谓 “pathspec” 是指你在 Git 中如何指定路径，包括通配符的使用。 它们会在 <code>.gitignore</code> 文件中用到，命令行里也会用到（<code>git add *.c</code>）。</p><p><strong><code>GIT_GLOB_PATHSPECS</code></strong> 和 <strong><code>GIT_NOGLOB_PATHSPECS</code></strong> 控制通配符在路径规则中的默认行为。 如果 <code>GIT_GLOB_PATHSPECS</code> 设置为 1, 通配符表现为通配符（这是默认设置）; 如果 <code>GIT_NOGLOB_PATHSPECS</code> 设置为 1,通配符仅匹配字面。意思是 <code>*.c</code> 只会匹配 <em>文件名是</em> “*.c” 的文件，而不是以 <code>.c</code> 结尾的文件。 你可以在各个路径规范中用 <code>:(glob)</code> 或 <code>:(literal)</code> 开头来覆盖这个配置，如 <code>:(glob)*.c</code> 。</p><p><strong><code>GIT_LITERAL_PATHSPECS</code></strong> 禁用上面的两种行为；通配符将不能用，前缀覆盖也不能用。</p><p><strong><code>GIT_ICASE_PATHSPECS</code></strong> 让所有的路径规范忽略大小写。</p><h3 id="提交"><a class="header-anchor" href="#提交"></a>提交</h3><p>Git 提交对象的创建通常最后是由 <code>git-commit-tree</code> 来完成， <code>git-commit-tree</code> 用这些环境变量作主要的信息源。 仅当这些值不存在才回退到预置的值。</p><p><strong><code>GIT_AUTHOR_NAME</code></strong> 是 “author” 字段的可读名字。</p><p><strong><code>GIT_AUTHOR_EMAIL</code></strong> 是 “author” 字段的邮件。</p><p><strong><code>GIT_AUTHOR_DATE</code></strong> 是 “author” 字段的时间戳。</p><p><strong><code>GIT_COMMITTER_NAME</code></strong> 是 “committer” 字段的可读名字。</p><p><strong><code>GIT_COMMITTER_EMAIL</code></strong> 是 “committer” 字段的邮件。</p><p><strong><code>GIT_COMMITTER_DATE</code></strong> 是 “committer” 字段的时间戳。</p><p>如果 <code>user.email</code> 没有配置， 就会用到 <strong><code>EMAIL</code></strong> 指定的邮件地址。 如果 <em>这个</em> 也没有设置， Git 继续回退使用系统用户和主机名。</p><h3 id="网络"><a class="header-anchor" href="#网络"></a>网络</h3><p>Git 使用 <code>curl</code> 库通过 HTTP 来完成网络操作， 所以 <strong><code>GIT_CURL_VERBOSE</code></strong> 告诉 Git 显示所有由那个库产生的消息。 这跟在命令行执行 <code>curl -v</code> 差不多。</p><p><strong><code>GIT_SSL_NO_VERIFY</code></strong> 告诉 Git 不用验证 SSL 证书。 这在有些时候是需要的， 例如你用一个自己签名的证书通过 HTTPS 来提供 Git 服务， 或者你正在搭建 Git 服务器，还没有安装完全的证书。</p><p>如果 Git 操作在网速低于 <strong><code>GIT_HTTP_LOW_SPEED_LIMIT</code></strong> 字节／秒，并且持续 <strong><code>GIT_HTTP_LOW_SPEED_TIME</code></strong> 秒以上的时间，Git 会终止那个操作。 这些值会覆盖 <code>http.lowSpeedLimit</code> 和 <code>http.lowSpeedTime</code> 配置的值。</p><p><strong><code>GIT_HTTP_USER_AGENT</code></strong> 设置 Git 在通过 HTTP 通讯时用到的 user-agent。 默认值类似于 <code>git/2.0.0</code> 。</p><h3 id="比较和合并"><a class="header-anchor" href="#比较和合并"></a>比较和合并</h3><p><strong><code>GIT_DIFF_OPTS</code></strong> 这个有点起错名字了。 有效值仅支持 <code>-u&lt;n&gt;</code> 或 <code>--unified=&lt;n&gt;</code>，用来控制在 <code>git diff</code> 命令中显示的内容行数。</p><p><strong><code>GIT_EXTERNAL_DIFF</code></strong> 用来覆盖 <code>diff.external</code> 配置的值。 如果设置了这个值， 当执行 <code>git diff</code> 时，Git 会调用该程序。</p><p><strong><code>GIT_DIFF_PATH_COUNTER</code></strong> 和 <strong><code>GIT_DIFF_PATH_TOTAL</code></strong> 对于 <code>GIT_EXTERNAL_DIFF</code> 或 <code>diff.external</code> 指定的程序有用。 前者表示在一系列文件中哪个是被比较的（从 1 开始），后者表示每批文件的总数。</p><p><strong><code>GIT_MERGE_VERBOSITY</code></strong> 控制递归合并策略的输出。 允许的值有下面这些：</p><ul><li>0 什么都不输出，除了可能会有一个错误信息。</li><li>1 只显示冲突。</li><li>2 还显示文件改变。</li><li>3 显示因为没有改变被跳过的文件。</li><li>4 显示处理的所有路径。</li><li>5 显示详细的调试信息。</li></ul><p>默认值是 2。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>本章讨论了很多底层命令，这些命令比我们在本书其余部分学到的高层命令来得更原始，也更简洁。 从底层了解 Git 的工作原理有助于更好地理解 Git 在内部是如何运作的，也方便你能够针对特定的工作流写出自己的工具和脚本。</p><p>作为一套内容寻址文件系统，Git 不仅仅是一个版本控制系统，它同时是一个非常强大且易用的工具。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-Git与其他系统</title>
      <link href="/2024/01/22/git-study-9/"/>
      <url>/2024/01/22/git-study-9/</url>
      
        <content type="html"><![CDATA[<h2 id="作为客户端的-Git"><a class="header-anchor" href="#作为客户端的-Git"></a>作为客户端的 Git</h2><p>在开发中接触到的项目，可能已经使用了其他 VCS ，并且暂时没有迁移到 Git 的打算。可以在本地使用 Git 客户端用作平时版本控制，Git 原生支持对其他 VCS 系统自然对接，例如 Subversion 。</p><p>在 Git 中所有 Subversion 桥接命令的基础命令是 <code>git svn</code>。需要特别注意的是当你使用 <code>git svn</code> 时，就是在与 Subversion 打交道，一个与 Git 完全不同的系统。 尽管 <strong>可以</strong> 在本地新建分支与合并分支，但是你最好还是通过变基你的工作来保证你的历史尽可能是直线，并且避免做类似同时与 Git 远程服务器交互的事情。</p><h2 id="迁移到-Git"><a class="header-anchor" href="#迁移到-Git"></a>迁移到 Git</h2><p>如果你现在有一个正在使用其他 VCS 的代码库，但是你已经决定开始使用 Git，必须通过某种方式将你的项目迁移至 Git。</p><p>如果之前使用 Subversion ，则可以直接涌过 <code>git svn clone</code> 迁移仓库。</p><p>如果之前使用 Mercurial ，则需要使用一个叫作“hg-fast-export”的工具，需要从这里拷贝一份：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/frej/fast-export.git</span></span><br></pre></td></tr></table></figure><p>转换的第一步就是要先得到想要转换的 Mercurial 仓库的完整克隆：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hg <span class="built_in">clone</span> &lt;remote repo URL&gt; /tmp/hg-repo</span></span><br></pre></td></tr></table></figure><p>下一步就是创建一个作者映射文件。 Mercurial 对放入到变更集作者字段的内容比 Git 更宽容一些，所以这是一个清理的好机会。 只需要用到 <code>bash</code> 终端下的一行命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /tmp/hg-repo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hg <span class="built_in">log</span> | grep user: | <span class="built_in">sort</span> | <span class="built_in">uniq</span> | sed <span class="string">&#x27;s/user: *//&#x27;</span> &gt; ../authors</span></span><br></pre></td></tr></table></figure><p>下一步是创建一个新的 Git 仓库，然后运行导出脚本：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init /tmp/converted</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /tmp/converted</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</span></span><br></pre></td></tr></table></figure><p><code>-r</code> 选项告诉 hg-fast-export 去哪里寻找我们想要转换的 Mercurial 仓库，<code>-A</code> 标记告诉它在哪找到作者映射文件（分支和标签的映射文件分别通过 <code>-B</code> 和 <code>-T</code> 选项来指定）。 这个脚本会分析 Mercurial 变更集然后将它们转换成 Git“fast-import”功能需要的脚本。</p><p>所有 Mercurial 标签都已被转换成 Git 标签，Mercurial 分支与书签都被转换成 Git 分支。 现在已经准备好将仓库推送到新的服务器那边：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin git@my-git-server:myrepository.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --all</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>本章参考价值较小，具体细节和实践示例可以看原文：<a href="https://git-scm.com/book/zh/v2/Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F-%E8%BF%81%E7%A7%BB%E5%88%B0-Git">Git 与其他系统 - 迁移到 Git</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-自定义Git</title>
      <link href="/2024/01/22/git-study-8/"/>
      <url>/2024/01/22/git-study-8/</url>
      
        <content type="html"><![CDATA[<h2 id="配置-Git"><a class="header-anchor" href="#配置-Git"></a>配置 Git</h2><p>在安装 Git 后，首先要做的事就是配置 Git 的提交者的名称和邮件地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Wray&quot;</span><br><span class="line">git config --global user.email wray20156294@gmail.com</span><br></pre></td></tr></table></figure><p>现在，将会讲解除了配置 Git 提交者信息以外的其他配置信息。</p><p>首先，快速回忆下：Git 使用一系列配置文件来保存你自定义的行为。 它首先会查找系统级的 <code>/etc/gitconfig</code> 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 <code>--system</code> 选项给 <code>git config</code>，它就会读写该文件。</p><p>接下来 Git 会查找每个用户的 <code>~/.gitconfig</code> 文件（或者 <code>~/.config/git/config</code> 文件）。 你可以传递 <code>--global</code> 选项让 Git 读写该文件。</p><p>最后 Git 会查找你正在操作的仓库所对应的 Git 目录下的配置文件（<code>.git/config</code>）。 这个文件中的值只对该仓库有效，它对应于向 <code>git config</code> 传递 <code>--local</code> 选项。</p><p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 <code>.git/config</code> 中的值会覆盖掉 <code>/etc/gitconfig</code> 中所对应的值。</p><blockquote><p>Git 的配置文件是纯文本的，所以你可以直接手动编辑这些配置文件，输入合乎语法的值。 但是运行 <code>git config</code> 命令会更简单些。</p></blockquote><h3 id="客户端基础配置"><a class="header-anchor" href="#客户端基础配置"></a>客户端基础配置</h3><p>Git 能够识别的配置项分为两大类：客户端和服务器端。 其中大部分属于客户端配置 —— 可以依你个人的工作偏好进行配置。</p><p>如果想得到本地当前版本的 Git 支持的选项列表，可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man git-config</span><br></pre></td></tr></table></figure><p>下面主要讲解平常实用的部分命令。</p><h4 id="core-editor"><a class="header-anchor" href="#core-editor"></a>core.editor</h4><p>默认情况下，Git 会调用你通过环境变量 <code>$VISUAL</code> 或 <code>$EDITOR</code> 设置的文本编辑器， 如果没有设置，默认则会调用 <code>vi</code> 来创建和编辑你的提交以及标签信息。 你可以使用 <code>core.editor</code> 选项来修改默认的编辑器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><p>现在，无论你定义了什么终端编辑器，Git 都会调用 Emacs 编辑信息。</p><h4 id="commit-template"><a class="header-anchor" href="#commit-template"></a>commit.template</h4><p>如果把此项指定为你的系统上某个文件的路径，当你提交的时候， Git 会使用该文件的内容作为提交的默认初始化信息。 创建的自定义提交模版中的值可以用来提示自己或他人适当的提交格式和风格。</p><h4 id="core-pager"><a class="header-anchor" href="#core-pager"></a>core.pager</h4><p>该配置项指定 Git 运行诸如 <code>log</code> 和 <code>diff</code> 等命令所使用的分页器。 你可以把它设置成用 <code>more</code> 或者任何你喜欢的分页器（默认用的是 <code>less</code>），当然也可以设置成空字符串，关闭该选项：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.pager <span class="string">&#x27;&#x27;</span></span></span><br></pre></td></tr></table></figure><p>这样不管命令的输出量多少，Git 都会在一页显示所有内容。</p><h4 id="user-signingkey"><a class="header-anchor" href="#user-signingkey"></a>user.signingkey</h4><p>如果你要创建经签署的含附注的标签， 那么把你的 GPG 签署密钥设置为配置项会更好。如下设置你的密钥 ID：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.signingkey &lt;gpg-key-id&gt;</span></span><br></pre></td></tr></table></figure><p>现在，你每次运行 <code>git tag</code> 命令时，即可直接签署标签，而无需定义密钥：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -s &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><h4 id="core-excludesfile"><a class="header-anchor" href="#core-excludesfile"></a>core.excludesfile</h4><p>你可以在你的项目的 <code>.gitignore</code> 文件里面规定无需纳入 Git 管理的文件的模板，这样它们既不会出现在未跟踪列表， 也不会在你运行 <code>git add</code> 后被暂存。</p><p>不过有些时候，你想要在你所有的版本库中忽略掉某一类文件。 如果你的操作系统是 macOS，很可能就是指 <code>.DS_Store</code>。 如果你把 Emacs 或 Vim 作为首选的编辑器，你肯定知道以 <code>~</code> 结尾的文件名。</p><p>这个配置允许你设置类似于全局生效的 <code>.gitignore</code> 文件。 如果你按照下面的内容创建一个 <code>~/.gitignore_global</code> 文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*~</span><br><span class="line">.*.swp</span><br><span class="line">.DS_Store</span><br></pre></td></tr></table></figure><p>然后运行 <code>git config --global core.excludesfile ~/.gitignore_global</code>，Git 将把那些文件永远地拒之门外。</p><h4 id="help-autocorrect"><a class="header-anchor" href="#help-autocorrect"></a>help.autocorrect</h4><p>假如你打错了一条命令，会显示：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git chekcout master</span></span><br><span class="line">git：&#x27;chekcout&#x27; 不是一个 git 命令。参见 &#x27;git --help&#x27;。</span><br><span class="line"></span><br><span class="line">您指的是这个么？</span><br><span class="line">  checkout</span><br></pre></td></tr></table></figure><p>Git 会尝试猜测你的意图，但是它不会越俎代庖。 如果你把 <code>help.autocorrect</code> 设置成 1，那么只要有一个命令被模糊匹配到了，Git 会自动运行该命令。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git chekcout master</span></span><br><span class="line">警告：您运行一个不存在的 Git 命令 &#x27;chekcout&#x27;。继续执行假定您要要运行的</span><br><span class="line">是 &#x27;checkout&#x27;</span><br><span class="line">在 0.1 秒钟后自动运行...</span><br></pre></td></tr></table></figure><p>注意提示信息中的“0.1 秒”。<code>help.autocorrect</code> 接受一个代表十分之一秒的整数。 所以如果你把它设置为 50, Git 将在自动执行命令前给你 5 秒的时间改变主意。</p><h4 id="color"><a class="header-anchor" href="#color"></a>color.*</h4><p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。 要想关掉 Git 的终端颜色输出，试一下这个：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global color.ui <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><p>这个设置的默认值是 <code>auto</code>，它会着色直接输出到终端的内容；而当内容被重定向到一个管道或文件时，则忽略着色功能。</p><p>你也可以设置成 <code>always</code>，来忽略掉管道和终端的不同，即在任何情况下着色输出。 你很少会这么设置，在大多数场合下，如果你想在被重定向的输出中插入颜色码，可以传递 <code>--color</code> 标志给 Git 命令来强制它这么做。 默认设置就已经能满足大多数情况下的需求了。</p><p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。 它们都能被置为 <code>true</code>、<code>false</code> 或 <code>always</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color.branch</span><br><span class="line">color.diff</span><br><span class="line">color.interactive</span><br><span class="line">color.status</span><br></pre></td></tr></table></figure><p>另外，以上每个配置项都有子选项，它们可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。 例如，为了让 <code>diff</code> 的输出信息以蓝色前景、黑色背景和粗体显示，你可以运行</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global color.diff.meta <span class="string">&quot;blue black bold&quot;</span></span></span><br></pre></td></tr></table></figure><p>你能设置的颜色有：<code>normal</code>、<code>black</code>、<code>red</code>、<code>green</code>、<code>yellow</code>、<code>blue</code>、<code>magenta</code>、<code>cyan</code> 或 <code>white</code>。 正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择包括：<code>bold</code>、<code>dim</code>、<code>ul</code>（下划线）、<code>blink</code>、<code>reverse</code>（交换前景色和背景色）。</p><h4 id="core-autocrlf"><a class="header-anchor" href="#core-autocrlf"></a>core.autocrlf</h4><p>假如你正在 Windows 上写程序，而你的同伴用的是其他系统（或相反），你可能会遇到 CRLF 问题。 这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 macOS 和 Linux 只使用换行（LF）一个字符。 虽然这是小问题，但它会极大地扰乱跨平台协作。许多 Windows 上的编辑器会悄悄把行尾的换行字符转换成回车和换行， 或在用户按下 Enter 键时，插入回车和换行两个字符。</p><p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。 你可以用 <code>core.autocrlf</code> 来打开此项功能。 如果是在 Windows 系统上，把它设置成 <code>true</code>，这样在检出代码时，换行会被转换成回车和换行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.autocrlf <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>如果使用以换行作为行结束符的 Linux 或 macOS，你不需要 Git 在检出文件时进行自动的转换； 然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 你可以把 <code>core.autocrlf</code> 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.autocrlf input</span></span><br></pre></td></tr></table></figure><p>这样在 Windows 上的检出文件中会保留回车和换行，而在 macOS 和 Linux 上，以及版本库中会保留换行。</p><p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 <code>false</code> 取消此功能，把回车保留在版本库中：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.autocrlf <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><h4 id="core-whitespace"><a class="header-anchor" href="#core-whitespace"></a>core.whitespace</h4><p>Git 预先设置了一些选项来探测和修正多余空白字符问题。 它提供了六种处理多余空白字符的主要选项 —— 其中三个默认开启，另外三个默认关闭，不过你可以自由地设置它们。</p><p>默认被打开的三个选项是：<code>blank-at-eol</code>，查找行尾的空格；<code>blank-at-eof</code>，盯住文件底部的空行； <code>space-before-tab</code>，警惕行头 tab 前面的空格。</p><p>默认被关闭的三个选项是：<code>indent-with-non-tab</code>，揪出以空格而非 tab 开头的行（你可以用 <code>tabwidth</code> 选项控制它）；<code>tab-in-indent</code>，监视在行头表示缩进的 tab；<code>cr-at-eol</code>，告诉 Git 忽略行尾的回车。</p><p>通过设置 <code>core.whitespace</code>，你可以让 Git 按照你的意图来打开或关闭以逗号分割的选项。 要想关闭某个选项，你可以在输入设置选项时不指定它或在它前面加个 <code>-</code>。 例如，如果你想要打开除<code>space-before-tab</code> 之外的所有选项，那么可以这样 （ <code>trailing-space</code> 涵盖了 <code>blank-at-eol</code> 和 <code>blank-at-eof</code> ）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.whitespace \</span></span><br><span class="line"><span class="language-bash">    trailing-space,-space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol</span></span><br></pre></td></tr></table></figure><p>你也可以只指定自定义的部分：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.whitespace \</span></span><br><span class="line"><span class="language-bash">    -space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol</span></span><br></pre></td></tr></table></figure><h3 id="服务端配置"><a class="header-anchor" href="#服务端配置"></a>服务端配置</h3><h4 id="receive-fsckObjects"><a class="header-anchor" href="#receive-fsckObjects"></a>receive.fsckObjects</h4><p>Git 能够确认每个对象的有效性以及 SHA-1 检验和是否保持一致。 但 Git 不会在每次推送时都这么做。这个操作很耗时间，很有可能会拖慢提交的过程，特别是当库或推送的文件很大的情况下。 如果想在每次推送时都要求 Git 检查一致性，设置 <code>receive.fsckObjects</code> 为 true 来强迫它这么做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --system receive.fsckObjects <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>现在 Git 会在每次推送生效前检查库的完整性，确保没有被有问题的客户端引入破坏性数据。</p><h4 id="receive-denyNonFastForwards"><a class="header-anchor" href="#receive-denyNonFastForwards"></a>receive.denyNonFastForwards</h4><p>如果你变基已经被推送的提交，继而再推送，又或者推送一个提交到远程分支，而这个远程分支当前指向的提交不在该提交的历史中，这样的推送会被拒绝。 这通常是个很好的策略，但有时在变基的过程中，你确信自己需要更新远程分支，可以在 push 命令后加 <code>-f</code> 标志来强制更新（force-update）。</p><p>要禁用这样的强制更新推送（force-pushes），可以设置 <code>receive.denyNonFastForwards</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --system receive.denyNonFastForwards <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>稍后我们会提到，用服务器端的接收钩子也能达到同样的目的。 那种方法可以做到更细致的控制，例如禁止某一类用户做非快进（non-fast-forwards）推送。</p><h4 id="receive-denyDeletes"><a class="header-anchor" href="#receive-denyDeletes"></a>receive.denyDeletes</h4><p>有一些方法可以绕过 <code>denyNonFastForwards</code> 策略。其中一种是先删除某个分支，再连同新的引用一起推送回该分支。 把 <code>receive.denyDeletes</code> 设置为 true 可以把这个漏洞补上：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --system receive.denyDeletes <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>这样会禁止通过推送删除分支和标签 — 没有用户可以这么做。 要删除远程分支，必须从服务器手动删除引用文件。</p><h2 id="Git-属性"><a class="header-anchor" href="#Git-属性"></a>Git 属性</h2><p>你也可以针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。 这些基于路径的设置项被称为 Git 属性，可以在你的目录下的 <code>.gitattributes</code> 文件内进行设置（通常是你的项目的根目录）。如果不想让这些属性文件与其它文件一同提交，你也可以在 <code>.git/info/attributes</code> 文件中进行设置。</p><p>通过使用属性，你可以对项目中的文件或目录单独定义不同的合并策略，让 Git 知道怎样比较非文本文件，或者让 Git 在提交或检出前过滤内容。</p><h2 id="Git-钩子"><a class="header-anchor" href="#Git-钩子"></a>Git 钩子</h2><p>和其它版本控制系统一样，Git 能在特定的重要动作发生时触发自定义脚本。 有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 你可以随心所欲地运用这些钩子。</p><p>钩子都被存储在 Git 目录下的 <code>hooks</code> 子目录中。 也即绝大部分项目中的 <code>.git/hooks</code> 。 当你用 <code>git init</code> 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。 这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或任何你熟悉的语言编写它们。 这些示例的名字都是以 <code>.sample</code> 结尾，如果你想启用它们，得先移除这个后缀。</p><p>把一个正确命名（不带扩展名）且可执行的文件放入 <code>.git</code> 目录下的 <code>hooks</code> 子目录中，即可激活该钩子脚本。 这样一来，它就能被 Git 调用。</p><blockquote><p>需要注意的是，克隆某个版本库时，它的客户端钩子 <strong>并不</strong> 随同复制。 如果需要靠这些脚本来强制维持某种策略，建议你在服务器端实现这一功能。</p></blockquote><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>自定义 Git 章节中，我主要在乎的是使用 Git 客户端配置，因为它跟平常的开发息息相关。 Git 属性和 Git 钩子更偏向于自定义化，一般项目确实用不到，等到真的有需求那天，再专门整理一章实践片，现在主打一个了解，知道有这个东西就行。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-Git工具</title>
      <link href="/2024/01/20/git-study-7/"/>
      <url>/2024/01/20/git-study-7/</url>
      
        <content type="html"><![CDATA[<h2 id="Git的修订版本"><a class="header-anchor" href="#Git的修订版本"></a>Git的修订版本</h2><p>Git 每一次 commit 都会生成一个版本号，也成为单个修订版本，它由 40 个字符的完整 SHA-1 散列值组成。</p><p>Git 支持只提供 4 个 SHA-1 字符即可获得对应的那次提交，但前提是在没有冲突的情况下，一般 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的冲突。</p><blockquote><p>关于 SHA-1 的简短说明</p><p>许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同。 然后呢？</p><p>如果你真的向仓库里提交了一个对象，它跟之前的某个 <strong>不同</strong> 对象的 SHA-1 值相同， Git 会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。 如果之后你想检出那个对象时，你将得到先前那个对象的数据。</p><p>但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20 字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 <code>p = (n(n-1)/2) * (1/2^160))</code> ）。 2^80 是 1.2 x 10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。</p><p>举例说一下怎样才能产生一次 SHA-1 冲突。 如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 Linux 内核历史（650 万个 Git 对象）的代码， 并将之提交到一个巨大的 Git 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50% 的概率产生一次 SHA-1 对象冲突。</p></blockquote><h2 id="交互式暂存"><a class="header-anchor" href="#交互式暂存"></a>交互式暂存</h2><p>用途：当在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时。</p><p>通过 <code>git add -i</code> 进入交互式暂存。</p><p><img src="/2024/01/20/git-study-7/image-20240116171937170.png" alt="image-20240116171937170"></p><p>输入数字下标或者前缀字母即可进入下一步，例如 status ，输入 1 或 s 。</p><p>上述的所有命令解释如下：</p><ul><li>status 表示查看当前 Git 已跟踪且变更过的文件状态。</li><li>update 表示进行暂存操作。（即 git add xxx 操作）</li><li>revert 表示取消暂存操作。 （即 git restore xxx 操作）</li><li>add untracked 表示将未跟踪的文件进行跟踪。</li><li>patch 表示暂存文件的特定部分。</li><li>diff 表示查看已暂存内容的区别。</li><li>quit 表示退出。</li><li>help 表示帮助。</li></ul><p>进入以上命令后，想要返回上一步，只需要不输入任何东西的情况下按回车即可。</p><h2 id="贮藏与清理"><a class="header-anchor" href="#贮藏与清理"></a>贮藏与清理</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 <code>git stash</code> 命令。</p><p><strong>贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）</strong>。</p><p>贮藏相关命令如下：</p><ul><li><p>git stash：贮藏当前改动的文件。</p><blockquote><p>默认情况下，<code>git stash</code> 只会贮藏已修改和暂存的 <strong>已跟踪</strong> 文件。 如果指定 <code>--include-untracked</code> 或 <code>-u</code> 选项，Git 也会贮藏任何未跟踪文件。 然而，在贮藏中包含未跟踪的文件仍然不会包含明确 <strong>忽略</strong> 的文件。 要额外包含忽略的文件，请使用 <code>--all</code> 或 <code>-a</code> 选项。</p></blockquote></li><li><p>git stash list：查看贮藏记录</p></li><li><p>git stash apply：应用贮藏记录的内容</p><blockquote><p>git stash apply 默认应用最新一条记录，如果想要应用指定记录，可根据记录前的下标修改命令为 git stash apply stash@{n} ，n 表示下标。</p></blockquote></li><li><p>git stash drop：删除贮藏记录</p><blockquote><p>默认删除第一条贮藏记录，也可以跟 apply 一样，指定删除。</p></blockquote></li></ul><p><strong>清理（clean）用于从工作目录中移除未被追踪的文件</strong>。</p><p>清理相关命令如下：</p><ul><li><p>git clean -n：查看将要移除的文件有哪些，并不是真的移除。</p></li><li><p>git clean -f：移除 -n 中显示的将要移除的文件。</p><blockquote><p>-d 选项，表示未追踪的子目录。默认情况下 -n 或 -f 不会扫码移除子目录，需要增加 -d 参数才行。</p><p>-x 选项，表示包含移除与 <code>.gitignore</code> 或其他忽略文件中的模式匹配的文件。</p></blockquote></li></ul><h2 id="签署工作"><a class="header-anchor" href="#签署工作"></a>签署工作</h2><p>Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源， Git 提供了几种通过 GPG 来签署和验证工作的方式。</p><p>GPG 使用方法：</p><ul><li><p>gpg --list-keys：查看 GPG 密钥。</p><blockquote><p>示例如下：</p><p><img src="/2024/01/20/git-study-7/image-20240117174307694.png" alt="image-20240117174307694"></p></blockquote></li><li><p>gpg --gen-key：生成 GPG 密钥。</p></li><li><p>git config --global user.signingkey 0A46826A：配置 GPG 的公钥。</p></li></ul><h2 id="搜索"><a class="header-anchor" href="#搜索"></a>搜索</h2><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者显示一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。</p><p>第一个工具是 <code>git grep &lt;搜索字符串或正则表达式&gt;</code> 命令，主要是用于搜索代码在哪里。</p><p>如果传递 <code>-n</code> 参数，将会输出 Git 找到的匹配行的行号。</p><p>如果传递 <code>-c</code> 参数，输出的信息仅包括那些包含匹配字符串的文件，以及每个文件中包含了多少个匹配。</p><p>如果传递 <code>-p</code> 参数，则会显示搜索字符串的上下文。</p><p>第二个工具是 Git 日志搜索，主要是用于搜索代码是何时存在或引入的。</p><p>通过 <code>git log -S &lt;搜索字符串或正则表达式&gt;</code>命令，搜索代码的提交记录，展示提交日志。</p><p>其中 <code>-S</code> 参数表示显示新增和删除该字符串的提交记录。</p><p>如果传递 <code>--oneline</code> 参数，则主要显示提交的修订版本和提交备注。</p><h2 id="重写历史"><a class="header-anchor" href="#重写历史"></a>重写历史</h2><p>在学习重写历史之前，需要牢记一个开发准则：在满意之前不要推送工作内容。</p><p>Git 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 <strong>在本地</strong> 随便重写历史记录。 然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。 简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。</p><h3 id="修改最后一次提交"><a class="header-anchor" href="#修改最后一次提交"></a>修改最后一次提交</h3><p>顾名思义，只需要对最后一次提交做修改，此时使用 <code>git commit --amend</code> 命令就好。它会用新的提交版本来替换旧的最后一次提交。</p><p>如果提交信息不需要修改，可以使用 <code>--no-edit</code> 参数。</p><h3 id="修改多个提交信息"><a class="header-anchor" href="#修改多个提交信息"></a>修改多个提交信息</h3><p>Git 本身是没有直接改变历史的工具的，可以使用变基工具来变基这一系列提交，通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。</p><p>需要注意的是，<code>git rebase -i &lt;版本区间&gt;</code>命令会将这个区间的所有提交信息进行重写，所以尽量不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。</p><h3 id="filter-branch"><a class="header-anchor" href="#filter-branch"></a>filter-branch</h3><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 <code>filter-branch</code>，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。</p><blockquote><p><code>git filter-branch</code> 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用 <code>git-filter-repo</code>，它是一个 Python 脚本，相比大多数使用 <code>filter-branch</code> 的应用来说，它做得要更好。它的文档和源码可访问 https://github.com/newren/git-filter-repo 获取。</p></blockquote><h4 id="从每一个提交中移除一个文件"><a class="header-anchor" href="#从每一个提交中移除一个文件"></a>从每一个提交中移除一个文件</h4><p>有人粗心地通过 <code>git add .</code> 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 <code>filter-branch</code> 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 <code>passwords.txt</code> 的文件，可以使用 <code>--tree-filter</code> 选项给 <code>filter-branch</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git filter-branch --tree-filter <span class="string">&#x27;rm -f passwords.txt&#x27;</span> HEAD</span></span><br><span class="line">Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)</span><br><span class="line">Ref &#x27;refs/heads/master&#x27; was rewritten</span><br></pre></td></tr></table></figure><p><code>--tree-filter</code> 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 <code>passwords.txt</code> 的文件，无论它是否存在。</p><h4 id="使一个子目录做为新的根目录"><a class="header-anchor" href="#使一个子目录做为新的根目录"></a>使一个子目录做为新的根目录</h4><p>假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（<code>trunk</code>、<code>tags</code> 等等）。 如果想要让 <code>trunk</code> 子目录作为每一个提交的新的项目根目录，<code>filter-branch</code> 也可以帮助你那么做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git filter-branch --subdirectory-filter trunk HEAD</span></span><br><span class="line">Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)</span><br><span class="line">Ref &#x27;refs/heads/master&#x27; was rewritten</span><br></pre></td></tr></table></figure><p>现在新项目根目录是 <code>trunk</code> 子目录了。 Git 会自动移除所有不影响子目录的提交。</p><h4 id="全局修改邮箱地址"><a class="header-anchor" href="#全局修改邮箱地址"></a>全局修改邮箱地址</h4><p>另一个常见的情形是在你开始工作时忘记运行 <code>git config</code> 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 <code>filter-branch</code> 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 <code>--commit-filter</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git filter-branch --commit-filter <span class="string">&#x27;</span></span></span><br><span class="line">        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;123@qq.com&quot; ];</span><br><span class="line">        then</span><br><span class="line">                GIT_AUTHOR_NAME=&quot;Wray&quot;;</span><br><span class="line">                GIT_AUTHOR_EMAIL=&quot;wray20156294@gmail.com&quot;;</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        else</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        fi&#x27; HEAD</span><br></pre></td></tr></table></figure><p>这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。</p><p>如果提交记录已经推送到远程仓库，需要使用 <code>git push origin branch_name</code>命令更新。</p><p>使用它来修改提交者（作者和提交者）信息可能导致与远程仓库的历史不一致，从而导致推送被拒绝。这是因为修改历史会改变每个提交的 SHA-1 校验和，而远程仓库已经有了不同的历史。</p><p>因此建议使用<code>git push --force-with-lease origin branch_name</code> 方式安全的强制推送，它会检查远程分支是否和你的本地分支一致。如果远程分支的历史已经被其他人修改，推送会被拒绝。</p><h2 id="重置揭密"><a class="header-anchor" href="#重置揭密"></a>重置揭密</h2><p>主要讲解 <code>git reset</code> 命令的强大之处，以及与 <code>git checkout</code> 的区别。</p><p>更多详情在：<a href="https://blog.itwray.com/2023/11/22/git-commands-reset/">https://blog.itwray.com/2023/11/22/git-commands-reset/</a></p><h2 id="高级合并"><a class="header-anchor" href="#高级合并"></a>高级合并</h2><p>Git 的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。</p><p>所以，在合并前，建议将正在做的工作，要么提交到一个临时分支要么储藏（stasg）它。</p><p>如果已经执行了 <code>git merge</code> 合并操作并出现了合并冲突，可以通过 <code>git merge --abort</code> 来简单地退出合并。</p><p>如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。 大多数情况下，如果你在错误的 <code>git merge</code> 后运行 <code>git reset --hard HEAD~</code>。</p><h2 id="Rerere"><a class="header-anchor" href="#Rerere"></a>Rerere</h2><p><code>git rerere</code> 功能是一个隐藏的功能。 正如它的名字“重用记录的解决方案（reuse recorded resolution）”所示，它允许你让 Git 记住解决一个块冲突的方法， 这样在下一次看到相同冲突时，Git 可以为你自动地解决它。</p><p>有几种情形下这个功能会非常有用。 在文档中提到的一个例子是想要保证一个长期分支会干净地合并，但是又不想要一串中间的合并提交弄乱你的提交历史。 将 <code>rerere</code> 功能开启后，你可以试着偶尔合并，解决冲突，然后退出合并。 如果你持续这样做，那么最终的合并会很容易，因为 <code>rerere</code> 可以为你自动做所有的事情。</p><h2 id="Git-调试"><a class="header-anchor" href="#Git-调试"></a>Git 调试</h2><p>使用 <code>git blame</code> 标注文件，可以知道一个文件的每一行具体在何时引入的，显示每行最后一次修改的提交记录。</p><p>例如：<code>git blame -L 69,82 Makefile</code> 表示用 <code>git blame</code> 确定了 Linux 内核源码顶层的 <code>Makefile</code> 中每一行分别来自哪个提交和提交者， 此外用 <code>-L</code> 选项还可以将标注的输出限制为该文件中的第 69 行到第 82 行。</p><p>使用<code>git bisect</code> 命令会对提交历史进行二分查找，以找到是哪一个提交引入了问题。</p><h2 id="子模块"><a class="header-anchor" href="#子模块"></a>子模块</h2><p>子模块的应用场景如下：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p><p>首先，确定自己的主项目，然后在主项目的仓库下通过<code>git submodule add</code> 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块。</p><p>例如，在 <code>git-study</code> 项目下添加 <code>git-study-submodule</code>子项目：</p><p><code>git submodule add git@github.com:wangfarui/git-study-submodule.git</code></p><p>查看<code>git-study</code>项目目录结构：</p><p><img src="/2024/01/20/git-study-7/image-20240119110628042.png" alt="image-20240119110628042"></p><p>首先应当注意到新的 <code>.gitmodules</code> 文件。 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：</p><p><img src="/2024/01/20/git-study-7/image-20240119110652184.png" alt="image-20240119110652184"></p><p>如果有多个子模块，该文件中就会有多条记录。 要重点注意的是，该文件也像 <code>.gitignore</code> 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。</p><p>添加子模块后，<code>git status</code>查看主项目仓库状态：</p><p><img src="/2024/01/20/git-study-7/image-20240119110832251.png" alt="image-20240119110832251"></p><p>可以发现子模块的项目内容已经被跟踪到主项目中，执行<code>git commit</code>将其提交到主项目中，再执行<code>git push</code>将主项目推送到远程仓库。</p><p>在 GitHub 下，可以看到 GitHub 会自动识别到子项目，项目链接到子项目地址。</p><p><img src="/2024/01/20/git-study-7/image-20240119111301145.png" alt="image-20240119111301145"></p><p>但是！！！需要注意链接地址：</p><p>https://github.com/wangfarui/git-study-submodule/tree/ea6b9f6afef267dc897376df3b98b879aa5ec0fb</p><p>可以再看看<code>git-study-submodule</code>项目的真正 Git 仓库地址：</p><p>https://github.com/wangfarui/git-study-submodule</p><p>可以发现从主项目进入的子项目显示的是主项目的版本，所以如果直接在子项目做提交变更，主项目是感知不到的，需要手动刷新并推送。</p><p>由此可见，子项目是独立存在的，只不过主项目将其引入进来，可以直接使用源码。同理，子项目的开发工作可以是独立项目开发，也可以是直接在主项目的子模块下开发。在子模块下执行 <code>git remote show origin</code> 可以看到当前指向的 Git 远程仓库为子项目的仓库地址。</p><p><img src="/2024/01/20/git-study-7/image-20240119111717930.png" alt="image-20240119111717930"></p><p>在子项目下做编辑并提交操作后，在主项目通过<code>git add</code>跟踪子模块，再提交和推送后，子模块的远程仓库才会同步更新。</p><p>如果子项目已经独立开发并更新到远程仓库了，可以使用 <code>git submodule update --remote git-study-submodule</code> 命令拉取最新信息，此时 <code>git-study-submodule</code> 子项目的内容已经与远程仓库同步了，不需要再 merge 。</p><p>更新完子项目后，主项目需要通过<code>git add</code>跟踪子模块，再提交和推送后，主项目下的子项目版本才会同步变更。</p><h2 id="打包"><a class="header-anchor" href="#打包"></a>打包</h2><p>Git 可以将它的数据“打包”到一个文件中。 这在许多场景中都很有用。 有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。 可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。 可能你的无线、有线网卡坏掉了。 可能你现在没有共享服务器的权限，你又希望通过邮件将更新发送给别人， 却不希望通过 <code>format-patch</code> 的方式传输 40 个提交。</p><p>这些情况下 <code>git bundle</code> 就会很有用。 <code>bundle</code> 命令会将 <code>git push</code> 命令所传输的所有内容打包成一个二进制文件， 你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p><h2 id="替换"><a class="header-anchor" href="#替换"></a>替换</h2><p>Git 对象数据库中的对象是不可改变的， 然而 Git 提供了一种有趣的方式来用其他对象 <strong>假装</strong> 替换数据库中的 Git 对象。</p><p><code>replace</code> 命令可以让你在 Git 中指定 <strong>某个对象</strong> 并告诉 Git：“每次遇到这个 Git 对象时，假装它是 <strong>其它对象</strong>”。 在你用一个不同的提交替换历史中的一个提交而不想以 <code>git filter-branch</code> 之类的方式重建完整的历史时，这会非常有用。</p><h2 id="凭证存储"><a class="header-anchor" href="#凭证存储"></a>凭证存储</h2><p>如果你使用的是 SSH 方式连接远端，并且设置了一个没有口令的密钥，这样就可以在不输入用户名和密码的情况下安全地传输数据。 然而，这对 HTTP 协议来说是不可能的 —— 每一个连接都是需要用户名和密码的。 这在使用双重认证的情况下会更麻烦，因为你需要输入一个随机生成并且毫无规律的 token 作为密码。</p><p>Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项：</p><ul><li>默认所有都不缓存。 每一次连接都会询问你的用户名和密码。</li><li>“cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。</li><li>“store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。</li><li>如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。</li><li>如果你使用的是 Windows，你可以安装一个叫做 “Git Credential Manager for Windows” 的辅助工具。 这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。 可以在 https://github.com/Microsoft/Git-Credential-Manager-for-Windows 下载。</li></ul><p>你可以设置 Git 的配置来选择上述的一种方式</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global credential.helper cache</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>Git 工具非常之多，有些工具在日常开发中可能基本用不到，但有些工具还是非常实用的。这里主要列举一下我觉得比较有用的：贮藏（git stash）、重写最后一次提交（git commit --amend）、重置揭密（git reset）、搜索（git grep）。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作小结-接入钉钉机器人</title>
      <link href="/2024/01/13/work-report-dingtalk-robot/"/>
      <url>/2024/01/13/work-report-dingtalk-robot/</url>
      
        <content type="html"><![CDATA[<h2 id="钉钉机器人介绍"><a class="header-anchor" href="#钉钉机器人介绍"></a>钉钉机器人介绍</h2><p>官方地址：<a href="https://open.dingtalk.com/document/robots/custom-robot-access">https://open.dingtalk.com/document/robots/custom-robot-access</a></p><p>企业内部有较多系统支撑着公司的核心业务流程，譬如CRM系统、交易系统、监控报警系统等等。通过钉钉的自定义机器人，可以将这些系统事件同步到钉钉的聊天群。</p><h2 id="接入方式"><a class="header-anchor" href="#接入方式"></a>接入方式</h2><p>接入钉钉机器人比较简单，分为两步步骤：</p><ol><li>在钉钉群聊中，添加并配置机器人。</li><li>基于钉钉机器人的 Webhook 地址发起 HTTP POST 请求，即可实现给该钉钉群发送消息。</li></ol><p>发送的消息内容是一个 JSON 对象，按照钉钉给定的消息类型和数据格式进行发送。</p><p>当前自定义机器人支持文本 (text)、链接 (link)、markdown(markdown)、ActionCard、FeedCard消息类型。</p><blockquote><p>钉钉提供了SDK接入方式，通过如下依赖实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>alibaba-dingtalk-service-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="使用方法"><a class="header-anchor" href="#使用方法"></a>使用方法</h2><p>钉钉机器人发送消息可能是一个非常常用的操作，大多数情况下，发送的消息内容结构是固定的，所以在项目中对钉钉机器人发送消息做了一个封装。</p><p>首先，看一下如果不封装代码，直接使用 Java 代码发送消息的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OriginalDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义消息内容</span></span><br><span class="line">        Map&lt;String, String&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">&quot;msgtype&quot;</span>, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">        msg.put(<span class="string">&quot;text&quot;</span>, JSONUtil.toJsonStr(<span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;我就是我, 是不一样的烟火&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpUtil.createPost(<span class="string">&quot;https://oapi.dingtalk.com/robot/send?access_token=566cc69da782ec******&quot;</span>)</span><br><span class="line">                .body(JSONUtil.toJsonStr(msg))</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        System.out.println(httpResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，发送的钉钉消息是一串文本，需要先定义消息类型，再通过HTTP工具发送。</p><p>这其中除了文本消息内容是可变的，其实都是固定的，所以如果通过封装后的工具发送，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DingTalkHelper.sendMessage(<span class="string">&quot;我就是我, 是不一样的烟火&quot;</span>);</span><br></pre></td></tr></table></figure><br><p>完整的项目示例代码：<a href="https://github.com/wangfarui/work-report/tree/main/dingtalk-rebot">https://github.com/wangfarui/work-report/tree/main/dingtalk-rebot</a></p><h2 id="实现封装"><a class="header-anchor" href="#实现封装"></a>实现封装</h2><p>工作项目上，因为使用了 Apollo 作为动态属性配置，所以钉钉机器人封装中也用到了它。</p><h3 id="参数配置"><a class="header-anchor" href="#参数配置"></a>参数配置</h3><p>首先，确定钉钉机器人需要的属性，通过钉钉文档的介绍，机器人发送消息至少需要客户端地址，如果配置了授权和加密，则还需要 token 和 secret ，参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;dingTalk.client-url:https://oapi.dingtalk.com/robot/send&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String clientUrl;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;dingTalk.access-token:&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;dingTalk.secret:&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String secret;</span><br></pre></td></tr></table></figure><p>然后，钉钉机器人发送的消息有时是不必须的，例如用于发送系统告警信息时，在内网进行开发联调时，不希望打印一堆异常信息到钉钉群里，就增加了个参数用于控制钉钉机器人的开启和关闭（ enabled ）。</p><p>此外，结合钉钉机器人支持@功能，实现了动态@指定人或所有人功能，通过手机号绑定。参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启钉钉告警功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;dingTalk.enabled:false&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 群@指定人手机号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;dingTalk.at.atMobiles:&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; atMobiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 群@所有人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;dingTalk.at.atAll:false&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> atAll;</span><br></pre></td></tr></table></figure><p>最后，在钉钉机器人用于发送系统异常消息时，有时希望忽略某些接口的告警，有时希望只开启某些接口的告警，所以配置了忽略告警url和指定告警url两个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 忽略的告警url</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;dingTalk.ignoreUrls:&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; ignoreUrls;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定的告警url</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;dingTalk.warnUrls:&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; warnUrls;</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a class="header-anchor" href="#发送消息"></a>发送消息</h3><p>为了减轻项目的依赖项，因此没有接入SDK方式，发送消息仍然采用的是HTTP方式。</p><p>为了保证钉钉机器人发送消息功能不影响业务功能的正常进行，因此将发送消息功能独立到新的线程，并对发送结果的异常消息做日志记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送钉钉消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request  机器人消息对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> canApply 是否需要发送钉钉机器人消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> DingTalkSendRequest request, <span class="type">boolean</span> canApply)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canApply) &#123;</span><br><span class="line">        <span class="keyword">if</span> (properties.isAtAll()) &#123;</span><br><span class="line">            request.setAtAll(properties.isAtAll());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CollectionUtils.isNotEmpty(properties.getAtMobiles())) &#123;</span><br><span class="line">            request.setAtMobiles(properties.getAtMobiles());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completed</span> <span class="operator">=</span> request.completeRequestParam();</span><br><span class="line">        <span class="keyword">if</span> (!completed) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;[DingTalkClient][send]钉钉消息请求对象数据异常, request:&#123;&#125;&quot;</span>, JSON.toJSONString(request));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> properties.getRequestUrl();</span><br><span class="line">        EXECUTOR_SERVICE.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpUtil.createPost(requestUrl)</span><br><span class="line">                    .body(JSON.toJSONString(request))</span><br><span class="line">                    .charset(StandardCharsets.UTF_8)</span><br><span class="line">                    .execute();</span><br><span class="line">            <span class="keyword">if</span> (httpResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;[DingTalkClient][send]发送钉钉消息异常, request:&#123;&#125;&quot;</span>, JSON.toJSONString(request));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!httpResponse.isOk()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;[DingTalkClient][send]发送钉钉消息失败, request:&#123;&#125;, response:&#123;&#125;&quot;</span>, JSON.toJSONString(request), JSON.toJSONString(httpResponse));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过发送消息方法的入参可以看出，此功能主要依赖于 <code>DingTalkSendRequest</code> 对象，此对象的属性是严格按照钉钉文档的参数名进行设定的，避免JSON序列化时的二次包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DingTalkSendRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于钉钉入参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String msgtype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钉钉消息类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> DingTalkMsgType dingTalkMsgType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钉钉消息需要 @ 的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> AT at;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钉钉消息类型为 markdown 的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> Markdown markdown;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钉钉消息类型为 text 的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> Text text;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AT</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; atMobiles;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; atUserIds;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isAtAll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Markdown</span> &#123;</span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非钉钉消息的数据格式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, String&gt; content;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addContent</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.content == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.content = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.content.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">formatContentToText</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : <span class="built_in">this</span>.content.entrySet()) &#123;</span><br><span class="line">                sb.append(entry.getKey()).append(<span class="string">&quot;：&quot;</span>).append(entry.getValue()).append(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.text = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统异常消息"><a class="header-anchor" href="#系统异常消息"></a>系统异常消息</h3><p>通过 spring-web 的 <code>@RestControllerAdvice</code> + <code>@ExceptionHandler</code> 注解拦截指定异常，对需要的异常发送消息到钉钉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendDingTalkMessage</span><span class="params">(Throwable e, HttpServletRequest httpServletRequest)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化钉钉告警对象 并配置告警标题</span></span><br><span class="line">    <span class="type">DingTalkSendRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DingTalkSendRequest</span>();</span><br><span class="line">    request.setMarkdownTitle(e <span class="keyword">instanceof</span> BizException ? <span class="string">&quot;业务告警&quot;</span> : <span class="string">&quot;系统告警&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置基础告警信息</span></span><br><span class="line">    request.addMarkdownContent(<span class="string">&quot;【告警环境】&quot;</span>, <span class="built_in">this</span>.envStr);</span><br><span class="line">    request.addMarkdownContent(<span class="string">&quot;【traceId】&quot;</span>, MDC.get(<span class="string">&quot;traceId&quot;</span>));</span><br><span class="line">    request.addMarkdownContent(<span class="string">&quot;【租户id】&quot;</span>, UserUtils.getTenantId().toString());</span><br><span class="line">    request.addMarkdownContent(<span class="string">&quot;【告警时间】&quot;</span>, DateUtil.now());</span><br><span class="line">    <span class="comment">// 配置http请求告警信息</span></span><br><span class="line">    <span class="keyword">if</span> (httpServletRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">        request.addMarkdownContent(<span class="string">&quot;【异常接口】&quot;</span>, httpServletRequest.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异常堆栈信息</span></span><br><span class="line">    request.addMarkdownContent(<span class="string">&quot;【异常堆栈】&quot;</span>, ExceptionUtils.exceptionStackTraceText(e, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">    DingTalkHelper.send(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二次封装"><a class="header-anchor" href="#二次封装"></a>二次封装</h3><p>如果直接使用封装的 <code>DingTalkClient</code> 对象，调用 <code>send</code> 方法发送消息，对于开发人员来说还是比较麻烦的，还需要自定义消息对象等。</p><p>因此，根据业务项目场景需求，二次封装了一个抽象类，开发人员可以直接静态调用发送消息功能，实现普通消息和异常消息的发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="type">DingTalkSendRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DingTalkSendRequest</span>();</span><br><span class="line">    request.setTextContent(message);</span><br><span class="line">    getDingTalkClient().send(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendException</span><span class="params">(String message, Throwable e)</span> &#123;</span><br><span class="line">    <span class="type">DingTalkSendRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DingTalkSendRequest</span>();</span><br><span class="line">    request.setMarkdownTitle(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">    request.addMarkdownContent(<span class="string">&quot;异常内容&quot;</span>, message);</span><br><span class="line">    request.addMarkdownContent(<span class="string">&quot;异常信息&quot;</span>, ExceptionUtils.exceptionStackTraceText(e));</span><br><span class="line">    getDingTalkClient().send(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>钉钉机器人发送消息这个功能，钉钉官方支持的是比较简单的，因此主要是看消息内容的JSON数据，通过JSON格式化确定消息内容的复杂性。所以本次工作上的封装主要是针对消息内容做了一个优化，然后结合项目需求开发一些特殊规定，例如什么环境需要@什么人、什么接口需要屏蔽、什么异常是必须要发送消息的等等。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作小结-MyBatis-Plus填充策略</title>
      <link href="/2024/01/10/work-report-mybatisplus-fill/"/>
      <url>/2024/01/10/work-report-mybatisplus-fill/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-Plus简介"><a class="header-anchor" href="#MyBatis-Plus简介"></a>MyBatis-Plus简介</h2><p>官方地址：<a href="https://baomidou.com/">https://baomidou.com/</a></p><p>MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>而本次工作内容就是使用了它的<a href="https://baomidou.com/pages/4c6bcf/">自动填充功能</a>，实现 Entity 对象属性值的自动填充。</p><h2 id="自动填充功能"><a class="header-anchor" href="#自动填充功能"></a>自动填充功能</h2><p>实现功能：在插入或更新数据时，自动插入或更新指定字段的值。例如一些特殊字段：创建时间、创建人、更新时间、更新人等。</p><p>实现原理主要分为两步：</p><ol><li>实现元对象处理器接口：com.baomidou.mybatisplus.core.handlers.MetaObjectHandler</li><li>@TableField 注解标记字段的填充策略。</li></ol><p>注意事项：</p><p><img src="/2024/01/10/work-report-mybatisplus-fill/image-20240112152613998.png" alt="image-20240112152613998"></p><p>关于注意事项第一点：填充原理是直接给 Entity 的属性设置值，理解起来就是，填充原理是基于 Entity 实例对象的，所以通过 Mapper SQL 语句方式、或者通过 Lambda 表达式方式都是不可行的。</p><p>关于注意事项最后一点：解释当需要通过 Mapper SQL 语句方式填充时，必须按照它的约定配置，一要求方法参数对象是 Entity 对象，二要求方法参数类型需要按照约定定义别名。</p><h2 id="使用方法"><a class="header-anchor" href="#使用方法"></a>使用方法</h2><p>在 Spring Boot 环境下，定义实体对象、Mapper对象、Service对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createById;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(String name, Integer age, String email)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setAge(age);</span><br><span class="line">        user.setEmail(email);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存</span></span><br><span class="line">        <span class="built_in">this</span>.save(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getById(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateByLambda</span><span class="params">(Long id, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lambdaUpdate()</span><br><span class="line">                .eq(User::getId, id)</span><br><span class="line">                .set(User::getAge, age)</span><br><span class="line">                .update();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateByMethod</span><span class="params">(Long id, Integer age)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setAge(age);</span><br><span class="line">        <span class="built_in">this</span>.updateById(user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，实现 <code>MetaObjectHandler</code> 接口，定义 MyBatis Plus 填充策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createById&quot;</span>, Long.class, System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, Date.class, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，编写单元测试类，调用 Service 对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.save(<span class="string">&quot;wray&quot;</span>, <span class="number">18</span>, <span class="string">&quot;wray20156294@gmail.com&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateByLambda</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.updateByLambda(<span class="number">1745704644463579138L</span>, <span class="number">19</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateByMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.updateByMethod(<span class="number">1745704644463579138L</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试发现，在调用 <code>userService.updateByLambda</code> 方法时，基于 Lambda 表达式修改的数据，填充策略没有生效，证实了注意事项的第一点。</p><br><p>完整项目示例代码：<a href="https://github.com/wangfarui/work-report/tree/main/mybatis-plus-fill">https://github.com/wangfarui/work-report/tree/main/mybatis-plus-fill</a></p><h2 id="关于-TableField-注解标记字段填充策略的疑问"><a class="header-anchor" href="#关于-TableField-注解标记字段填充策略的疑问"></a>关于 @TableField 注解标记字段填充策略的疑问</h2><p>自动填充功能的两步实现原理中，第二步要求指定字段标记填充策略。一开始我认为有点搞繁琐了，因为既然已经在第一步配置填充策略时指定了填充字段的名称，为何还要再标记说明一遍。</p><p>这就得先搞清楚 MyBatis-Plus 是如何实现此功能的了，假如没有第二步，现在有一个 Entity 对象需要保存，填充策略自动填充值是填充的属性值，其实并没有直接给实体对象赋值。等到后面拼接保存方法的sql语句时，判断实体对象是否存在相同字段名称的属性，然后拼接sql语句，实现字段自动填充。</p><p>上述是指实体对象确实需要自动填充，假如某个表也有相同字段，但是它不需要自动填充，如果没有第二步标记指定，就得把业务表是否填充的判断逻辑放到 MyBatis-Plus 的 MetaObjectHandler 填充方法中了，这样一个为了简化代码的自动填充功能反而变得复杂了。</p><p>因此，MyBatis-Plus 在实现自动填充功能时，不仅需要判断实体对象是否存在相同字段名称的属性，还要判断该属性是否被标记。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>MyBatis-Plus 的自动填充功能，在业务项目下还是很实用的，业务项目的数据表基本上都要求要有创建信息、更新信息等，这些基础数据在业务代码中会频繁出现且代码内容完全相同，使用填充功能还可以避免大量重复代码。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作小结 </tag>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作小结-ShedLock的使用</title>
      <link href="/2024/01/08/work-report-shedlock/"/>
      <url>/2024/01/08/work-report-shedlock/</url>
      
        <content type="html"><![CDATA[<h2 id="ShedLock简介"><a class="header-anchor" href="#ShedLock简介"></a>ShedLock简介</h2><p>ShedLock 保证任务最多同时执行一次，当一个节点获取到任务并开始执行，那么其他节点不会等待，而是直接跳过。</p><p>它不是一个分布式调度程序，更像是一个分布式锁，在分布式锁的基础上对调度任务做了扩展，使得分布式服务下的定时任务看起来像分布式调度任务一样。</p><p>此外，ShedLock 的锁是基于时间的，并且 ShedLock 在乐观上是假设所有节点上的时钟是同步的。</p><p>ShedLock 的Github地址：<a href="https://github.com/lukas-krecan/ShedLock">https://github.com/lukas-krecan/ShedLock</a></p><h2 id="ShedLock组成"><a class="header-anchor" href="#ShedLock组成"></a>ShedLock组成</h2><p>ShedLock 分为三部分：</p><ul><li>Core 核心：提供锁机制。</li><li>Integration 集成：使用 Spring AOP、Micronaut AOP 或手写代码与业务项目代码集成。</li><li>Lock Provider 锁提供程序：使用 SQL 数据库、Mongo、Redis 等外部进程提供锁。</li></ul><h2 id="ShedLock用法"><a class="header-anchor" href="#ShedLock用法"></a>ShedLock用法</h2><blockquote><p>ShedLock 基于 Spring 实现时，由于 Spring 6 的JDK依赖因素，所以 ShedLock 的5.x版本需要 JDK &gt; 17 ，否则需要使用 ShedLock 4.x 版本。</p></blockquote><p>接下来，以 Spring 项目（并非Spring Boot项目）为例，JDK 版本为 17 ，Spring 版本为 6.1.1 。</p><p>示例项目代码地址：<a href="https://github.com/wangfarui/work-report/tree/main/shedlock-schedule">https://github.com/wangfarui/work-report/tree/main/shedlock-schedule</a></p><h3 id="启用并配置-Scheduled-locking"><a class="header-anchor" href="#启用并配置-Scheduled-locking"></a>启用并配置 Scheduled locking</h3><p>首先需要添加 ShedLock 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javacrumbs.shedlock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shedlock-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javacrumbs.shedlock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shedlock-provider-redis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，<code>shedlock-provider-redis-spring</code> 中依赖于 <code>spring-data-redis</code>，其中 redis 的驱动器是可选的，默认有 jedis 和 lettuce 两种。示例项目使用 jedis，所以还需要添加 jedis 的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，开始配置 ShedLock 。第一步注入<code>LockProvider</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LockProvider <span class="title function_">lockProvider</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisLockProvider</span>(connectionFactory, <span class="string">&quot;local&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上诉代码可以发现，<code>LockProvider</code>基于 Redis 的实现类 <code>RedisLockProvider</code> 在实例化时还需要一个 <code>RedisConnectionFactory</code> 对象。第二步需要注入 jedis 的 ConnectionFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> JedisConnectionFactory <span class="title function_">jedisConnectionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RedisStandaloneConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisStandaloneConfiguration</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    configuration.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JedisConnectionFactory</span>(configuration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完 ShedLock 的 <code>LockProvider</code> 之后，在配置类上标记 <code>@EnableSchedulerLock</code>以启用 <code>@SchedulerLock</code> 注解的锁功能，标记<code>@EnableScheduling</code>以启用<code>@Scheduled</code>注解的调度功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableSchedulerLock(defaultLockAtMostFor = &quot;10m&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置定时任务"><a class="header-anchor" href="#配置定时任务"></a>配置定时任务</h3><p>通过 <code>@Scheduled</code> 标记Bean对象下的方法为一个定时任务，再通过 <code>@SchedulerLock</code> 使得该任务在分布式服务下同时最多执行一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(cron = &quot;0/5 * * * * *&quot;)</span><br><span class="line">@SchedulerLock(name = &quot;scheduledTaskName&quot;)</span><br><span class="line">public void scheduledTask() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ShedLock总结"><a class="header-anchor" href="#ShedLock总结"></a>ShedLock总结</h2><p>使用 ShedLock 大致分为三步：</p><ol><li>提供一个 <code>LockProvider</code> 。</li><li>标记 <code>@EnableSchedulerLock</code> 注解以启用<code>@SchedulerLock</code>的注解功能。</li><li>标记 <code>@SchedulerLock</code> 注解以启用锁功能。</li></ol><p>以上操作步骤都是按照 ShedLock 默认配置来进行的，如果需要启用高级用法，例如希望<code>@SchedulerLock</code>注解只作用于<code>@Scheduled</code>注解下，可以指定<code>@EnableSchedulerLock</code> 注解的 <code>interceptMode()</code> 属性为 InterceptMode.PROXY_SCHEDULER 。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作小结 </tag>
            
            <tag> ShedLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作小结-业务编号生成器</title>
      <link href="/2024/01/05/work-report-business-sn/"/>
      <url>/2024/01/05/work-report-business-sn/</url>
      
        <content type="html"><![CDATA[<h2 id="业务背景"><a class="header-anchor" href="#业务背景"></a>业务背景</h2><p>系统的业务单据基本都会带有一个单据编号字段，编号规则如下：</p><ul><li>一般以租户维度下唯一，即允许不同租户的相同单据类型出现单据编号重复。</li><li>编号形式一般为：固定前缀 + 日期 + 自然位数 。</li><li>部分单据编号的形式要求包含随机数，用于打乱自然增长序号。</li><li>部分单据编号的前缀不是唯一的，可能会根据用户输入的前缀决定。</li></ul><h2 id="实现原理"><a class="header-anchor" href="#实现原理"></a>实现原理</h2><p>关于业务背景的需求，其实主要麻烦的是自然位数的实现，特别是在考虑多种附加场景下时，例如：自然位数尽可能从1递增、系统是分布式服务、不同租户下序列号隔离。</p><p>因此，一般需要借助其他工具实现，例如：</p><ol><li>数据库的序列（Sequence），数据库序列是一种数据库对象，用于生成唯一的递增或递减序列值。</li><li>Redis 的 INCR 命令，用来原子地递增一个键的值，使用 Redis 的字符串类型来存储递增的序列值。</li><li>分布式ID生成器，例如Snowflake算法，可以生成全局唯一的递增ID。</li><li>分布式缓存和计数器，使用分布式缓存（例如Memcached）和计数器，通过原子递增操作实现递增序列。</li></ol><p>在工作中，我使用的是 MySQL 数据库的唯一索引特性 + InnoDB引擎的事务特性，通过事务和唯一索引的锁机制，实现自然位数的自然递增。</p><h3 id="数据表设计"><a class="header-anchor" href="#数据表设计"></a>数据表设计</h3><p>数据表主要是依赖一张表，用于存储自然位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table sys_business_sn</span><br><span class="line">(</span><br><span class="line">    id              bigint auto_increment comment &#x27;主键id&#x27;</span><br><span class="line">        primary key,</span><br><span class="line">    tenant_id       bigint   default 0                 not null comment &#x27;租户id&#x27;,</span><br><span class="line">    business_type   int                                not null comment &#x27;业务类型&#x27;,</span><br><span class="line">    business_date   date                               not null comment &#x27;业务日期&#x27;,</span><br><span class="line">    business_sn     int                                not null comment &#x27;业务编号 (一般根据 业务类型+业务日期 唯一)&#x27;,</span><br><span class="line">    row_create_time datetime default CURRENT_TIMESTAMP not null comment &#x27;数据创建时间&#x27;,</span><br><span class="line">    row_update_time datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment &#x27;数据更新时间&#x27;,</span><br><span class="line">    constraint uniq_tenant_type_date unique (tenant_id, business_type, business_date)</span><br><span class="line">) comment &#x27;系统业务编号表&#x27;;</span><br></pre></td></tr></table></figure><p>其中 tenant_id 表示租户id，实现租户隔离；business_type 表示业务类型，指不同业务单据对应的自然位数是隔离的；business_date 表示业务日期，指不同日期下的自然位数是隔离的；business_sn 表示自然位数，它通过 租户id + 业务类型 + 业务日期 实现唯一，通过 uniq_tenant_type_date 唯一索引建立关系。</p><p>至于如何通过这张表获取单据编号（其实主要是获取业务编号），则依赖下面的 sql 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_business_sn(tenant_id, business_type, business_date, business_sn)</span><br><span class="line">       <span class="keyword">values</span> (#&#123;tenantId&#125;, #&#123;businessType&#125;, #&#123;businessDate&#125;, <span class="number">1</span>) <span class="keyword">on</span> duplicate key</span><br><span class="line">       <span class="keyword">update</span> business_sn <span class="operator">=</span> business_sn <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这句 sql 语句采用 <code>inset into xxx values xxx on duplicate key update xxx</code> 语法。当“租户id + 业务类型 + 业务日期”拼接的值不存在对应的行数据时，默认插入一条数据，业务编号初始为1；当存在对应的行数据时，则将业务编号自增加1。</p><h3 id="代码设计"><a class="header-anchor" href="#代码设计"></a>代码设计</h3><p>通过数据表设计，在 Java 代码设计一个 DAO 层，用于生成指定租户、业务类型、业务日期的单据编号。</p><p><code>getBusinessSnByType</code> 方法用于获取指定的自然位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getBusinessSnByType</span><span class="params">(Integer businessType, Date date, Long companyId)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿取到真正存储到数据库的tenantId, 不能为null</span></span><br><span class="line">    String realTenantId;</span><br><span class="line">    <span class="keyword">if</span> (companyId == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">tenantId</span> <span class="operator">=</span> UserUtils.getTenantId();</span><br><span class="line">        <span class="keyword">if</span> (tenantId == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;token信息异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realTenantId = tenantId.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        realTenantId = companyId.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> BUSINESS_DATE_FORMAT.format(date);</span><br><span class="line"></span><br><span class="line">    <span class="type">DefaultTransactionDefinition</span> <span class="variable">transactionDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    transactionDefinition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">transactionStatus</span> <span class="operator">=</span> transactionManager.getTransaction(transactionDefinition);</span><br><span class="line">    baseMapper.incrementBusinessSn(realTenantId, businessType, dateStr);</span><br><span class="line"></span><br><span class="line">    <span class="type">SysBusinessSn</span> <span class="variable">entity</span> <span class="operator">=</span> lambdaQuery()</span><br><span class="line">            .eq(SysBusinessSn::getTenantId, realTenantId)</span><br><span class="line">            .eq(SysBusinessSn::getBusinessType, businessType)</span><br><span class="line">            .eq(SysBusinessSn::getBusinessDate, dateStr)</span><br><span class="line">            .select(SysBusinessSn::getBusinessSn)</span><br><span class="line">            .last(<span class="string">&quot;limit 1&quot;</span>)</span><br><span class="line">            .one();</span><br><span class="line"></span><br><span class="line">    transactionManager.commit(transactionStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entity.getBusinessSn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的关键在于 <code>TransactionStatus</code> 控制数据库事务的开始和提交，在事务中做数据更新和数据查询操作，根据 InnoDB 的ACID原则，拿取更新后的业务编号。</p><p>在这个方法的上层方法（<code>generateDefaultFullBusinessSnByCustomized</code>），则是拼接最终的单据编号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">generateDefaultFullBusinessSnByCustomized</span><span class="params">(SysBusinessSnEnum sysBusinessSnEnum, String dateFormat, DecimalFormat decimalFormat, Long companyId)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(sysBusinessSnEnum.getPrefix());</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(dateFormat);</span><br><span class="line">    sb.append(simpleDateFormat.format(date));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sysBusinessSnEnum.getRandomLen() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">randomNumbers</span> <span class="operator">=</span> RandomUtil.randomNumbers(sysBusinessSnEnum.getRandomLen());</span><br><span class="line">        sb.append(randomNumbers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="built_in">this</span>.getBusinessSnByType(sysBusinessSnEnum.getCode(), date, companyId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.append(decimalFormat.format(sn)).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>完整的代码示例地址：<a href="https://github.com/wangfarui/work-report/tree/main/business-sn">https://github.com/wangfarui/work-report/tree/main/business-sn</a></p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>因为实现原理借助的工具不同，所以优缺点有很多都是显而易见的，是代码很难解决的。先说优点：</p><ol><li>有效保障分布式服务下业务编号递增规则。</li><li>可以基于数据表了解到各租户下各单据类型的编号使用状况。</li></ol><p>缺点：</p><ol><li>因为数据库的原因，所以如果数据库奔溃等原因，就会影响所有涉及到业务的正常流程。</li><li>一般这个表会跟业务表共存在一个数据库，会影响数据库的吞吐量、连接数等。</li><li>业务编号可能不保持连续递增，由于业务系统的业务异常等原因。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作小结-OA审批(3)</title>
      <link href="/2024/01/03/work-report-oa3/"/>
      <url>/2024/01/03/work-report-oa3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>在 <a href="https://blog.itwray.com/2023/09/01/work-report-ddoa2/">工作小结-钉钉OA审批(2)</a> 中，介绍了项目搭建钉钉OA审批底层框架的思路。本章则主要是整理项目集成中台内部系统OA审批的设计思路，以及优化oa审批底层框架结构。</p><p>前源码地址：<a href="https://github.com/wangfarui/java-study/tree/main/third-study/dingtalk/dingtalk-oa">https://github.com/wangfarui/java-study/tree/main/third-study/dingtalk/dingtalk-oa</a></p><p>现整合后的源码地址：<a href="https://github.com/wangfarui/work-report/tree/main/oa-approval">https://github.com/wangfarui/work-report/tree/main/oa-approval</a></p><h2 id="框架目录结构"><a class="header-anchor" href="#框架目录结构"></a>框架目录结构</h2><p><img src="/2024/01/03/work-report-oa3/image-20240103164812301.png" alt="image-20240103164812301"></p><p>优化后的项目结构大体上分为三类：</p><ol><li>OA审批共有的对象与接口。例如<code>ApprovalBusinessTypeEnum</code>表示审批业务类型对象，<code>BusinessApprovalCallbackListener</code>表示业务审批回调监听接口。</li><li>业务审批表单目录，即 <code>from</code> 目录。它们通过 <code>XxxApprovalFormEngine</code> 接口实现表单控件的自动构建。</li><li>OA审批工作流的实现方式，例如 <code>dingtalk</code> 、<code>system</code> 目录，它们分别代表了钉钉OA审批和内部系统OA审批。</li></ol><blockquote><p>示例在 DemoApprovalService 下，包含发起审批和审批回调操作。</p></blockquote><h2 id="设计思路"><a class="header-anchor" href="#设计思路"></a>设计思路</h2><h3 id="整体功能流程"><a class="header-anchor" href="#整体功能流程"></a>整体功能流程</h3><p>首先需要明确一点，做这个OA审批底层框架，是为了业务开发人员可以快速使用OA审批功能，不用关注怎么去对接各种OA审批工作流的使用方法。</p><p>OA审批功能在业务上主要分为两个，一是发起审批，二是审批结果回调。然后，OA审批底层框架再以此基础上，扩展新功能，例如审批流程的查询、审批撤销等等。</p><p>OA审批底层框架通过自定义了一套使用方法，将发起审批和审批结果回调做了包装处理，业务开发人员只用关注业务数据的交互。具体业务流程如下图：</p><p><img src="/2024/01/03/work-report-oa3/image-20240104152826675.png" alt="image-20240104152826675"></p><h3 id="发起审批"><a class="header-anchor" href="#发起审批"></a>发起审批</h3><p>发起审批前需要先定义好审批表单模板对象，这个底层框架封装的第一步，通过自定义注解告知控件的名称、类型、是否必填等信息。例如钉钉表单控件 <code>DingTalkFormComponent</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DingTalkFormComponent &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表单控件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表单控件id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;表单控件列表中唯一&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表单控件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ComponentType <span class="title function_">componentType</span><span class="params">()</span> <span class="keyword">default</span> ComponentType.AUTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否非空, 默认不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段为&#123;<span class="doctag">@link</span> java.util.Date&#125;时，日期格式化样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">pattern</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个普通对象定义完控件后，还需要实现 <code>XxxApprovalFormEngine</code> 接口，它的作用就是通过解析自定义注解构建表单模板对象和表单实例对象。</p><p>有了表单模板对象后，就可以开始发起审批了，发起审批需要根据不同的OA审批实现端找到对应的 <code>XxxApprovalService</code> 服务类，并调用 <code>startApprovalFlowInstance</code> 方法。方法接收一个表单实例对象参数，实例对象需要业务唯一id、审批业务类型、表单模板对象等信息。例如内部系统的审批表单流程实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemApprovalFormInstance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scm业务id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long businessId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批业务类型</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApprovalBusinessTypeEnum businessTypeEnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批流程表单模板对象</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SystemApprovalFormEngine approvalForm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务发起日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date businessDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scm租户id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空字段，为空时默认从UserUtils获取&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long tenantId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scm操作人id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空字段，为空时默认从UserUtils获取&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 部门id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;存在多部门时，必传&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long departmentId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用服务类的 <code>startApprovalFlowInstance</code> 方法发起审批成功后，底层框架会保存一条业务与OA审批实现端的关联映射关系数据，这条数据是后面审批回调做数据绑定的关键，同时也可以用来判断当前业务的审批状态。</p><h3 id="审批回调"><a class="header-anchor" href="#审批回调"></a>审批回调</h3><p>在业务方，因为有了底层框架的存在，所以不需要关注OA审批实现端是怎么回调至系统的，它只需要针对不同的审批结果做业务处理即可。因此底层框架提供了审批回调注解 <code>XxxApprovalCallback</code> ，通过标记在方法上实现。例如系统审批回调注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SystemApprovalCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务审批类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ApprovalBusinessTypeEnum <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批事件类型</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;系统审批不支持 ApprovalEventType.ALL &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ApprovalEventType <span class="title function_">eventType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务方在方法上指定其对应的业务审批类型和审批事件类型，底层框架会根据OA审批实现端的审批结果回调对应的方法，并返回一个业务审批回调事件对象（<code>BusinessApprovalCallbackEvent</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BusinessApprovalCallbackEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long businessId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 租户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long tenantId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;钉钉审批回调时: 当钉钉企业用户与SCM企业用户的手机号匹配不到时，可能为空&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设计缺陷"><a class="header-anchor" href="#设计缺陷"></a>设计缺陷</h3><p>因为工作内容的排期问题，原是只需要钉钉审批一种实现方式的，所以没有考虑抽象对象的层级，底层框架对业务系统提供的接口名称都含有钉钉相关字样。后面接入内部系统审批时，因为涉及到的业务代码范围太广，只好做成增量式扩展，例如表单控件注解分成了 <code>DingTalkFormComponent</code> 和 <code>SystemFormComponent</code> ，审批回调注解分成了 <code>DingTalkApprovalCallback</code> 和 <code>SystemApprovalCallback</code> ，包括很多内部实现都出现了重合情况。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>这次主要是将钉钉审批和内部系统审批做了整合，但因为历史迭代原因，对外接口是分离的，整体的流程思路基本是不变的，基于 “定义表单模板对象 -&gt; 发起审批 -&gt; 审批回调” 封装。</p><p>若后期还会新的OA审批实现端接入，希望把对外接口做成统一吧，至于历史模块只能做兼容了。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作小结 </tag>
            
            <tag> OA审批 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于IDEA代码编辑器光标选择问题</title>
      <link href="/2023/12/27/other-idea-231227/"/>
      <url>/2023/12/27/other-idea-231227/</url>
      
        <content type="html"><![CDATA[<p><strong>问题现象</strong>：</p><p>在编辑代码时，使用鼠标点任何位置，光标就定位到点的位置了，而不是定位到代码行的最后一个字符。同样的，用键盘的上下左右键也是此情况。</p><p><img src="/2023/12/27/other-idea-231227/image-20231227145422640.png" alt="image-20231227145422640"></p><p><strong>解决方法</strong></p><p>点击鼠标右键，找到“Column Selection Mode”（列选择模式）项，取消勾选即可。</p><p><img src="/2023/12/27/other-idea-231227/image-20231227145623991.png" alt="image-20231227145623991"></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-GitHub(6)</title>
      <link href="/2023/12/19/git-study-6/"/>
      <url>/2023/12/19/git-study-6/</url>
      
        <content type="html"><![CDATA[<p>本章将讨论如何高效地使用 GitHub。 我们将学习如何注册和管理账户、创建和使用 Git 版本库、向已有项目贡献的通用流程以及如何接受别人向你自己项目的贡献、GitHub 的编程接口和很多能够让这些操作更简单的小提示。</p><h2 id="账户的配置"><a class="header-anchor" href="#账户的配置"></a>账户的配置</h2><h3 id="创建账户"><a class="header-anchor" href="#创建账户"></a>创建账户</h3><p>使用 GitHub ，第一件事是需要创建一个账户，访问 <a href="https://github.com">https://github.com</a> ，找到 “Sign Up” 入口，注册一个自己的私人免费账户。</p><p>创建账户的作用是为了以后 fork 其它项目，以及推送我们自己的修改。也可以创建自己的 Git 项目，然后托管在 GitHub 上。简而言之，可以把 GitHub 当成一个 Git 服务器使用。</p><h3 id="SSH-访问"><a class="header-anchor" href="#SSH-访问"></a>SSH 访问</h3><p>使用 SSH 远程可以避免后期频繁的输入用户名和密码，使用之前需要在 GitHub 上配置 SSH Keys 。</p><p>首先，需要在自己的本地环境生成一个公钥。（可以参考 <a href="https://blog.itwray.com/2023/12/15/git-study-4/">生成SSH公钥</a>。）</p><p>然后，在 GitHub 页面，点击设置按钮，找到 “SSH Keys” 配置项，点击 “New SSH Key”。</p><p><img src="/2023/12/19/git-study-6/image-20231219172755430.png" alt="image-20231219172755430"></p><p>最后，在弹出的新增框中，输入自定义标题，并把公钥复制到 Key 下，SSH 远程配置就算是完成了。</p><h3 id="邮箱地址"><a class="header-anchor" href="#邮箱地址"></a>邮箱地址</h3><p>GitHub 使用用户邮件地址区分 Git 提交。 如果你在自己的提交中使用了多个邮件地址，希望 GitHub 可以正确地将它们连接起来， 你需要在管理页面的 Emails 部分添加你拥有的所有邮箱地址。</p><p><img src="/2023/12/19/git-study-6/image-20231219173101513.png" alt="image-20231219173101513"></p><p>通过它的注释内容可以看出，邮箱地址分为两种，一个为 Primary 主邮箱地址，用于账户验证和接收通知消息，而其他邮箱地址则只用于账户验证。</p><p>还有一种邮箱地址是未验证的，未验证的邮箱地址是不能设置为主邮箱地址的。</p><h3 id="两步验证"><a class="header-anchor" href="#两步验证"></a>两步验证</h3><p>为了额外的安全性，你绝对应当设置两步验证，简写为 “2FA”。 两步验证是一种用于降低因你的密码被盗而带来的账户风险的验证机制，现在已经变得越来越流行。 开启两步验证，GitHub 会要求你用两种不同的验证方法，这样，即使其中一个被攻破，攻击者也不能访问你的账户。</p><p>在设置中找到 “Two-factor authentication” 项，开启两步验证功能。</p><h2 id="对项目做出贡献"><a class="header-anchor" href="#对项目做出贡献"></a>对项目做出贡献</h2><p>当想要参与一个项目时，如果没有推送权限，可以通过 Fork + Pull Request 的方式参与项目的开发，不过它需要项目管理者的审批。</p><p>Fork 表示派生，当派生一个项目时，GitHub 会在个人仓库下创建一个项目副本，开发者可以在这个项目下进行提交和推送。</p><p>项目开发完毕后，再通过 Pull Request 合并请求，在原项目的页面上，找到“New pull request”按钮，发起一个PR请求，然后等待项目管理者审核。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-分布式Git(5)</title>
      <link href="/2023/12/17/git-study-5/"/>
      <url>/2023/12/17/git-study-5/</url>
      
        <content type="html"><![CDATA[<p>这一章中，你将会学习如何作为贡献者或整合者，在一个分布式协作的环境中使用 Git。 你会学习为一个项目成功地贡献代码，并接触一些最佳实践方式，让你和项目的维护者能轻松地完成这个过程。另外，你也会学到如何管理有很多开发者提交贡献的项目。</p><h2 id="分布式工作流程"><a class="header-anchor" href="#分布式工作流程"></a>分布式工作流程</h2><p>Git 作为分布式版本控制系统，一个项目可以跟踪多个远程仓库，每个开发者在项目开发时可以将自己的代码贡献到其他仓库，同时也可以维护自己的远程仓库，而其他人也可以在该开发者的远程仓库上工作并贡献代码。基于此，Git 的工作流程可以衍生出多种应用方式。</p><h3 id="集中式工作流"><a class="header-anchor" href="#集中式工作流"></a>集中式工作流</h3><p>集中式工作流更符合传统意义上集中式版本控制系统的工作流程方式，一个项目一般只会有一个中心仓库，所有开发者将自己的工作与之同步。</p><p>当多个开发者从中心仓库克隆代码下来后，同时作了修改，那么只有第一个开发者可以顺利的把数据推送到共享服务器。第二个开发者在推送修改之前，必须要先将前者的工作合并进行，确保不会覆盖前者的修改内容，再推送共享服务器。</p><p>在公司或者团队中，可能集中式工作流程更适合，只要正确利用好分支模型，一个百人团队的项目也可以很好的协作开发。</p><h3 id="集成管理者工作流"><a class="header-anchor" href="#集成管理者工作流"></a>集成管理者工作流</h3><p>Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表“官方”项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示：</p><ol><li>项目维护者推送到主仓库。</li><li>贡献者克隆此仓库，做出修改。</li><li>贡献者将数据推送到自己的公开仓库。</li><li>贡献者给维护者发送邮件，请求拉取自己的更新。</li><li>维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。</li><li>维护者将合并后的修改推送到主仓库。</li></ol><p><img src="/2023/12/17/git-study-5/image-20231219164749169.png" alt="image-20231219164749169"></p><p>这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。人们可以容易地将某个项目派生成为自己的公开仓库，向这个仓库推送自己的修改，并为每个人所见。 这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。 贡献者不必等待维护者处理完提交的更新——每一方都可以按照自己的节奏工作。</p><h3 id="主管与副主管工作流"><a class="header-anchor" href="#主管与副主管工作流"></a>主管与副主管工作流</h3><p>这其实是多仓库工作流程的变种。 一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。 被称为 <strong>副主管（lieutenant）</strong> 的各个集成管理者分别负责集成项目中的特定部分。 所有这些副主管头上还有一位称为 <strong>主管（dictator）</strong> 的总集成管理者负责统筹。 主管维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。 整个流程看起来是这样的：</p><ol><li>普通开发者在自己的主题分支上工作，并根据 <code>master</code> 分支进行变基。 这里是主管推送的参考仓库的 <code>master</code> 分支。</li><li>副主管将普通开发者的主题分支合并到自己的 <code>master</code> 分支中。</li><li>主管将所有副主管的 <code>master</code> 分支并入自己的 <code>master</code> 分支中。</li><li>最后，主管将集成后的 <code>master</code> 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。</li></ol><p><img src="/2023/12/17/git-study-5/image-20231219164851026.png" alt="image-20231219164851026"></p><p>这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。 利用这种方式，项目总负责人（即主管）可以把大量分散的集成工作委托给不同的小组负责人分别处理，然后在不同时刻将大块的代码子集统筹起来，用于之后的整合。</p><h3 id="工作流程总结"><a class="header-anchor" href="#工作流程总结"></a>工作流程总结</h3><p>一般项目下，可能都是使用的第一种“集中式工作流”进行协作开发，而像开源项目一般采用“集成管理者工作流”。</p><h2 id="向一个项目贡献"><a class="header-anchor" href="#向一个项目贡献"></a>向一个项目贡献</h2><p>描述如何向一个项目贡献的主要困难在于完成贡献有很多不同的方式。 因为 Git 非常灵活，人们可以通过不同的方式来一起工作，所以描述应该如何贡献并不是非常准确——每一个项目都有一点儿不同。 影响因素包括活跃贡献者的数量、选择的工作流程、提交权限与可能包含的外部贡献方法。</p><p>第一个影响因素是活跃贡献者的数量——积极地向这个项目贡献代码的用户数量以及他们的贡献频率。 在许多情况下，你可能会有两三个开发者一天提交几次，对于不活跃的项目可能更少。 对于大一些的公司或项目，开发者的数量可能会是上千，每天都有成百上千次提交。 这很重要，因为随着开发者越来越多，在确保你的代码能干净地应用或轻松地合并时会遇到更多问题。 提交的改动可能表现为过时的，也可能在你正在做改动或者等待改动被批准应用时被合并入的工作严重损坏。 如何保证代码始终是最新的，并且提交始终是有效的？</p><p>下一个影响因素是项目使用的工作流程。 它是中心化的吗，即每一个开发者都对主线代码有相同的写入权限？ 项目是否有一个检查所有补丁的维护者或整合者？ 是否所有的补丁是同行评审后批准的？ 你是否参与了那个过程？ 是否存在副官系统，你必须先将你的工作提交到上面？</p><p>下一个影响因素是提交权限。 是否有项目的写权限会使向项目贡献所需的流程有极大的不同。 如果没有写权限，项目会选择何种方式接受贡献的工作？ 是否甚至有一个如何贡献的规范？ 你一次贡献多少工作？ 你多久贡献一次？</p><h2 id="维护项目"><a class="header-anchor" href="#维护项目"></a>维护项目</h2><p>除了如何有效地参与一个项目的贡献之外，你可能也需要了解如何维护项目。 这包含接受并应用别人使用 <code>format-patch</code> 生成并通过电子邮件发送过来的补丁， 或对项目添加的远程版本库分支中的更改进行整合。 但无论是管理版本库，还是帮忙验证、审核收到的补丁，都需要同其他贡献者约定某种长期可持续的工作方式。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>本章节学习了使用 Git 为项目做出贡献、维护自己的项目或采纳其他用户的贡献。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-Git服务器(4)</title>
      <link href="/2023/12/15/git-study-4/"/>
      <url>/2023/12/15/git-study-4/</url>
      
        <content type="html"><![CDATA[<h2 id="协议"><a class="header-anchor" href="#协议"></a>协议</h2><p>Git 可以使用四种不同的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。</p><h3 id="本地协议"><a class="header-anchor" href="#本地协议"></a>本地协议</h3><p><em>本地协议（Local protocol）</em> 其中的远程版本库就是同一主机上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。</p><p>克隆一个本地版本库，可以执行如下的命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> /srv/git/project.git</span></span><br></pre></td></tr></table></figure><p>或你可以执行这个命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> file:///srv/git/project.git</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><p>基于文件系统的版本库的优点是简单，并且直接使用了现有的文件权限和网络访问权限。 如果你的团队已经有共享文件系统，建立版本库会十分容易。 只需要像设置其他共享目录一样，把一个裸版本库的副本放到大家都可以访问的路径，并设置好读/写的权限，就可以了。</p><p><strong>缺点</strong></p><p>这种方法的缺点是，通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问。 如果你想从家里推送内容，必须先挂载一个远程磁盘，相比网络连接的访问方式，配置不方便，速度也慢。</p><p>值得一提的是，如果你使用的是类似于共享挂载的文件系统时，这个方法不一定是最快的。 访问本地版本库的速度与你访问数据的速度是一样的。 在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</p><p>最终，这个协议并不保护仓库避免意外的损坏。 每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</p><h3 id="HTTP协议"><a class="header-anchor" href="#HTTP协议"></a>HTTP协议</h3><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为 <strong>智能</strong> HTTP 协议，旧版本的一般被称为 <strong>哑</strong> HTTP 协议。</p><p>智能 HTTP 的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制， 这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名/密码授权，免去设置 SSH 公钥。</p><p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务， 也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p><p><strong>优点</strong></p><p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p><p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p><p>另一个好处是 HTTPS 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p><p><strong>缺点</strong></p><p>在一些服务器上，架设 HTTPS 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与智能 HTTP 协议相比就几乎没有优势了。</p><p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 macOS 的 Keychain 或者 Windows 的凭证管理器。</p><h3 id="SSH协议"><a class="header-anchor" href="#SSH协议"></a>SSH协议</h3><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下服务器已经支持通过 SSH 访问 —— 即使没有也很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p><p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> ssh://[user@]server/project.git</span></span><br></pre></td></tr></table></figure><p>或者使用一个简短的 scp 式的写法：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> [user@]server:project.git</span></span><br></pre></td></tr></table></figure><p>在上面两种情况中，如果你不指定可选的用户名，那么 Git 会使用当前登录的用的名字。</p><p><strong>优点</strong></p><p>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTPS 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p><p><strong>缺点</strong></p><p>SSH 协议的缺点在于它不支持匿名访问 Git 仓库。 如果你使用 SSH，那么即便只是读取数据，使用者也 <strong>必须</strong> 通过 SSH 访问你的主机， 这使得 SSH 协议不利于开源的项目，毕竟人们可能只想把你的仓库克隆下来查看。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外， 还得架设一个可以让其他人访问的服务。</p><h3 id="Git协议"><a class="header-anchor" href="#Git协议"></a>Git协议</h3><p>最后是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p><p><strong>优点</strong></p><p>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><p><strong>缺点</strong></p><p>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 <code>git://</code> 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 <code>xinetd</code>、<code>systemd</code> 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p><blockquote><p>GitHub服务器使用的主要是Git协议和HTTPS协议。这两种协议分别用于代码版本控制系统Git的传输和Web服务的安全传输。</p><ol><li><strong>Git协议：</strong><ul><li>Git协议是专门为Git版本控制系统设计的传输协议。它使用SSH（Secure Shell）作为传输协议，提供对Git仓库的读写权限。通过Git协议，开发者可以克隆、推送和拉取代码。</li></ul></li><li><strong>HTTPS协议：</strong><ul><li>GitHub也支持通过HTTPS协议进行访问和传输。HTTPS提供了加密和身份验证的功能，通过TLS/SSL协议来保护数据传输的安全性。使用HTTPS协议，用户可以通过浏览器或Git客户端与GitHub进行交互。</li></ul></li></ol><p>Git协议使用SSH进行传输，而SSH本身具有授权机制。用户通过公钥和私钥进行身份验证，只有拥有正确私钥的用户才能与仓库进行交互。这提供了一定的安全性和授权机制。</p></blockquote><h2 id="生成SSH公钥"><a class="header-anchor" href="#生成SSH公钥"></a>生成SSH公钥</h2><p>默认情况下，用户的SSH密钥存储在 ~/.ssh 目录下。目录下的结构大致如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br></pre></td></tr></table></figure><p>我们需要寻找一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。 <code>.pub</code> 文件是你的公钥，另一个则是与之对应的私钥。 如果找不到这样的文件（或者根本没有 <code>.ssh</code> 目录），你可以通过运行 <code>ssh-keygen</code> 程序来创建它们。 在 Linux/macOS 系统中，<code>ssh-keygen</code> 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/schacon/.ssh/id_rsa):</span><br><span class="line">Created directory &#x27;/home/schacon/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</span><br></pre></td></tr></table></figure><p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。 如果你不想在使用密钥时输入口令，将其留空即可。 然而，如果你使用了密码，那么请确保添加了 <code>-o</code> 选项，它会以比默认格式更能抗暴力破解的格式保存私钥。 你也可以用 <code>ssh-agent</code> 工具来避免每次都要输入密码。</p><p>现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员 （假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 <code>.pub</code> 文件内容，并将其通过邮件发送。 公钥看起来是这样的：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@mylaptop.local</span><br></pre></td></tr></table></figure><h3 id="GitLab"><a class="header-anchor" href="#GitLab"></a>GitLab</h3><p>一般私服都会使用 GitLab 作为搭建Git服务器的解决方案。具体的安装和使用可以参考：<a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab">服务器上的Git - GitLab</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-Git分支(3)</title>
      <link href="/2023/12/12/git-study-3/"/>
      <url>/2023/12/12/git-study-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>继上次学习<a href="https://blog.itwray.com/2023/12/07/git-study-2/">Git学习-GIt基础</a>后，本章将学习Git分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p><p>有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p></blockquote><h2 id="分支简介"><a class="header-anchor" href="#分支简介"></a>分支简介</h2><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 <strong>快照</strong> 。</p><p>在进行<code>git commit</code>提交操作时，GIt 会保存一个提交对象。该提交对象包含一个指向暂存内容快照的指针，还包含提交作者的姓名、邮箱、提交信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p><p>为了形象说明上述的提交对象，假设现在有一个工作目录，有三个文件，并且还没有进行提交过。然后进行暂存和提交操作，暂存操作时会为每一个文件计算校验和，校验和 使用 <strong>blob</strong> 对象保存，提交操作时会计算每个子目录的校验和，然后在Git仓库中这些校验和保存为树对象。随后，Git会创建一个提交对象，它包含一个指向这个树对象的指针。</p><blockquote><p>实际上，Git中的每个提交都包含一个树对象，该树对象描述了在该提交中所有文件和子目录的布局。这个树对象包含指向对应文件和子目录的树对象或者文件对象的引用。</p><p>简而言之，Git的每一次提交都会对应有一个树对象，也只能有一个树对象。</p></blockquote><p>现在，Git 仓库中有五个对象：三个 <em>blob</em> 对象（保存着文件快照）、一个 <strong>树</strong> 对象 （记录着目录结构和 blob 对象索引）以及一个 <strong>提交</strong> 对象（包含着指向前述树对象的指针和所有提交信息）。</p><p><img src="/2023/12/12/git-study-3/image-20231214162142939.png" alt="image-20231214162142939"></p><p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><p><img src="/2023/12/12/git-study-3/image-20231214162202144.png" alt="image-20231214162202144"></p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 <code>master</code> 分支会在每次提交时自动向前移动。</p><h2 id="分支创建"><a class="header-anchor" href="#分支创建"></a>分支创建</h2><p>GIt 创建分支只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch testing</span></span><br></pre></td></tr></table></figure><p>这会在当前所在的提交对象上创建一个指针。</p><p><img src="/2023/12/12/git-study-3/image-20231214162603258.png" alt="image-20231214162603258"></p><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <strong>创建</strong> 一个新分支，并不会自动切换到新分支中去。</p><p><img src="/2023/12/12/git-study-3/image-20231214162634544.png" alt="image-20231214162634544"></p><h2 id="分支切换"><a class="header-anchor" href="#分支切换"></a>分支切换</h2><p>使用 <code>git checkout</code> 命令切换分支。例如现在需要切换到 <code>testing</code> 分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><p><img src="/2023/12/12/git-study-3/image-20231214162732333.png" alt="image-20231214162732333"></p><p>HEAD 指针会随着提交操作自动向前移动，也会在切换分支时移动到对应分支的最新提交上。</p><p>在切换分支时，<code>git checkout</code> 命令实际做了两件事，一是使 HEAD 指回目标分支，二是将工作目录恢复成目标分支所指向的快照内容。</p><blockquote><p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p><p>一般是在Git中有未提交的更改时，尝试切换分支可能会被拒绝。这是因为Git不希望在未保存更改的情况下让你切换到另一个分支，以防止潜在的冲突和数据丢失。</p><p>在出现禁止切换分支时，可以提交更改（<code>git commit -a</code>），也可以储藏更改（<code>git stash</code>）。</p></blockquote><h2 id="分支合并"><a class="header-anchor" href="#分支合并"></a>分支合并</h2><p>使用 <code>git merge</code> 合并分支。例如现在有 <code>master</code> 和 <code>iss53</code> 两个分支，现在需要把 <code>iss53</code> 合并到 <code>master</code> 分支下，运行如下命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 当出现冲突时，提示内容如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><h2 id="分支管理"><a class="header-anchor" href="#分支管理"></a>分支管理</h2><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --no-merged</span></span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">error: The branch &#x27;testing&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.</span><br></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><blockquote><p>如果在 <code>git branch --no-merged</code> 不加任何参数，表示默认检查当前分支。</p><p>使用 <code>git branch --no-merged master</code> 命令，表示查看未合并到master分支的有哪些。</p></blockquote><h2 id="远程分支"><a class="header-anchor" href="#远程分支"></a>远程分支</h2><h3 id="远程分支概念"><a class="header-anchor" href="#远程分支概念"></a>远程分支概念</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等。</p><p>使用 <code>git ls-remote &lt;remote&gt;</code>  显式地获取远程引用的完整列表。</p><p><img src="/2023/12/12/git-study-3/image-20231214165623679.png" alt="image-20231214165623679"></p><p>使用<code>git remote show &lt;remote&gt;</code> 可以获得远程分支的更多信息。</p><p><img src="/2023/12/12/git-study-3/image-20231214165633071.png" alt="image-20231214165633071"></p><p>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。</p><p>远程分支都是以 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名。</p><p>假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p><p><img src="/2023/12/12/git-study-3/image-20231214165759669.png" alt="image-20231214165759669"></p><p>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p><p><img src="/2023/12/12/git-study-3/image-20231214165822344.png" alt="image-20231214165822344"></p><p>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（在本例中为 <code>git fetch origin</code>）。 这个命令查找 <code>origin</code> 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p><p><img src="/2023/12/12/git-study-3/image-20231214165844920.png" alt="image-20231214165844920"></p><p>在使用了 <code>git fetch</code> 拉取远程仓库的数据后，使用 <code>git merge</code> 命令会将远程分支与本地分支进行合并。但需要注意的是，当前本地分支需要跟踪该远程分支才行。</p><h3 id="跟踪分支"><a class="header-anchor" href="#跟踪分支"></a>跟踪分支</h3><p>使用 <code>git branch -u &lt;remote&gt;/branch</code> 将当前本地分支跟踪到指定远程仓库的远程分支上。<code>-u</code>参数也可以换成 <code>--set-upstream-to</code> 参数。</p><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。</p><p>使用 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code> 命令，会创建一个本地分支并跟踪到指定远程分支，同时切换分支。由于这个命令比较常用，Git提供了快捷方式，使用 <code>git checkout --track &lt;remote&gt;/&lt;branch&gt;</code> 命令可以做到上述命令相同的功能。</p><p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sf origin/serverfix</span></span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure><p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><br><p>使用 <code>git branch -vv</code> 命令，会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch --all; git branch -vv</span></span><br></pre></td></tr></table></figure><h3 id="拉取远程分支"><a class="header-anchor" href="#拉取远程分支"></a>拉取远程分支</h3><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p><h3 id="推送远程分支"><a class="header-anchor" href="#推送远程分支"></a>推送远程分支</h3><p>使用 <code>git push &lt;remote&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code> 推送指定的本地分支到指定远程仓库的远程分支下。如果远程分支不存在，Git会自动创建远程分支。</p><p>当本地分支已跟踪远程分支，可以直接使用 <code>git push</code> 推送当前本地分支至跟踪的远程分支上。</p><p><code>git push --force-with-lease</code> 是一个用于 Git 的命令，它在强制推送（force push）时提供了一种更安全的方式。</p><p>通常情况下，使用 <code>git push --force</code> 命令可以强制推送你的本地分支到远程仓库，即使这样可能会覆盖其他人的提交。这可能会导致数据丢失或合作困难。</p><p>而 <code>git push --force-with-lease</code> 命令可以避免这种情况。它会首先检查远程分支的状态，确保你的本地分支是基于最新的远程分支提交的。如果你的本地分支落后于远程分支，那么 <code>--force-with-lease</code> 选项会拒绝推送，以防止覆盖其他人的提交。</p><h3 id="删除远程分支"><a class="header-anchor" href="#删除远程分支"></a>删除远程分支</h3><p>使用 <code>git push &lt;remote&gt; --delete &lt;branch&gt;</code> 删除远程分支。</p><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><p>使用 <code>git reflog show &lt;remote&gt;/&lt;branch&gt;</code> 命令查看已删除的分支。找到删除分支的提交哈希，重新新建本地分支并推送，即可恢复远程分支。</p><h2 id="变基"><a class="header-anchor" href="#变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。</p><h3 id="变基的基本操作"><a class="header-anchor" href="#变基的基本操作"></a>变基的基本操作</h3><p>假设现在Git上的分支情况如下：</p><p><img src="/2023/12/12/git-study-3/image-20231214172915634.png" alt="image-20231214172915634"></p><p>现在需要将 <code>experiment</code> 分支合并到 <code>master</code> 分支下。</p><p>如果使用合并 <code>merge</code> 命令，它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><p><img src="/2023/12/12/git-study-3/image-20231214173016814.png" alt="image-20231214173016814"></p><p>如果使用变基<code>rebase</code>命令，它将提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。操作命令如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）</p><p><img src="/2023/12/12/git-study-3/image-20231214173219126.png" alt="image-20231214173219126"></p><p>再将<code>C4</code>中的修改变基到<code>C3</code>上，现在回到 <code>master</code> 分支，进行一次快进合并。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge experiment</span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/12/git-study-3/image-20231214173306033.png" alt="image-20231214173306033"></p><p>此时，<code>C4'</code> 指向的快照就和 <code>merge</code> 合并操作中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><h3 id="变基的风险"><a class="header-anchor" href="#变基的风险"></a>变基的风险</h3><p>要用它得遵守一条准则：</p><p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</p><h3 id="变基-vs-合并"><a class="header-anchor" href="#变基-vs-合并"></a>变基 vs. 合并</h3><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <code>rebase</code> 及 <code>filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>本章主要学习了本地分支的创建、切换、合并、删除，远程分支的推送、跟踪、拉取、删除，分支管理的常用命令，分支合并与分支变基的区别与使用。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-Git基础(2)</title>
      <link href="/2023/12/07/git-study-2/"/>
      <url>/2023/12/07/git-study-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>继上次学习<a href="https://blog.itwray.com/2023/10/13/git-study-1/">Git学习-起步</a>后，本章将学习Git基础，本章涵盖了你在使用 Git 完成各种工作时将会用到的各种基本命令。 在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。 本章也将向你演示了如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）之间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。</p></blockquote><h2 id="获取-Git-仓库"><a class="header-anchor" href="#获取-Git-仓库"></a>获取 Git 仓库</h2><p>获取 Git 仓库有两种方式：</p><ol><li>将尚未进行版本控制的本地目录转换为 Git 仓库（<code>git init</code>）</li><li>从其他服务器 <strong>克隆</strong> 一个已存在的 Git 仓库（<code>git clone</code>）</li></ol><h3 id="在已存在目录中初始化仓库"><a class="header-anchor" href="#在已存在目录中初始化仓库"></a>在已存在目录中初始化仓库</h3><p>在已存在的目录路径下，执行 <code>git init</code> 。</p><p>执行完之后，Git 会在该目录下创建一个<code>.git</code>的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p><h3 id="克隆现有的仓库"><a class="header-anchor" href="#克隆现有的仓库"></a>克隆现有的仓库</h3><p>语法：<code>git clone &lt;url&gt;</code></p><p><code>&lt;url&gt;</code>就是 GIt 仓库的远程地址，Git 支持多种数据协议，例如<code>https</code>、<code>git</code>、<code>ssh</code>。</p><p>执行<code>git clone</code>命令后，Git 会在执行命令所在目录下创建一个 Git 仓库目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。</p><p>例如：<code>git clone https://github.com/libgit2/libgit2</code></p><p>Git 仓库的目录名称就为<code>libgit2</code>，如果希望在创建仓库时自定义仓库名称，可以通过额外的参数指定新的目录名。</p><p>例如：<code>git clone https://github.com/libgit2/libgit2 mylibgit</code></p><p>Git 仓库的目录名称就为<code>mylibgit</code>。</p><h2 id="Git-仓库文件的状态变化周期"><a class="header-anchor" href="#Git-仓库文件的状态变化周期"></a>Git 仓库文件的状态变化周期</h2><p><img src="/2023/12/07/git-study-2/image-20231207152109416.png" alt="image-20231207152109416"></p><p>结合上图，GIt 仓库下的文件分为四种状态：</p><ul><li>Untracked：未跟踪。</li><li>Unmodified：已跟踪且未修改。</li><li>Modified：已跟踪且已修改。</li><li>Staged：已暂存。</li></ul><p>通过上图的箭头可知，从左到右文件的状态变更流程如下：</p><ol><li>Untracked -&gt; Staged，使用 <code>git add</code> 暂存文件，将未跟踪的文件进行跟踪并暂存。</li><li>Staged -&gt; Unmodified，使用 <code>git commit</code> 提交文件，Git记录文件版本。</li><li>Unmodified -&gt; Modified，编辑文件，文件的状态从“未修改”变更为“已修改”。</li><li>Modified -&gt; Staged，使用 <code>git add</code> 暂存文件，将已跟踪且已修改的文件进行暂存。</li><li>Unmodified -&gt; Untracked，使用 <code>git rm</code> 将未修改的文件从已跟踪的文件列表中移除并在目录中删除。</li><li>Modified/Staged -&gt; Untracked，使用 <code>git rm -f</code>强制将已修改或已暂存的文件从已跟踪的文件列表中移除并在目录中删除。</li></ol><p>从上诉可知，Git 仓库的文件主要分为两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。</p><p>初次克隆 <code>git clone</code> 某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。反之，通过<code>git init</code>初始化的Git仓库，工作目录中的所有文件都属于未跟踪文件。</p><h3 id="git-status"><a class="header-anchor" href="#git-status"></a>git status</h3><p>可以用 <code>git status</code> 命令查看 Git 仓库下的文件状态。</p><p>如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。</p><p>再看下面截图的情况：</p><p><img src="/2023/12/07/git-study-2/image-20231207163143786.png" alt="image-20231207163143786"></p><p>上图分为三种文件状态：</p><ul><li>Changes to be committed：表示已暂存文件。</li><li>Changes not staged for commit：表示已跟踪且已修改的文件。</li><li>Untracked files：表示未跟踪的文件。</li></ul><h3 id="git-add"><a class="header-anchor" href="#git-add"></a>git add</h3><p><code>git add</code> 是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p><h3 id="gitignore忽略文件"><a class="header-anchor" href="#gitignore忽略文件"></a>.gitignore忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。</p><p>关于<code>.gitignore</code>文件的详细解释，可以参考 <a href="https://blog.itwray.com/2023/11/02/git-study-commands/">Git学习-命令</a> 章节中的1.3小节。</p><h3 id="git-diff"><a class="header-anchor" href="#git-diff"></a>git diff</h3><p>当想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。不过不太推荐这个命令。。。建议使用图形化工具，例如 IDEA、SourceTree 等。</p><h3 id="git-commit"><a class="header-anchor" href="#git-commit"></a>git commit</h3><p>使用 <code>git commit</code> 命令，会将暂存区中的文件创建为一次提交记录，并生成一个完整 SHA-1 校验和的版本号。</p><p><code>git commit</code>命令会要求每次提交都带有提交说明，在未指定<code>-m</code>参数时，git会启用文本编辑器来输入提交说明。</p><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p><p><code>git commit</code>只提交指定的文件，而非暂存区所有的文件，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit path/to/your/file.ext -m <span class="string">&quot;Your commit message&quot;</span></span><br></pre></td></tr></table></figure><p>在这个命令中，<code>path/to/your/file.ext</code> 是要提交的特定文件的路径，<code>-m</code> 选项用于添加提交消息。</p><p>如果要提交多个文件，可以将它们一起列出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit path/to/your/file1.ext path/to/your/file2.ext -m <span class="string">&quot;Your commit message&quot;</span></span><br></pre></td></tr></table></figure><h3 id="git-rm"><a class="header-anchor" href="#git-rm"></a>git rm</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p><code>git rm</code>一般用于已跟踪且未修改（Unmodified）的文件。如果是未跟踪文件，直接使用rm删除即可。如果是已跟踪且已修改（Modified） 或者 已跟踪且已暂存（Staged）的文件，则需要使用<code>-f</code>参数，强制删除。</p><p>当想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached README</span><br></pre></td></tr></table></figure><h3 id="git-mv"><a class="header-anchor" href="#git-mv"></a>git mv</h3><p>Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。</p><p>语法：<code>git mv file_from file_to</code></p><p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure><p>如此分开操作，Git 也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别在于，<code>git mv</code> 是一条命令而非三条命令，直接使用 <code>git mv</code> 方便得多。 不过在使用其他工具重命名文件时，记得在提交前 <code>git rm</code> 删除旧文件名，再 <code>git add</code> 添加新文件名。</p><h2 id="查看提交历史"><a class="header-anchor" href="#查看提交历史"></a>查看提交历史</h2><p>使用 <code>git log</code> 即可查看提交历史。</p><p><img src="/2023/12/07/git-study-2/image-20231207171033768.png" alt="image-20231207171033768"></p><p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p>使用 <code>git log --pretty=oneline</code>命令，可以只查看提及记录的版本号和提交备注。</p><p><img src="/2023/12/07/git-study-2/image-20231211172914540.png" alt="image-20231211172914540"></p><p>使用<code>-n</code>参数，可以只查看最近n次提交历史。</p><p>使用 <code>--stat</code>参数，显示在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><p><img src="/2023/12/07/git-study-2/image-20231207171305899.png" alt="image-20231207171305899"></p><p><code>git log</code>在终端提供了许多参数，但个人还是推荐使用图形化工具，例如IDEA、SourceTree等。</p><h2 id="撤销操作"><a class="header-anchor" href="#撤销操作"></a>撤销操作</h2><p>撤销操作可以指替多个方面，比如撤销工作目录的修改、撤销提交历史、撤销暂存等。</p><p>撤销命令有两个，一般使用<code>git restore</code>撤销工作目录中的文件，使用<code>git reset</code>撤销提交历史。</p><p>现在有如下图所示的工作目录状态：</p><p><img src="/2023/12/07/git-study-2/image-20231208110044957.png" alt="image-20231208110044957"></p><p>使用 <code>git restore --staged &lt;file&gt;</code> 会将暂存区中的文件撤销到未暂存已修改状态下，即撤销了 <code>git add</code> 命令的操作，但没有还原文件的修改记录。</p><p>使用 <code>git restore &lt;file&gt;</code> 撤销工作目录中文件的修改记录，还原到上一次提交记录的版本。</p><p>而 <code>git reset</code> 命令功能，可以参考 <a href="https://blog.itwray.com/2023/11/22/git-commands-reset/">Git命令-reset</a> 文章。</p><br><p>在使用<code>git commit</code>时，有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;initial commit&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add forgotten_file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><blockquote><p>当你在修补最后的提交时，与其说是修复旧提交，倒不如说是完全用一个 <strong>新的提交</strong> 替换旧的提交， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。</p><p>修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。</p></blockquote><h2 id="远程仓库的使用"><a class="header-anchor" href="#远程仓库的使用"></a>远程仓库的使用</h2><p>Git使用远程仓库实现Git项目协作功能。远程仓库是指托管在因特网或其他网络中项目的版本库。远程仓库用于用户来说，具有权限划分，例如只读（fetch）、读写（push）。一个项目可以有多个远程仓库。</p><blockquote><p>Git的远程仓库并不是指一定是互联网上的仓库，也可以是本地主机，“远程仓库”更多的是想表达它在别处的意思。把远程仓库部署在本地主机，在通过Git项目推送到远程仓库，也是一种管理远程仓库的概念。</p></blockquote><h3 id="查看远程仓库"><a class="header-anchor" href="#查看远程仓库"></a>查看远程仓库</h3><p>每个远程仓库都会被git定义一个简写的仓库名称，一般默认为orign。</p><p>使用 <code>git remote</code> 可以查看当前项目下所有的远程仓库简写名称</p><p><img src="/2023/12/07/git-study-2/image-20231211165852679.png" alt="image-20231211165852679"></p><p>使用 <code>git remote -v</code> 查看远程仓库的简写名称与其对应的URL，并标注远程仓库的读写权限。</p><p><img src="/2023/12/07/git-study-2/image-20231211170031846.png" alt="image-20231211170031846"></p><h3 id="添加远程仓库"><a class="header-anchor" href="#添加远程仓库"></a>添加远程仓库</h3><p>在 <strong>获取Git仓库</strong> 章节中，使用 <code>git clone</code> 可以从远程仓库克隆项目到本地，并且会为本地Git项目添加该远程仓库地址。</p><p>而对于本地使用 <code>git init</code> 初始化的GIt项目，就需要手动添加远程仓库。</p><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 为Git项目添加一个新的远程仓库。其中的 <code>shortname</code> 表示远程仓库简写名称，<code>uerl</code> 表示远程仓库地址。</p><p>添加远程仓库之后，可以运行 <code>git fetch &lt;remote&gt;</code> 拉取远程仓库信息。其中的 <code>&lt;remote&gt;</code> 表示远程仓库简写名称，即 <code>&lt;shortname</code> 。</p><p>使用 <code>git fetch</code>之后，这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><h3 id="推送到远程仓库"><a class="header-anchor" href="#推送到远程仓库"></a>推送到远程仓库</h3><p>使用 <code>git push &lt;remote&gt; &lt;branch&gt;</code> 推送Git项目的具体某个分支到远程仓库。关于推送功能的注意点：</p><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</p><p>上述这句话简而言之就是，在 <code>git push</code> 之前，建议先 <code>git pull</code>。</p><h3 id="查看某个远程仓库"><a class="header-anchor" href="#查看某个远程仓库"></a>查看某个远程仓库</h3><p>当想要查询某个远程仓库的更多信息，例如URL、分支等。可以使用 <code>git remote show &lt;remote&gt; </code>命令。</p><p><img src="/2023/12/07/git-study-2/image-20231211171903258.png" alt="image-20231211171903258"></p><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 <code>main</code> 分支，并且如果运行 <code>git pull</code>， 就会抓取所有的远程引用，然后将远程 <code>main</code> 分支合并到本地 <code>main</code> 分支。 它也会列出拉取到的所有远程引用。</p><h3 id="远程仓库的重命名和移除"><a class="header-anchor" href="#远程仓库的重命名和移除"></a>远程仓库的重命名和移除</h3><p>你可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote remove paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p><h2 id="Git标签"><a class="header-anchor" href="#Git标签"></a>Git标签</h2><p>Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）。</p><h3 id="列出标签"><a class="header-anchor" href="#列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签非常简单，只需要输入 <code>git tag</code> （可带上可选的 <code>-l</code> 选项 <code>--list</code>）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v1.0</span><br><span class="line">v2.0</span><br></pre></td></tr></table></figure><p>这个命令以字母顺序列出标签，但是它们显示的顺序并不重要。</p><p>你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -l <span class="string">&quot;v1.8.5*&quot;</span></span></span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br></pre></td></tr></table></figure><blockquote><p>按照通配符列出标签需要 <code>-l</code> 或 <code>--list</code> 选项</p><p>如果你只想要完整的标签列表，那么运行 <code>git tag</code> 就会默认假定你想要一个列表，它会直接给你列出来， 此时的 <code>-l</code> 或 <code>--list</code> 是可选的。</p><p>然而，如果你提供了一个匹配标签名的通配模式，那么 <code>-l</code> 或 <code>--list</code> 就是强制使用的。</p></blockquote><h3 id="创建标签"><a class="header-anchor" href="#创建标签"></a>创建标签</h3><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p><p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p><blockquote><p>使用 <code>git show &lt;tag&gt;</code> 可以查看标签信息，比较轻量标签和附注标签最简单的方式，就是看标签信息最前面是否有 <strong>标签版本</strong>、<strong>Tagger（打标签者的信息）</strong>、<strong>Date（打标签的时间点）</strong>、<strong>标签备注</strong>。</p></blockquote><h3 id="附注标签"><a class="header-anchor" href="#附注标签"></a>附注标签</h3><p>在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.4 -m <span class="string">&quot;my version 1.4&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</p><p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4</span></span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h3 id="轻量标签"><a class="header-anchor" href="#轻量标签"></a>轻量标签</h3><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v1.4-lw</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure><p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4-lw</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><h3 id="后期打标签"><a class="header-anchor" href="#后期打标签"></a>后期打标签</h3><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure><p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.2 9fceb02</span></span><br></pre></td></tr></table></figure><p>可以看到你已经在那次提交上打上标签了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.2</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.2</span></span><br><span class="line">tag v1.2</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 15:32:16 2009 -0800</span><br><span class="line"></span><br><span class="line">version 1.2</span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="共享标签"><a class="header-anchor" href="#共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push &lt;remote&gt; &lt;tagname&gt;</code>。</p><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><p><img src="/2023/12/07/git-study-2/image-20231211174337165.png" alt="image-20231211174337165"></p><blockquote><p>使用 --tags 推送所有标签是，不会区分轻量标签和附注标签，Git也没有提供参数支持各自推送。</p></blockquote><h3 id="删除标签"><a class="header-anchor" href="#删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。 例如，可以使用以下命令删除一个轻量标签：（该方法不会从任何远程仓库中移除这个标签）</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v1.4-lw</span></span><br><span class="line">Deleted tag &#x27;v1.4-lw&#x27; (was e7d5add)</span><br></pre></td></tr></table></figure><p>删除远程仓库标签的方式为 <code>git push &lt;remote&gt; --delete &lt;tagname&gt;</code></p><h3 id="检出标签"><a class="header-anchor" href="#检出标签"></a>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout 2.0.0</span></span><br><span class="line">Note: checking out &#x27;2.0.0&#x27;.</span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout 2.0-beta-0.1</span></span><br><span class="line">Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final</span><br><span class="line">HEAD is now at df3f601... add atlas.json and cover image</span><br></pre></td></tr></table></figure><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b version2 v2.0.0</span></span><br><span class="line">Switched to a new branch &#x27;version2&#x27;</span><br></pre></td></tr></table></figure><p>如果在这之后又进行了一次提交，<code>version2</code> 分支就会因为这个改动向前移动， 此时它就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就要当心了。</p><h2 id="Git-别名"><a class="header-anchor" href="#Git-别名"></a>Git 别名</h2><p>Git 别名功能类似于Linux上的<code>alias</code>命令，但 Git 只是简单地将别名替换为对应的命令。它通过<code>git config</code>配置。</p><p>例如，配置 <code>git config --global alias.st status</code>，当想要执行<code>git status</code>时，可以直接输入<code>git st</code>。</p><p>当想要执行外部命令，而不是一个 Git 子命令时。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>至此，Git 的基础操作基本就介绍完了。大致包括有：创建或克隆一个仓库、进行更改、暂存并提交这些更改、浏览仓库从创建到现在的所有更改历史。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活日记-20231205</title>
      <link href="/2023/12/05/life-200231205/"/>
      <url>/2023/12/05/life-200231205/</url>
      
        <content type="html"><![CDATA[<p>记录最近看到的一句话：</p><p><em><strong>努力不一定就有希望</strong></em></p><p><em><strong>但不努力一定没希望</strong></em></p><p><em><strong>希望通过努力让每一个家庭团圆</strong></em></p><br><p>至此：愿世间少一点病魔，多一点温暖。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记录一次macOS输入法卡顿的现象问题</title>
      <link href="/2023/11/22/other-macos-input-method/"/>
      <url>/2023/11/22/other-macos-input-method/</url>
      
        <content type="html"><![CDATA[<h2 id="问题现象"><a class="header-anchor" href="#问题现象"></a>问题现象</h2><p>记录一次 macOS 输入法卡顿的现象问题，特别是在 Typora 编辑器下编辑时会特别卡顿。</p><p>在一个平常的日子，跟往常一样打开 Typora 编写md文件，发现打字时极其卡顿，基本上每敲出一个字符都会卡一下。</p><h2 id="问题分析与解决方案"><a class="header-anchor" href="#问题分析与解决方案"></a>问题分析与解决方案</h2><p>先说解决方案：<strong>将 macOS 下“设置”-“键盘”-“输入法”下的自定义短语删掉即可。</strong></p><p>因为在其他软件上感觉还好，基本没什么卡顿，测试软件为 IDEA 和 VSCode ，所以就怀疑是不是 Typora 的原因。</p><p>所以就Google了“ Typora for mac 打字卡顿”，看到一个帖子<a href="https://www.v2ex.com/t/837163">https://www.v2ex.com/t/837163</a>，大致内容如下：</p><p><img src="/2023/11/22/other-macos-input-method/image-20231122172613926.png" alt="image-20231122172613926"></p><p>同时，又在另一个blog下，说可能是因为 Typora 的“自动保存”功能导致的，关闭掉之后有效缓解卡顿。但我发现他是 Windows 版本的，在 macOS 版本下，我把 Typora 的配置翻烂了也没找到。</p><p>于是，在一个帖子上找到了相关解释。</p><p><img src="/2023/11/22/other-macos-input-method/image-20231122173339756.png" alt="image-20231122173339756"></p><p>GitHub 的issues链接：[https://github.com/ Typora / Typora -issues/issues/1641](https://github.com/ Typora / Typora -issues/issues/1641)</p><p>至此，我一度怀疑就是 Typora 的原因，在此期间内心一阵疯狂吐槽。。。</p><p>回想最近，我也没有动过 Typora 软件，也没有升级过。但还是检查了下是否有最新版本，发现有一个小版本可以更新，更新完之后，还是一点用没有。甚至我还找到历史版本随便下载了一个早期的大版本，发现也不行。</p><p>至此，我都想吐槽自己， Typora 突然卡顿，在我确定没动过版本的情况下，怎么可能是因为版本的原因呢。</p><p>于是，我又怀疑是 Typora 打开的目录下的md文件太多的原因，于是打开了一个只有一个md文件的目录，发现还是如此。</p><p>在 Typora 上各种尝试之后，我发现在源代码模式（<code>command+/</code>）下，编辑不会卡顿。因此我更加怀疑，不会真的是 Typora “所写即所得”的特性导致的吧。内心奔溃，因为如果真的如此，我这花原价购买的许可证岂不浪费了，血亏。。。</p><p>理智告诉我， Typora 应该不至于如此垃圾吧。。。毕竟这个卡顿现象也太严重了，网上却并没有很多相关资料。</p><p>于是，我又在网上各种查阅，百度、Google齐上阵，在使用搜索引擎时，打字输入搜索关键字时，我发现也会有点卡顿，在百度的搜索框下比较明显。（内心还吐槽了一阵百度[捂脸]）</p><p>突然，灵感突发，在 Typora 上打字是卡，复制粘贴时却不卡，一开始还以为是复制的内容量小，于是故意复制很长一段富文本内容，粘贴发现并没有什么卡顿。因为如此，我就感觉不是 Typora “所写即所得”的特性导致的。</p><p>既然是打字卡，那有可能是输入法导致的。于是回想了下最近，因为一直使用的是macOS原生的简体中文输入法，感觉原生输入法在敲一些长句或者网络流行句时需要手动找半天，不像国产输入法那样，都会有一些网络词库，于是就安装了个百度输入法体验体验，最后实在是用不习惯，又卸载了。</p><p>既然又想继续使用原生输入法，又想体验国产那些网络词库。因此就找网上找到一些解决方案，大致就是将其他输入法的词库导出出来，通过工具转换成macOS原生输入法的词库（.plist后缀结尾的文件），然后将该词库拖拽到输入法的自定义短语下即可。（在macOS 14.1.1下，“设置”-“键盘”-“文字输入”-“自定义短语”）</p><p><img src="/2023/11/22/other-macos-input-method/image-20231123135025399.png" alt="image-20231123135025399"></p><p>搞完之后，发现还挺好用，于是就一直这样设置的。却忽略了一点，那就是词库量可能比较大，影响到了输入法输入时的效率。</p><p>macOS的“自定义短语”功能，猜想一下应该是在用户输入时，输入法会根据输入内容实时检索短语列表，而且这个检索不仅是在简体拼音下有效，对于“ABC”这种英文输入法也会有效，而导致于在 Typora 编写时，敲一个“ `` ”都非常费劲。</p><p>既然是猜测词库量太大导致的，我就索性直接把所有自定义短语都删了，再在 Typora 下试了下，健步如飞。。。</p><p>再去百度搜索引擎下测试了下，也是一样，健步如飞。。。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>从出现这个问题，到解决问题，差不多花了快3个小时，一方面是还需要忙工作上的事，另一方面主要还是陷入到了自己的愚蠢中。</p><p>对于问题的出现，不应该一股脑的去瞎尝试（更新 Typora 版本），也不应该过渡依赖搜索引擎。问题是自己导致的（虽然在一开始不知道），应该从自身出发，先通过各方面测试确定到底是哪一步导致的，再回顾自己最近的操作，通过一步步还原去查明真相，最后解决问题。</p><p>如果对于问题实在是一头雾水，借鉴搜索引擎是必然的，毕竟总要有希望能遇到他人的前车之鉴。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
            <tag> 输入法 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-reset命令</title>
      <link href="/2023/11/22/git-commands-reset/"/>
      <url>/2023/11/22/git-commands-reset/</url>
      
        <content type="html"><![CDATA[<h2 id="Git的三棵树"><a class="header-anchor" href="#Git的三棵树"></a>Git的三棵树</h2><p>在了解<code>reset</code>特性之前，先了解 Git 的三棵树含义。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：</p><p><img src="/2023/11/22/git-commands-reset/image-20231122163553891.png" alt="image-20231122163553891"></p><h3 id="HEAD"><a class="header-anchor" href="#HEAD"></a>HEAD</h3><p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 <strong>该分支上的最后一次提交</strong> 的快照。</p><h3 id="Index（索引）"><a class="header-anchor" href="#Index（索引）"></a>Index（索引）</h3><p>索引是你的 <strong>预期的下一次提交</strong>。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 <code>git commit</code> 时 Git 看起来的样子。</p><h3 id="Working-Directory（工作目录）"><a class="header-anchor" href="#Working-Directory（工作目录）"></a>Working Directory（工作目录）</h3><p><strong>工作目录</strong>（通常也叫 <strong>工作区</strong>）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 <code>.git</code> 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 <strong>沙盒</strong>。在你将修改提交到暂存区并记录到历史之前，可以随意更改。</p><h2 id="Git的工作流程"><a class="header-anchor" href="#Git的工作流程"></a>Git的工作流程</h2><p>经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。</p><p><img src="/2023/11/22/git-commands-reset/reset-workflow.png" alt="reset workflow"></p><p>这里面的三个操作含义分别如下：</p><ul><li>Stage Files：通过<code>git add</code>暂存文件到Index，便于下一次提交。</li><li>Commit：提交Index中的内容，并将其保存为一个永久的快照，然后创建一个指向该快照的提交对象。HEAD指针也会在提交完后指向该快照。</li><li>Checkout the project：在本图示例中，它表示提交完后，HEAD指针指向当前工作区的快照。此外，Git有一个git checkout`操作，可以将HEAD指针指向指定的分支，从而将工作区的内容切换到指定分支的对应的索引，再将索引的内容拷贝到工作区。</li></ul><p>实际的可视化过程如下：</p><p>假设现在有一个新目录，其中有一个文件（file.txt）。将该文件称为v1版本，并标记为蓝色。在这个目录路径下现在运行<code>git init</code>，这会创建一个Git仓库，其中HEAD引用指向未创建的<code>master</code>分支。</p><p><img src="/2023/11/22/git-commands-reset/image-20231124142318855.png" alt="image-20231124142318855"></p><p>此时，只有工作目录有内容。</p><p>现在我们想要提交这个文件，所以用 <code>git add</code> 来获取工作目录中的内容，并将其复制到索引中。</p><p><img src="/2023/11/22/git-commands-reset/image-20231124142355657.png" alt="image-20231124142355657"></p><p>接着运行 <code>git commit</code>，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 <code>master</code> 来指向本次提交。</p><p><img src="/2023/11/22/git-commands-reset/image-20231124142425038.png" alt="image-20231124142425038"></p><p>此时如果我们运行 <code>git status</code>，会发现没有任何改动，因为现在三棵树完全相同。</p><p>现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 <strong>v2</strong> 版本，并将它标记为红色。</p><p><img src="/2023/11/22/git-commands-reset/image-20231124142447025.png" alt="image-20231124142447025"></p><p>如果现在运行 <code>git status</code>，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 <code>git add</code> 来将它暂存到索引中。</p><p><img src="/2023/11/22/git-commands-reset/image-20231124142509271.png" alt="image-20231124142509271"></p><p>此时，由于索引和 HEAD 不同，若运行 <code>git status</code> 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 <code>git commit</code> 来完成提交。</p><p><img src="/2023/11/22/git-commands-reset/image-20231124142538812.png" alt="image-20231124142538812"></p><p>现在运行 <code>git status</code> 会没有输出，因为三棵树又变得相同了。</p><p>切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将 <strong>索引</strong> 填充为该次提交的快照， 然后将 <strong>索引</strong> 的内容复制到 <strong>工作目录</strong> 中。</p><p>至此，Git工作流程的可视化过程就大致描述完了，通过图形的方式，更加直观的展示了一个文件在Git仓库下经过 <code>Working Directory</code> -&gt; <code>Index</code> -&gt; <code>HEAD</code> 的过程。</p><h2 id="Git的reset"><a class="header-anchor" href="#Git的reset"></a>Git的reset</h2><p><code>reset</code>即为重置的意思，它主要可以做三件事：</p><ol><li>移动HEAD指针（--soft）</li><li>更新索引（--mixed）</li><li>更新工作目录（--hard）</li></ol><p><code>git reset</code>的语法：<code>git reset [--mixed | --soft | --hard] [&lt;commit&gt;]</code></p><p><code>--soft</code>：表示只移动HEAD指针。</p><p><code>--mixed</code>：表示移动HEAD指针并更新索引。</p><p><code>--hard</code>：表示移动HEAD指针，并更新索引和工作目录。</p><p><code>git reset</code>默认情况下是<code>--mixed</code>级别。也就是说执行该命令后，他会移动HEAD指针并更新索引。</p><p><code>&lt;commit&gt;</code>表示想要移动的版本，可以使用版本号的简写（例如<code>9e5e6a4</code>这种形式），也可以使用<code>HEAD~</code>形式。</p><p><code>HEAD~</code>表示上一个版本，<code>HEAD~2</code>表示上二个版本，以此类推。。。</p><br><p>接下来，解释下何为移动HEAD指针，何为更新索引，何为更新工作目录。</p><p>假设，现在有一个git仓库，它现有两个提交版本，如下：</p><p><img src="/2023/11/22/git-commands-reset/image-20231124160427130.png" alt="image-20231124160427130"></p><p>它的工作区是干净的，如下：</p><p><img src="/2023/11/22/git-commands-reset/image-20231124160450320.png" alt="image-20231124160450320"></p><p>现在针对上诉情况，各自执行<code>--soft</code>、<code>--mixed</code>、<code>--hard</code>三种参数。</p><p>第一种：执行<code>git reset --soft HEAD~</code>，再看<code>git log</code>和<code>git status</code>：</p><p><img src="/2023/11/22/git-commands-reset/image-20231124160625031.png" alt="image-20231124160625031"></p><p>通过<code>git log</code>发现，HEAD指针已经发生了变更。</p><p>通过<code>git status</code>发现，所有文件记录还是处于已暂存状态，表示还存在于索引中。</p><br><p>第二种：执行<code>git reset --mixed HEAD~</code>，再看<code>git log</code>和<code>git status</code>：</p><p><img src="/2023/11/22/git-commands-reset/image-20231124161148785.png" alt="image-20231124161148785"></p><p>通过<code>git log</code>发现，HEAD指针已经发生了变更。</p><p>通过<code>git status</code>发现，forgotten_file文件处于已变更但未暂存状态，而version文件处于未跟踪状态（因为它在上一次提交中属于新文件）。这种情况，表示重置到了没有执行<code>git add</code>之前，文件记录已经从索引中回退。</p><br><p>第二种：执行<code>git reset --hard HEAD~</code>，再看<code>git log</code>和<code>git status</code>：</p><p><img src="/2023/11/22/git-commands-reset/image-20231124161638120.png" alt="image-20231124161638120"></p><p>通过<code>git log</code>发现，HEAD指针已经发生了变更。</p><p>通过<code>git status</code>发现，工作目录下的文件都没有发生变更，表示所有文件记录都回退到了上一个版本，当前版本变更的文件内容都已消失。所以<code>--hard</code>是一个危险操作！</p><h2 id="Git-reset-pathspec"><a class="header-anchor" href="#Git-reset-pathspec"></a>Git reset &lt;pathspec&gt;</h2><p>如果<code>git reset</code>指定了一个作用路径（pathspec），那么他就会跳过第一步（移动HEAD指针），只在指定作用路径下重置文件记录。</p><p>语法为：<code>git reset [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;</code></p><p><code>&lt;tree-ish&gt;</code>表示分支版本，如果不指定，默认为HEAD，即当前版本。</p><p><code>[--]</code>表示重置操作，默认为--mixed。不能指定为--soft和--hard。</p><p><code>&lt;pathspec&gt;</code>表示作用路径，可以是具体文件，也可以是目录，也可以使用表达式。</p><p>示例：</p><ul><li><p><code>git reset file.txt</code>其实就是<code>git reset --mixed HEAD file.txt</code>的简写，表示将<code>file.txt</code>文件<strong>取消暂存</strong>。与它相反的是<code>git add file.txt</code>，表示将<code>file.txt</code>暂存。</p><blockquote><p>在后期Git版本中，推荐使用<code>git restore --staged &lt;file&gt;</code>用于取消暂存。</p></blockquote></li><li><p><code>git reset c54a forgotten_file</code>表示将<code>forgotten_file</code>文件重置到<code>c54a</code>这个版本，而将这个文件在<code>c54a</code>版本之后的改动标记为未暂存。</p></li></ul><h2 id="git-reset与git-checkout的区别"><a class="header-anchor" href="#git-reset与git-checkout的区别"></a>git reset与git checkout的区别</h2><p>总结：<code>git reset</code>和<code>git checkout</code>命令都具有修改HEAD指针指向的功能，只不过<code>git reset</code>是在当前分支移动HEAD指针，而<code>git checkout</code>是切换HEAD指针到指定分支。</p><p>和 <code>reset</code> 一样，<code>checkout</code> 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。</p><h3 id="不带路径"><a class="header-anchor" href="#不带路径"></a>不带路径</h3><p>运行 <code>git checkout [branch]</code> 与运行 <code>git reset --hard [branch]</code> 非常相似，它会更新所有三棵树使其看起来像 <code>[branch]</code>，不过有两点重要的区别。</p><p>首先不同于 <code>reset --hard</code>，<code>checkout</code> 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有 <em>还未修改过的</em> 文件都会被更新。 而 <code>reset --hard</code> 则会不做检查就全面地替换所有东西。</p><p>第二个重要的区别是 <code>checkout</code> 如何更新 HEAD。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 只会移动 HEAD 自身来指向另一个分支。</p><p>例如，假设我们有 <code>master</code> 和 <code>develop</code> 分支，它们分别指向不同的提交；我们现在在 <code>develop</code> 上（所以 HEAD 指向它）。 如果我们运行 <code>git reset master</code>，那么 <code>develop</code> 自身现在会和 <code>master</code> 指向同一个提交。 而如果我们运行 <code>git checkout master</code> 的话，<code>develop</code> 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 <code>master</code>。</p><p>所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但 <em>做法</em> 是非常不同的。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 则移动 HEAD 自身。</p><p><img src="/2023/11/22/git-commands-reset/image-20231124164518277.png" alt="image-20231124164518277"></p><h3 id="带路径"><a class="header-anchor" href="#带路径"></a>带路径</h3><p>运行 <code>checkout</code> 的另一种方式就是指定一个文件路径，这会像 <code>reset</code> 一样不会移动 HEAD。 它就像 <code>git reset [branch] file</code> 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 <code>git reset --hard [branch] file</code>（如果 <code>reset</code> 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。</p><p>此外，同 <code>git reset</code> 和 <code>git add</code> 一样，<code>checkout</code> 也接受一个 <code>--patch</code> 选项，允许你根据选择一块一块地恢复文件内容。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ-消费者之Push消费模式</title>
      <link href="/2023/11/15/rocketmq-push-consumer/"/>
      <url>/2023/11/15/rocketmq-push-consumer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>⚠️注意：<strong><code>rocketmq-spring-boot-starter</code></strong> 适用于 <strong>RocketMQ 4.x 客户端</strong>，主要面向依赖于 RocketMQ 4.x 的应用。</p></blockquote><h2 id="Pull与Push消费模式的对比"><a class="header-anchor" href="#Pull与Push消费模式的对比"></a>Pull与Push消费模式的对比</h2><p>在 RocketMQ 的内部实现原理中，其实现机制为 PULL 模式，而 PUSH 模式是一种伪推送，是对 PULL 模式的封装，PullCustomer每拉去一批消息后，提交到消费端的线程池（异步），然后马上向 Broker 拉取消息，即实现类似“推”的效果。</p><p>从 PULL 模式来看，消息的消费主要包含如下几个方面：</p><ul><li>消息拉取，消息拉取模式通过 PULL 相关的 API 从 Broker 指定消息消费队列中拉取一批消息到消费消费客户端，多个消费者需要手动完成队列的分配。</li><li>消息消费端处理完消费，需要向 Broker 端报告消息处理队列，然后继续拉取下一批消息。</li><li>如果遇到消息消费失败，需要告知 Broker，该条消息消费失败，后续需要重试，通过手动调用 sendMessageBack 方法实现。</li></ul><p>而 PUSH 模式就上述这些处理操作无需使用者考虑，只需告诉 RocketMQ 消费者在拉取消息后需要调用的事件监听器即可，消息消费进度的存储、消息消费的重试统一由 RocketMQ Client 来实现。</p><h3 id="Pull消费者API"><a class="header-anchor" href="#Pull消费者API"></a>Pull消费者API</h3><p>Pull消费者的实现对象为：org.apache.rocketmq.client.consumer.DefaultLitePullConsumer</p><p>启动消费者方法：DefaultLitePullConsumer#start() -&gt; DefaultLitePullConsumerImpl#start()</p><p>消费消息的方式：手动调用 DefaultLitePullConsumer#poll()</p><h3 id="Push消费者API"><a class="header-anchor" href="#Push消费者API"></a>Push消费者API</h3><p>Push消费者的实现对象为：org.apache.rocketmq.client.consumer.DefaultMQPushConsumer</p><p>核心参数（在实例化对象后必须手动赋值的参数）：MessageListener messageListener</p><p>启动消费者方法：DefaultMQPushConsumer#start() -&gt; DefaultMQPushConsumerImpl#start()</p><blockquote><p>在启动消费者时，会调用<code>checkConfig</code>方法检查对象属性配置，其中需要检查messageListener是否不为空，并且是否继承于MessageListenerOrderly或MessageListenerConcurrently。</p></blockquote><p>消费消息的方式：在启动消费者后，消费者内部通过定时调度自动拉取消息并触发消费动作，消费动作会回调到messageListener对象。</p><h2 id="DefaultMQPushConsumer消费原理"><a class="header-anchor" href="#DefaultMQPushConsumer消费原理"></a>DefaultMQPushConsumer消费原理</h2><p><code>DefaultMQPushConsumer</code>消费消息的动作是从启动开始的，因此从<code>start</code>方法开始研究。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115163809893.png" alt="image-20231115163809893"></p><p><code>traceDispatcher</code>是一个异步传输数据接口，默认情况下为null，属于扩展功能。目前主要关注<code>defaultMQPushConsumerImpl.start()</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   <span class="comment">// 根据服务状态决定启动动作</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="comment">// 服务的初始状态</span></span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            log.info(<span class="string">&quot;the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;&quot;</span>, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                <span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="built_in">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">        <span class="comment">// 一开始先将服务状态设置为启动失败。。。（个人感觉有点画蛇添足，因为start方法本身已经是synchronized方法，同时switch case判断的其他状态目前都是直接抛异常，这里提前设置为启动失败可能只是担心在启动过程中发生异常而被忽略，防止服务再次被启动而出现未知的异常）</span></span><br><span class="line">            <span class="built_in">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查对象配置</span></span><br><span class="line">            <span class="built_in">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝订阅关系</span></span><br><span class="line">            <span class="built_in">this</span>.copySubscription();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当消息模型为集群模式时，如果消费者的实例名称为默认值，则修改为&lt;ip#系统纳秒时间&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并创建MQ客户端实例</span></span><br><span class="line">        <span class="comment">// MQ客户端实例中会包含非常多关键的元素，例如mQClientAPIImpl、mQAdminImpl、pullMessageService、rebalanceService、defaultMQProducer等</span></span><br><span class="line">            <span class="built_in">this</span>.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(<span class="built_in">this</span>.defaultMQPushConsumer, <span class="built_in">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为负载均衡服务设置属性</span></span><br><span class="line">            <span class="built_in">this</span>.rebalanceImpl.setConsumerGroup(<span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="built_in">this</span>.rebalanceImpl.setMessageModel(<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">            <span class="built_in">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="built_in">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">            <span class="built_in">this</span>.rebalanceImpl.setmQClientFactory(<span class="built_in">this</span>.mQClientFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置PullAPIWrapper，该对象主要就是用于拉取消息，是与MQ API客户端的包装器</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.pullAPIWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.pullAPIWrapper = <span class="keyword">new</span> <span class="title class_">PullAPIWrapper</span>(</span><br><span class="line">                    mQClientFactory,</span><br><span class="line">                    <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息进度存储管理器</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.offsetStore = <span class="built_in">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                        <span class="built_in">this</span>.offsetStore = <span class="keyword">new</span> <span class="title class_">LocalFileOffsetStore</span>(<span class="built_in">this</span>.mQClientFactory, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                        <span class="built_in">this</span>.offsetStore = <span class="keyword">new</span> <span class="title class_">RemoteBrokerOffsetStore</span>(<span class="built_in">this</span>.mQClientFactory, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="built_in">this</span>.offsetStore);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.offsetStore.load();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据消息监听器的类型，初始化消费消息服务</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                <span class="built_in">this</span>.consumeOrderly = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConsumeMessageOrderlyService</span>(<span class="built_in">this</span>, (MessageListenerOrderly) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">this</span>.consumeMessagePopService = <span class="keyword">new</span> <span class="title class_">ConsumeMessagePopOrderlyService</span>(<span class="built_in">this</span>, (MessageListenerOrderly) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                <span class="built_in">this</span>.consumeOrderly = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConsumeMessageConcurrentlyService</span>(<span class="built_in">this</span>, (MessageListenerConcurrently) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">this</span>.consumeMessagePopService =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConsumeMessagePopConcurrentlyService</span>(<span class="built_in">this</span>, (MessageListenerConcurrently) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费消息服务，不同服务类型，启动后的逻辑不一样</span></span><br><span class="line">            <span class="built_in">this</span>.consumeMessageService.start();</span><br><span class="line">            <span class="built_in">this</span>.consumeMessagePopService.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前消费者注册到当前客户端实例的消费者分组缓存中，表示一个客户端下一个消费者分组只能有一个消费者</span></span><br><span class="line">        <span class="comment">// 证明了官方的一句话，建议一个客户端只启动同一个消费者消费消息</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">registerOK</span> <span class="operator">=</span> mQClientFactory.registerConsumer(<span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="built_in">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="built_in">this</span>.consumeMessageService.shutdown(defaultMQPushConsumer.getAwaitTerminationMillisWhenShutdown());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The consumer group[&quot;</span> + <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                    + <span class="string">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端实例启动，启动过程会启动mQClientAPIImpl、pullMessageService、rebalanceService、defaultMQProducer，以及启动一系列的定时任务（更新nameserver地址、更新topic路由信息等等）</span></span><br><span class="line">            mQClientFactory.start();</span><br><span class="line">            log.info(<span class="string">&quot;the consumer [&#123;&#125;] start OK.&quot;</span>, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="built_in">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The PushConsumer service state not OK, maybe started once, &quot;</span></span><br><span class="line">                + <span class="built_in">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新topic订阅信息</span></span><br><span class="line">    <span class="built_in">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个start启动过程中，涉及到Push消费消息的过程是<code>mQClientFactory.start()</code>，细看其方法实现。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115172204720.png" alt="image-20231115172204720"></p><p>这其中<code>this.pullMessageService.start()</code>就是消费消息的关键，<code>PullMessageService</code>继承于<code>ServiceThread</code>。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115173511872.png" alt="image-20231115173511872"></p><p><code>ServiceThread#start</code>方法实例化了一个Thread，并将当前对象作为Runnable参数，线程调用当前对象的run方法。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115173521034.png" alt="image-20231115173521034"></p><p><code>PullMessageService#run</code>是一个while循环方法，通过判断内部参数<code>stopped</code>终止循环。循环方法主要分两步：</p><ol><li><code>this.messageRequestQueue.take()</code>是一个<code>LinkedBlockingQueue</code>对象，通过阻塞等待方式等待消息请求。</li><li>通过队列拿到消息请求对象后，调用拉取消息方法，默认调用<code>this.pullMessage((PullRequest)messageRequest)</code>。</li></ol><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115173933395.png" alt="image-20231115173933395"></p><p>通过消费者分组名称获取消费者对象，调用消费者对象的<code>pullMessage</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessQueue</span> <span class="variable">processQueue</span> <span class="operator">=</span> pullRequest.getProcessQueue();</span><br><span class="line">    <span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;the pull request[&#123;&#125;] is dropped.&quot;</span>, pullRequest.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.makeSureStateOK();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;pullMessage exception, consumer state not ok&quot;</span>, e);</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isPause()) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;&quot;</span>, <span class="built_in">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">cachedMessageCount</span> <span class="operator">=</span> processQueue.getMsgCount().get();</span><br><span class="line">    <span class="type">long</span> <span class="variable">cachedMessageSizeInMiB</span> <span class="operator">=</span> processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cachedMessageCount &gt; <span class="built_in">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">        <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(</span><br><span class="line">                <span class="string">&quot;the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="built_in">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="built_in">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">        <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(</span><br><span class="line">                <span class="string">&quot;the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="built_in">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.consumeOrderly) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="built_in">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">            <span class="keyword">if</span> ((queueMaxSpanFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                log.warn(</span><br><span class="line">                    <span class="string">&quot;the queue&#x27;s messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">                    processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span><br><span class="line">                    pullRequest, queueMaxSpanFlowControlTimes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (processQueue.isLocked()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pullRequest.isPreviouslyLocked()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    offset = <span class="built_in">this</span>.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue());</span><br><span class="line">                    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.SYSTEM_ERROR, <span class="string">&quot;Unexpected offset &quot;</span> + offset);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">                    log.error(<span class="string">&quot;Failed to compute pull offset, pullResult: &#123;&#125;&quot;</span>, pullRequest, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">brokerBusy</span> <span class="operator">=</span> offset &lt; pullRequest.getNextOffset();</span><br><span class="line">                log.info(<span class="string">&quot;the first time to pull message, so fix offset from broker. pullRequest: &#123;&#125; NewOffset: &#123;&#125; brokerBusy: &#123;&#125;&quot;</span>,</span><br><span class="line">                    pullRequest, offset, brokerBusy);</span><br><span class="line">                <span class="keyword">if</span> (brokerBusy) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: &#123;&#125; NewOffset: &#123;&#125;&quot;</span>,</span><br><span class="line">                        pullRequest, offset);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pullRequest.setPreviouslyLocked(<span class="literal">true</span>);</span><br><span class="line">                pullRequest.setNextOffset(offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">            log.info(<span class="string">&quot;pull message later because not locked in broker, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SubscriptionData</span> <span class="variable">subscriptionData</span> <span class="operator">=</span> <span class="built_in">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == subscriptionData) &#123;</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">        log.warn(<span class="string">&quot;find the consumer&#x27;s subscription failed, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">beginTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">PullCallback</span> <span class="variable">pullCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PullCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(PullResult pullResult)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pullResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                pullResult = DefaultMQPushConsumerImpl.<span class="built_in">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                    subscriptionData);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> FOUND:</span><br><span class="line">                        <span class="type">long</span> <span class="variable">prevRequestOffset</span> <span class="operator">=</span> pullRequest.getNextOffset();</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                        <span class="type">long</span> <span class="variable">pullRT</span> <span class="operator">=</span> System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="built_in">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                            pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">                        <span class="type">long</span> <span class="variable">firstMsgOffset</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="literal">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="built_in">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line"></span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">dispatchToConsume</span> <span class="operator">=</span> processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="built_in">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                                pullResult.getMsgFoundList(),</span><br><span class="line">                                processQueue,</span><br><span class="line">                                pullRequest.getMessageQueue(),</span><br><span class="line">                                dispatchToConsume);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="built_in">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="built_in">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                            || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">                            log.warn(</span><br><span class="line">                                <span class="string">&quot;[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;&quot;</span>,</span><br><span class="line">                                pullResult.getNextBeginOffset(),</span><br><span class="line">                                firstMsgOffset,</span><br><span class="line">                                prevRequestOffset);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                    <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="built_in">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                        log.warn(<span class="string">&quot;the pull request offset illegal, &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                            pullRequest.toString(), pullResult.toString());</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        pullRequest.getProcessQueue().setDropped(<span class="literal">true</span>);</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executeTaskLater(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="built_in">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span><br><span class="line">                                        pullRequest.getNextOffset(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="built_in">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="built_in">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                                    log.warn(<span class="string">&quot;fix the pull request offset, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                    log.error(<span class="string">&quot;executeTaskLater Exception&quot;</span>, e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, <span class="number">10000</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;execute the pull request exception&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">commitOffsetEnable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">commitOffsetValue</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING == <span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        commitOffsetValue = <span class="built_in">this</span>.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">        <span class="keyword">if</span> (commitOffsetValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            commitOffsetEnable = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">subExpression</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">classFilter</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">SubscriptionData</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="built_in">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) &#123;</span><br><span class="line">            subExpression = sd.getSubString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        classFilter = sd.isClassFilterMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sysFlag</span> <span class="operator">=</span> PullSysFlag.buildSysFlag(</span><br><span class="line">        commitOffsetEnable, <span class="comment">// commitOffset</span></span><br><span class="line">        <span class="literal">true</span>, <span class="comment">// suspend</span></span><br><span class="line">        subExpression != <span class="literal">null</span>, <span class="comment">// subscription</span></span><br><span class="line">        classFilter <span class="comment">// class filter</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">            pullRequest.getMessageQueue(),</span><br><span class="line">            subExpression,</span><br><span class="line">            subscriptionData.getExpressionType(),</span><br><span class="line">            subscriptionData.getSubVersion(),</span><br><span class="line">            pullRequest.getNextOffset(),</span><br><span class="line">            <span class="built_in">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">            <span class="built_in">this</span>.defaultMQPushConsumer.getPullBatchSizeInBytes(),</span><br><span class="line">            sysFlag,</span><br><span class="line">            commitOffsetValue,</span><br><span class="line">            BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">            CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">            CommunicationMode.ASYNC,</span><br><span class="line">            pullCallback</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;pullKernelImpl exception&quot;</span>, e);</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是定义了一个内部匿名类<code>PullCallback</code>，再调用<code>this.pullAPIWrapper.pullKernelImpl</code>远程拉取消息，并回调到<code>PullCallback</code>的<code>onSuccess</code>或<code>onException</code>方法，正常情况下进入<code>onSuccess</code>方法。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115175115721.png" alt="image-20231115175115721"></p><p>当<code>PullResult</code>为FOUND时，表示拉取到消息，调用<code>DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest</code>方法。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115175205124.png" alt="image-20231115175205124"></p><p><code>this.consumeMessageService</code>是根据消息监听器（MessageListener）的类型而来，当类型为<code>MessageListenerOrderly</code>时，进入<code>ConsumeMessageOrderlyService</code>的<code>submitConsumeRequest</code>方法。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115175226760.png" alt="image-20231115175226760"></p><p><code>this.consumeExecutor</code>是一个线程池对象，因此主要看<code>ConsumeRequest</code>对象的<code>run</code>方法。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115175328249.png" alt="image-20231115175328249"></p><p><code>run</code>方法主要实现消息监听回调的代码如下：</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231115175609836.png" alt="image-20231115175609836"></p><p>其中<code>messageListener.consumeMessage(Collections.unmodifiableList(msgs), context)</code>就是回调消息监听器方法。</p><h2 id="RocketMQMessageListener实现原理"><a class="header-anchor" href="#RocketMQMessageListener实现原理"></a>@RocketMQMessageListener实现原理</h2><p><code>DefaultMQPushConsumer</code>是RocketMQ核心库实现Push消费者的类，而<code>RocketMQMessageListener</code>是<code>rocketmq-spring-boot</code>包下的内容，也就是说它是基于SpringBoot实现的。</p><p>通过<code>RocketMQAutoConfiguration</code>找到<code>RocketMQListenerConfiguration</code>类。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231116141137907.png" alt="image-20231116141137907"></p><p>其注册了一个Bean，beanClass为<code>RocketMQMessageListenerBeanPostProcessor</code>，它实现了<code>BeanPostProcessor</code>接口。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231116141313564.png" alt="image-20231116141313564"></p><p>因此就看<code>postProcessAfterInitialization</code>方法，在Bean初始化后，<code>RocketMQMessageListenerBeanPostProcessor</code>判断每个Bean是否含有<code>RocketMQMessageListener</code>注解，对含有注解的类，做两步操作：</p><ol><li><code>enhance</code>增强注解的属性。</li><li>将该Bean注册到<code>ListenerContainerConfiguration</code>容器中。</li></ol><p>默认情况下，rocketmq-spring-boot没有实现<code>AnnotationEnhancer</code>接口用于<code>enhance</code>方法，所以主要看第二步<code>listenerContainerConfiguration.registerContainer(beanName, bean, enhance)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerContainer</span><span class="params">(String beanName, Object bean, RocketMQMessageListener annotation)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取bean的目标class</span></span><br><span class="line">    Class&lt;?&gt; clazz = AopProxyUtils.ultimateTargetClass(bean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断beanClass是否即继承于RocketMQListener，又继承于RocketMQReplyListener</span></span><br><span class="line">    <span class="keyword">if</span> (RocketMQListener.class.isAssignableFrom(bean.getClass()) &amp;&amp; RocketMQReplyListener.class.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(clazz + <span class="string">&quot; cannot be both instance of &quot;</span> + RocketMQListener.class.getName() + <span class="string">&quot; and &quot;</span> + RocketMQReplyListener.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断beanClass是否继承于RocketMQListener或RocketMQReplyListener</span></span><br><span class="line">    <span class="keyword">if</span> (!RocketMQListener.class.isAssignableFrom(bean.getClass()) &amp;&amp; !RocketMQReplyListener.class.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(clazz + <span class="string">&quot; is not instance of &quot;</span> + RocketMQListener.class.getName() + <span class="string">&quot; or &quot;</span> + RocketMQReplyListener.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从注解获取consumerGroup、topic值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">consumerGroup</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolvePlaceholders(annotation.consumerGroup());</span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolvePlaceholders(annotation.topic());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前监听器是否在指定consumerGroup和topic下开启监听，默认开启</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">listenerEnabled</span> <span class="operator">=</span></span><br><span class="line">        (<span class="type">boolean</span>) rocketMQProperties.getConsumer().getListeners().getOrDefault(consumerGroup, Collections.EMPTY_MAP)</span><br><span class="line">            .getOrDefault(topic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未开启的话，日志打印提示</span></span><br><span class="line">    <span class="keyword">if</span> (!listenerEnabled) &#123;</span><br><span class="line">        log.debug(</span><br><span class="line">            <span class="string">&quot;Consumer Listener (group:&#123;&#125;,topic:&#123;&#125;) is not enabled by configuration, will ignore initialization.&quot;</span>,</span><br><span class="line">            consumerGroup, topic);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验方法，如果注解标识的消息模型是广播模式并且消费模式是有序消费，则抛异常提示</span></span><br><span class="line">    validate(annotation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 DefaultRocketMQListenerContainer 的beanName</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">containerBeanName</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s_%s&quot;</span>, DefaultRocketMQListenerContainer.class.getName(),</span><br><span class="line">        counter.incrementAndGet());</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> (GenericApplicationContext) applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向spring容器注册BeanDefinition，BeanClass为DefaultRocketMQListenerContainer，bean对象来源于 createRocketMQListenerContainer 方法</span></span><br><span class="line">    genericApplicationContext.registerBean(containerBeanName, DefaultRocketMQListenerContainer.class,</span><br><span class="line">        () -&gt; createRocketMQListenerContainer(containerBeanName, bean, annotation));</span><br><span class="line">    <span class="comment">// 使用getBean方法，触发当前指定 containerBeanName Bean的生命周期</span></span><br><span class="line">    <span class="type">DefaultRocketMQListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> genericApplicationContext.getBean(containerBeanName,</span><br><span class="line">        DefaultRocketMQListenerContainer.class);</span><br><span class="line">    <span class="comment">// 判断当前 DefaultRocketMQListenerContainer 的running状态是否启动，默认为false</span></span><br><span class="line">    <span class="keyword">if</span> (!container.isRunning()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动 DefaultRocketMQListenerContainer</span></span><br><span class="line">            container.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Started container failed. &#123;&#125;&quot;</span>, container, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志通知，某个 RocketMQMessageListener Bean成功注册了一个 DefaultRocketMQListenerContainer Bean到spring容器中</span></span><br><span class="line">    log.info(<span class="string">&quot;Register the listener to container, listenerBeanName:&#123;&#125;, containerBeanName:&#123;&#125;&quot;</span>, beanName, containerBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是做了两个操作：</p><ol><li>向spring容器注册了一个 DefaultRocketMQListenerContainer Bean，并触发Bean生命周期。</li><li>调用了 DefaultRocketMQListenerContainer#start() 方法启动。</li></ol><p>细看注册过程的<code>createRocketMQListenerContainer</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DefaultRocketMQListenerContainer <span class="title function_">createRocketMQListenerContainer</span><span class="params">(String name, Object bean,</span></span><br><span class="line"><span class="params">        RocketMQMessageListener annotation)</span> &#123;</span><br><span class="line">    <span class="type">DefaultRocketMQListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultRocketMQListenerContainer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将注解属性填充到container</span></span><br><span class="line">    container.setRocketMQMessageListener(annotation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值nameServer、accessChannel、topic、selectorExpression、consumerGroup、tlsEnable</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">nameServer</span> <span class="operator">=</span> environment.resolvePlaceholders(annotation.nameServer());</span><br><span class="line">    nameServer = StringUtils.hasLength(nameServer) ? nameServer : rocketMQProperties.getNameServer();</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessChannel</span> <span class="operator">=</span> environment.resolvePlaceholders(annotation.accessChannel());</span><br><span class="line">    container.setNameServer(nameServer);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(accessChannel)) &#123;</span><br><span class="line">        container.setAccessChannel(AccessChannel.valueOf(accessChannel));</span><br><span class="line">    &#125;</span><br><span class="line">    container.setTopic(environment.resolvePlaceholders(annotation.topic()));</span><br><span class="line">    <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> environment.resolvePlaceholders(annotation.selectorExpression());</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(tags)) &#123;</span><br><span class="line">        container.setSelectorExpression(tags);</span><br><span class="line">    &#125;</span><br><span class="line">    container.setConsumerGroup(environment.resolvePlaceholders(annotation.consumerGroup()));</span><br><span class="line">    container.setTlsEnable(environment.resolvePlaceholders(annotation.tlsEnable()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据beanClass类型，设置rocketMQListener或rocketMQReplyListener</span></span><br><span class="line">    <span class="keyword">if</span> (RocketMQListener.class.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        container.setRocketMQListener((RocketMQListener) bean);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (RocketMQReplyListener.class.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        container.setRocketMQReplyListener((RocketMQReplyListener) bean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置spring-messaging的MessageConverter</span></span><br><span class="line">    container.setMessageConverter(rocketMQMessageConverter.getMessageConverter());</span><br><span class="line">    <span class="comment">// container的beanName</span></span><br><span class="line">    container.setName(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置namespace</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> environment.resolvePlaceholders(annotation.namespace());</span><br><span class="line">    container.setNamespace(RocketMQUtil.getNamespace(namespace,</span><br><span class="line">        rocketMQProperties.getConsumer().getNamespace()));</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要是将<code>RocketMQMessageListener</code>注解上的属性赋值到<code>DefaultRocketMQListenerContainer</code>中，实例化一个<code>DefaultRocketMQListenerContainer</code>对象。</p><p>实例化完后，紧接着进行了一个<code>genericApplicationContext.getBean</code>操作，就是为了触发<code>DefaultRocketMQListenerContainer</code>Bean的生命周期方法。</p><p>先看<code>DefaultRocketMQListenerContainer</code>的结构：</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231116152202404.png" alt="image-20231116152202404"></p><p>在Bean的getBean生命周期中，会先后经过<code>ApplicationContextAware</code>和<code>InitializingBean</code>两个接口方法，即<code>setApplicationContext</code>和<code>afterPropertiesSet</code>方法。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231116152409223.png" alt="image-20231116152409223"></p><p>通过代码可以看出，<code>DefaultRocketMQListenerContainer</code>在<code>afterPropertiesSet</code>阶段做了三个操作：</p><ol><li>初始化<code>RocketMQPushConsumer</code>对象。</li><li>获取<code>RocketMQListener&lt;T&gt;</code>或<code>RocketMQReplyListener&lt;T, R&gt;</code>中范型T的对象类型。</li><li>获取<code>RocketMQListener&lt;T&gt;</code>或<code>RocketMQReplyListener&lt;T, R&gt;</code>的<code>onMessage</code>方法的<code>MethodParameter</code>对象。</li></ol><p>看一下<code>initRocketMQPushConsumer</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initRocketMQPushConsumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="keyword">if</span> (rocketMQListener == <span class="literal">null</span> &amp;&amp; rocketMQReplyListener == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Property &#x27;rocketMQListener&#x27; or &#x27;rocketMQReplyListener&#x27; is required&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.notNull(consumerGroup, <span class="string">&quot;Property &#x27;consumerGroup&#x27; is required&quot;</span>);</span><br><span class="line">    Assert.notNull(nameServer, <span class="string">&quot;Property &#x27;nameServer&#x27; is required&quot;</span>);</span><br><span class="line">    Assert.notNull(topic, <span class="string">&quot;Property &#x27;topic&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">RPCHook</span> <span class="variable">rpcHook</span> <span class="operator">=</span> RocketMQUtil.getRPCHookByAkSk(applicationContext.getEnvironment(),</span><br><span class="line">        <span class="built_in">this</span>.rocketMQMessageListener.accessKey(), <span class="built_in">this</span>.rocketMQMessageListener.secretKey());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">enableMsgTrace</span> <span class="operator">=</span> rocketMQMessageListener.enableMsgTrace();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(rpcHook)) &#123;</span><br><span class="line">        consumer = <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(consumerGroup, rpcHook, <span class="keyword">new</span> <span class="title class_">AllocateMessageQueueAveragely</span>(),</span><br><span class="line">            enableMsgTrace, <span class="built_in">this</span>.applicationContext.getEnvironment().</span><br><span class="line">            resolveRequiredPlaceholders(<span class="built_in">this</span>.rocketMQMessageListener.customizedTraceTopic()));</span><br><span class="line">        consumer.setVipChannelEnabled(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Access-key or secret-key not configure in &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        consumer = <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(consumerGroup, enableMsgTrace,</span><br><span class="line">            <span class="built_in">this</span>.applicationContext.getEnvironment().</span><br><span class="line">                resolveRequiredPlaceholders(<span class="built_in">this</span>.rocketMQMessageListener.customizedTraceTopic()));</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.setNamespace(namespace);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">customizedNameServer</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContext.getEnvironment().resolveRequiredPlaceholders(<span class="built_in">this</span>.rocketMQMessageListener.nameServer());</span><br><span class="line">    <span class="keyword">if</span> (customizedNameServer != <span class="literal">null</span>) &#123;</span><br><span class="line">        consumer.setNamesrvAddr(customizedNameServer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consumer.setNamesrvAddr(nameServer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (accessChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">        consumer.setAccessChannel(accessChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set the consumer core thread number and maximum thread number has the same value</span></span><br><span class="line">    consumer.setConsumeThreadMax(consumeThreadNumber);</span><br><span class="line">    consumer.setConsumeThreadMin(consumeThreadNumber);</span><br><span class="line">    consumer.setConsumeTimeout(consumeTimeout);</span><br><span class="line">    consumer.setMaxReconsumeTimes(maxReconsumeTimes);</span><br><span class="line">    consumer.setAwaitTerminationMillisWhenShutdown(awaitTerminationMillisWhenShutdown);</span><br><span class="line">    consumer.setInstanceName(instanceName);</span><br><span class="line">    <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">        <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            consumer.setMessageModel(org.apache.rocketmq.common.protocol.heartbeat.MessageModel.BROADCASTING);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            consumer.setMessageModel(org.apache.rocketmq.common.protocol.heartbeat.MessageModel.CLUSTERING);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Property &#x27;messageModel&#x27; was wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (selectorType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TAG:</span><br><span class="line">            consumer.subscribe(topic, selectorExpression);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SQL92:</span><br><span class="line">            consumer.subscribe(topic, MessageSelector.bySql(selectorExpression));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Property &#x27;selectorType&#x27; was wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (consumeMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> ORDERLY:</span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">DefaultMessageListenerOrderly</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CONCURRENTLY:</span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">DefaultMessageListenerConcurrently</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Property &#x27;consumeMode&#x27; was wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if String is not is equal &quot;true&quot; TLS mode will represent the as default value false</span></span><br><span class="line">    consumer.setUseTLS(<span class="keyword">new</span> <span class="title class_">Boolean</span>(tlsEnable));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rocketMQListener <span class="keyword">instanceof</span> RocketMQPushConsumerLifecycleListener) &#123;</span><br><span class="line">        ((RocketMQPushConsumerLifecycleListener) rocketMQListener).prepareStart(consumer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rocketMQReplyListener <span class="keyword">instanceof</span> RocketMQPushConsumerLifecycleListener) &#123;</span><br><span class="line">        ((RocketMQPushConsumerLifecycleListener) rocketMQReplyListener).prepareStart(consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initRocketMQPushConsumer</code>方法主要就是实例化了一个<code>DefaultMQPushConsumer</code>对象存储到<code>DefaultRocketMQListenerContainer</code>对象中。</p><p>实例化过程中，设置了一大堆属性，包括设置了消费者的消息模型（messageModel）、订阅关系（<code>consumer.subscribe</code>）、消息监听器（<code>consumer.setMessageListener</code>）。</p><p>在设置消息监听器中，使用的是内部实现的默认消息监听器。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231116154921998.png" alt="image-20231116154921998"></p><p>两者默认实现逻辑差不多，只是入参和出参的类型有些差异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultMessageListenerConcurrently</span> <span class="keyword">implements</span> <span class="title class_">MessageListenerConcurrently</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt messageExt : msgs) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;received msg: &#123;&#125;&quot;</span>, messageExt);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                handleMessage(messageExt);</span><br><span class="line">                <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> System.currentTimeMillis() - now;</span><br><span class="line">                log.debug(<span class="string">&quot;consume &#123;&#125; cost: &#123;&#125; ms&quot;</span>, messageExt.getMsgId(), costTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;consume message failed. messageId:&#123;&#125;, topic:&#123;&#125;, reconsumeTimes:&#123;&#125;&quot;</span>, messageExt.getMsgId(), messageExt.getTopic(), messageExt.getReconsumeTimes(), e);</span><br><span class="line">                context.setDelayLevelWhenNextConsume(delayLevelWhenNextConsume);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultMessageListenerOrderly</span> <span class="keyword">implements</span> <span class="title class_">MessageListenerOrderly</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt messageExt : msgs) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;received msg: &#123;&#125;&quot;</span>, messageExt);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                handleMessage(messageExt);</span><br><span class="line">                <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> System.currentTimeMillis() - now;</span><br><span class="line">                log.debug(<span class="string">&quot;consume &#123;&#125; cost: &#123;&#125; ms&quot;</span>, messageExt.getMsgId(), costTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;consume message failed. messageId:&#123;&#125;, topic:&#123;&#125;, reconsumeTimes:&#123;&#125;&quot;</span>, messageExt.getMsgId(), messageExt.getTopic(), messageExt.getReconsumeTimes(), e);</span><br><span class="line">                context.setSuspendCurrentQueueTimeMillis(suspendCurrentQueueTimeMillis);</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者都是<code>DefaultRocketMQListenerContainer</code>类的内部类，在处理消息上，都是调用内部的<code>handleMessage</code>方法。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231116155549954.png" alt="image-20231116155549954"></p><p>在处理消息时，通过判断<code>RocketMQMessageListener</code>注解标记类实现的接口类是<code>RocketMQListener</code>还是<code>RocketMQReplyListener</code>，决定消息消费的逻辑，当实现接口为<code>RocketMQReplyListener</code>时，表示可回复的消息。</p><p><code>RocketMQReplyListener#onMessage</code>方法返回的&lt;R&gt;会作为一条消息，通过消费者对应的生产者发送，消息的目标topic由原始消息决定，实现细节在<code>MessageUtil.createReplyMessage(messageExt, convertToBytes(message))</code>方法下。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231116160858499.png" alt="image-20231116160858499"></p><p>回过头，再看消息监听器的<code>consumeMessage</code>方法在何时被调用，通过IDE的调用链可知，是由<code>ConsumeMessageService</code>的<code>consumeMessageDirectly</code>方法所触发。</p><p>而在分析<code>DefaultMQPushConsumer</code>消费原理时，在<code>defaultMQPushConsumerImpl.start()</code>阶段，消费者会根据消息监听器（messageListener）的类型决定实例化具体的<code>ConsumeMessageService</code>。</p><p><img src="/2023/11/15/rocketmq-push-consumer/image-20231116161318342.png" alt="image-20231116161318342"></p><p>而<code>MessageListener</code>的具体实现就是<code>DefaultRocketMQListenerContainer</code>里面的<code>DefaultMessageListenerConcurrently</code>和<code>DefaultMessageListenerOrderly</code>两个内部类。</p><p>至此，<code>RocketMQTransactionListener</code>与<code>DefaultMQPushConsumer</code>就关联起来了，两个关联的关键对象就是<code>DefaultRocketMQListenerContainer</code>。</p><p>需要记住，真正做到消费消息的是RocketMQ核心包中的<code>DefaultMQPushConsumer</code>消费者，而<code>RocketMQTransactionListener</code>是对其做的扩展，通过SpringBoot能力帮助开发者省略了手动创建消费者的过程，让开发者只需要关注想要消费的topic、消费模式以及处理业务消息的业务逻辑等。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ-消费者之消息消费</title>
      <link href="/2023/11/07/rocketmq-consumer/"/>
      <url>/2023/11/07/rocketmq-consumer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>同学习<a href="https://blog.itwray.com/2023/11/01/rocketmq-producer/">RocketMQ-生产者之消息发送</a>一样，为了更快速上手，所以直接从<a href="https://github.com/apache/rocketmq-spring/tree/master/rocketmq-spring-boot-samples">rocketmq-spring-boot-samples</a>示例开始。</p><p>⚠️注意：<strong><code>rocketmq-spring-boot-starter</code></strong> 适用于 <strong>RocketMQ 4.x 客户端</strong>，主要面向依赖于 RocketMQ 4.x 的应用。</p></blockquote><h2 id="rocketmq-consume-demo"><a class="header-anchor" href="#rocketmq-consume-demo"></a>rocketmq-consume-demo</h2><p>进入到 rocketmq-spring-boot-samples 项目中，会发现如下模块：</p><p><img src="/2023/11/07/rocketmq-consumer/image-20231101103949080.png" alt="image-20231101103949080"></p><p>与生产者一样，消费者的demo也分为了普通demo和acl-demo两种，recketmq-consume-demo的项目结构如下：</p><p><img src="/2023/11/07/rocketmq-consumer/image-20231108173034800.png" alt="image-20231108173034800"></p><p><code>ConsumerApplication</code>是一个SpringBootApplication，主要是注入了<code>RocketMQTemplate</code>对象，使用其消费消息。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;extRocketMQTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate extRocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//This is an example of pull consumer using rocketMQTemplate.</span></span><br><span class="line">        List&lt;String&gt; messages = rocketMQTemplate.receive(String.class);</span><br><span class="line">        System.out.printf(<span class="string">&quot;receive from rocketMQTemplate, messages=%s %n&quot;</span>, messages);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//This is an example of pull consumer using extRocketMQTemplate.</span></span><br><span class="line">        messages = extRocketMQTemplate.receive(String.class);</span><br><span class="line">        System.out.printf(<span class="string">&quot;receive from extRocketMQTemplate, messages=%s %n&quot;</span>, messages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>run</code>方法可以看到<code>rocketMQTemplate.receive</code>就是消费者消费消息的实现方法，关键对象就是<code>RocketMQTemplate</code>，与生产者示例一样，它是通过spring依赖注入进来的，并且两者是同一个<code>RocketMQTemplate</code>对象。</p><p><code>RocketMQTemplate</code>对象注册于<code>RocketMQAutoConfiguration</code>。具体细节可回看：<a href="https://blog.itwray.com/2023/11/01/rocketmq-producer/">RocketMQ-生产者之消息发送</a></p><h2 id="消费者消费消息原理"><a class="header-anchor" href="#消费者消费消息原理"></a>消费者消费消息原理</h2><p>跟踪进入到<code>rocketMQTemplate#receive</code>方法中。</p><p><img src="/2023/11/07/rocketmq-consumer/image-20231114142146956.png" alt="image-20231114142146956"></p><p><code>receive</code>方法主要接收两个参数，class是消息对象类型，timeout表示接收消息的超时时间（默认毫秒）。消息对象类型比较好解释，就是这个消息的对象。而接收消息的超时时间是指等待消息的时间，当消息队列有消息时是不需要进行等待的，这里的等待超时时间是指当消息队列没有消息时，RocketMQ默认采用乐观消费思想，认为在等待指定时间内会有消息生产出来。</p><p>消费消息主要是<code>consumer.poll</code>方法实现，返回的消息对象是<code>MessageExt</code>，由<code>RocketMQTemplate</code>将其转换为指定的消息对象类型clazz。转换方法（<code>doConvertMessage</code>）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> &lt;T&gt; T <span class="title function_">doConvertMessage</span><span class="params">(MessageExt messageExt, Class&lt;T&gt; messageType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(messageType, MessageExt.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) messageExt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody(), Charset.forName(charset));</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(messageType, String.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) str;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If msgType not string, use objectMapper change it.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) <span class="built_in">this</span>.getMessageConverter().fromMessage(MessageBuilder.withPayload(str).build(), messageType);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;convert failed. str:&#123;&#125;, msgType:&#123;&#125;&quot;</span>, str, messageType);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot convert message to &quot;</span> + messageType, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>messageExt.getBody()</code>返回的是消息的字节数组，转换成指定对象类型时，都是先将其转为字符串，再通过spring-messaging的<code>MessageConverter</code>做对象转换。</p><p>再看<code>consumer.poll</code>的具体实现，<code>consumer</code>的默认对象为<code>DefaultLitePullConsumer</code>。</p><p><img src="/2023/11/07/rocketmq-consumer/image-20231114144317897.png" alt="image-20231114144317897"></p><p>与生产者发送消息的逻辑一样，最终消费消息的实现都是由实现类<code>DefaultLitePullConsumerImpl</code>实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;MessageExt&gt; <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkServiceState();</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Timeout must not be negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (defaultLitePullConsumer.isAutoCommit()) &#123;</span><br><span class="line">            maybeAutoCommit();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 拉取消息的结束时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis() + timeout;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里利用了BlockingQueue的获取队列元素的特性</span></span><br><span class="line">      <span class="comment">// 从队列中获取消息，如果队列消息为空，则队列等待指定时间后再返回</span></span><br><span class="line">        <span class="type">ConsumeRequest</span> <span class="variable">consumeRequest</span> <span class="operator">=</span> consumeRequestCache.poll(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前时间戳小于结束时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (endTime - System.currentTimeMillis() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果从队列获取的消息不为空，并且消息是废弃的，则重新从队列中获取</span></span><br><span class="line">            <span class="keyword">while</span> (consumeRequest != <span class="literal">null</span> &amp;&amp; consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">                consumeRequest = consumeRequestCache.poll(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (endTime - System.currentTimeMillis() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果从队列获取的消息不为空, 并且消息不是废弃的</span></span><br><span class="line">        <span class="keyword">if</span> (consumeRequest != <span class="literal">null</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">            List&lt;MessageExt&gt; messages = consumeRequest.getMessageExts();</span><br><span class="line">          <span class="comment">// 从消息队列的msgTreeMap移除这些消息，并返回消息偏移量最靠前的元素</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> consumeRequest.getProcessQueue().removeMessage(messages);</span><br><span class="line">          <span class="comment">// 更新消息队列的消费偏移量</span></span><br><span class="line">            assignedMessageQueue.updateConsumeOffset(consumeRequest.getMessageQueue(), offset);</span><br><span class="line">            <span class="comment">// If namespace not null , reset Topic without namespace.</span></span><br><span class="line">            <span class="built_in">this</span>.resetTopic(messages);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 消费消息的Hook</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.consumeMessageHookList.isEmpty()) &#123;</span><br><span class="line">                <span class="type">ConsumeMessageContext</span> <span class="variable">consumeMessageContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeMessageContext</span>();</span><br><span class="line">                consumeMessageContext.setNamespace(defaultLitePullConsumer.getNamespace());</span><br><span class="line">                consumeMessageContext.setConsumerGroup(<span class="built_in">this</span>.groupName());</span><br><span class="line">                consumeMessageContext.setMq(consumeRequest.getMessageQueue());</span><br><span class="line">                consumeMessageContext.setMsgList(messages);</span><br><span class="line">                consumeMessageContext.setSuccess(<span class="literal">false</span>);</span><br><span class="line">                <span class="built_in">this</span>.executeHookBefore(consumeMessageContext);</span><br><span class="line">              consumeMessageContext.setStatus(ConsumeConcurrentlyStatus.CONSUME_SUCCESS.toString());</span><br><span class="line">                consumeMessageContext.setSuccess(<span class="literal">true</span>);</span><br><span class="line">                <span class="built_in">this</span>.executeHookAfter(consumeMessageContext);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 设置消息队列最后消费的时间戳</span></span><br><span class="line">            consumeRequest.getProcessQueue().setLastConsumeTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> messages;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poll</code>方法是<code>synchronized</code>方法，其目的是为了保证同一时间一个消费者只会从消息缓存队列获取一次消息，避免消息的重复消费。这里面的关键在于<code>consumeRequestCache</code>缓存队列何时有消息进入队列。</p><p>因此就找<code>consumeRequestCache</code>对象何时插入元素，整个对象中只有一处调用了<code>consumeRequestCache.put(consumeRequest)</code>方法。</p><p><img src="/2023/11/07/rocketmq-consumer/image-20231114162527102.png" alt="image-20231114162527102"></p><p>而调用<code>submitConsumeRequest</code>方法的地方只有一处，即<code>DefaultLitePullConsumerImpl.PullTaskImpl#run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="type">PullResult</span> <span class="variable">pullResult</span> <span class="operator">=</span> pull(messageQueue, subscriptionData, offset, defaultLitePullConsumer.getPullBatchSize());</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.isCancelled() || processQueue.isDropped()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">    <span class="comment">// 表示发现消息</span></span><br><span class="line">    <span class="keyword">case</span> FOUND:</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objLock</span> <span class="operator">=</span> messageQueueLock.fetchLockObject(messageQueue);</span><br><span class="line">        <span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pullResult.getMsgFoundList() != <span class="literal">null</span> &amp;&amp; !pullResult.getMsgFoundList().isEmpty() &amp;&amp; assignedMessageQueue.getSeekOffset(messageQueue) == -<span class="number">1</span>) &#123;</span><br><span class="line">                processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">              <span class="comment">// 添加到消息缓存队列</span></span><br><span class="line">                submitConsumeRequest(<span class="keyword">new</span> <span class="title class_">ConsumeRequest</span>(pullResult.getMsgFoundList(), messageQueue, processQueue));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">        log.warn(<span class="string">&quot;The pull request offset illegal, &#123;&#125;&quot;</span>, pullResult.toString());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">updatePullOffset(messageQueue, pullResult.getNextBeginOffset(), processQueue);</span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure><p>该方法是由定时线程池触发的，在实例化<code>DefaultLitePullConsumerImpl.PullTaskImpl</code>对象后，将其放入线程池定时执行<code>run</code>方法。（实例化该对象是由RocketMQ消费者负载均衡实现的）</p><p><img src="/2023/11/07/rocketmq-consumer/image-20231114163708337.png" alt="image-20231114163708337"></p><p>到此，消费者消费消息的原理基本就大致理清了。</p><p><strong>小结</strong>：</p><ol><li>通过<code>DefaultLitePullConsumer</code>手动触发<code>poll</code>方法消费消息。</li><li>通过<code>DefaultLitePullConsumerImpl</code>对象获取消息缓存队列（<code>consumeRequestCache</code>）的消息。</li><li>而消息缓存队列的数据来源于<code>DefaultLitePullConsumerImpl</code>内置的定时线程池，通过触发<code>DefaultLitePullConsumerImpl.PullTaskImpl</code>的<code>run</code>方法从RocketMQ消息队列拉取消息。</li></ol><h2 id="消费者核心参数"><a class="header-anchor" href="#消费者核心参数"></a>消费者核心参数</h2><p>实际上，RocketMQ消费者有两类，一种是Pull模式，一种是Push模式。而rocketmq-consume-demo中演示的是Pull模式，因此这里主要介绍<code>DefaultLitePullConsumer</code>消费者的核心参数。后期有机会再专门介绍<code>DefaultMQPushConsumer</code>。</p><h3 id="DefaultLitePullConsumer核心方法"><a class="header-anchor" href="#DefaultLitePullConsumer核心方法"></a>DefaultLitePullConsumer核心方法</h3><ul><li><p>void start()</p><p>启动消费者。</p></li><li><p>void shutdown()</p><p>关闭消费者。</p></li><li><p>void subscribe(String topic, String subExpression)</p><p>按照主题与消息过滤表达式进行订阅。</p></li><li><p>void subscribe(String topic, MessageSelector selector)</p><p>按照主题与过滤表达式订阅消息，过滤表达式可通过 MessageSelector 的 bySql、byTag 来创建，这个与 PUSH 模式类似，故不重复展开。</p><blockquote><p>温馨提示：通过 subscribe 方式订阅 Topic，具备消息消费队列的重平衡，即如果消费消费者数量、主题的队列数发生变化时，各个消费者订阅的队列信息会动态变化。</p></blockquote></li><li><p>void unsubscribe(String topic)</p><p>取消订阅。</p></li><li><p>void assign(Collection&lt; MessageQueue &gt; messageQueues)</p><p>收到指定该消费者消费的队列，这种消费模式不具备消息消费队列的自动重平衡。</p></li><li><p>List<MessageExt> poll()</MessageExt></p><p>消息拉取 API，默认超时时间为 5s。</p></li><li><p>List<MessageExt> poll(long timeout)</MessageExt></p><p>消息拉取 API，可指定消息拉取超时时间。</p></li><li><p>void seek(MessageQueue messageQueue, long offset)</p><p>改变下一次消息拉取的偏移量，即改变 poll() 方法下一次运行的拉取消息偏移量，类似于回溯或跳过消息，注意：如果设置的 offset 大于当前消费队列的消费偏移量，就会造成部分消息直接跳过没有消费，使用时请慎重。</p></li><li><p>void seekToBegin(MessageQueue messageQueue)</p><p>改变下一次消息拉取的偏移量到消息队列最小偏移量。其效果相当于重新来过一次。</p></li><li><p>void seekToEnd(MessageQueue messageQueue)</p><p>该变下一次消息拉取偏移量到队列的最大偏移量，即跳过当前所有的消息，从最新的偏移量开始消费。</p></li><li><p>void pause(Collection&lt; MessageQueue &gt; messageQueues)</p><p>暂停消费，支持将某些消息消费队列挂起，即 poll() 方法在下一次拉取消息时会暂时忽略这部分消息消费队列，可用于消费端的限流。</p></li><li><p>void resume(Collection&lt; MessageQueue &gt; messageQueues)</p><p>恢复消费。</p></li><li><p>boolean isAutoCommit()</p><p>是否自动提交消费位点，Lite Pull 模式下可设置是否自动提交位点。</p></li><li><p>void setAutoCommit(boolean autoCommit)</p><p>设置是否自动提交位点。</p></li><li><p>Collection<MessageQueue> fetchMessageQueues(String topic)</MessageQueue></p><p>获取 Topic 的路由信息。</p></li><li><p>Long offsetForTimestamp(MessageQueue messageQueue, Long timestamp)</p><p>根据时间戳查找最接近该时间戳的消息偏移量。</p></li><li><p>void commitSync()</p><p>手动提交消息消费位点，在集群消费模式下，调用该方法只是将消息偏移量提交到 OffsetStore 在内存中，并不是实时向 Broker 提交位点，位点的提交还是按照定时任务定时向 Broker 汇报。</p></li><li><p>Long committed(MessageQueue messageQueue)</p><p>获取该消息消费队列已提交的消费位点（从 OffsetStore 中获取，即集群模式下会向 Broker 中的消息消费进度文件中获取。</p></li><li><p>void registerTopicMessageQueueChangeListener(String topic,TopicMessageQueueChangeListener listener)</p><p>注册主题队列变化事件监听器，客户端会每 30s 查询一下 订阅的 Topic 的路由信息（队列信息）的变化情况，如果发生变化，会调用注册的事件监听器。</p></li><li><p>void updateNameServerAddress(String nameServerAddress)</p><p>更新 NameServer 的地址。</p></li></ul><h3 id="DefaultLitePullConsumer核心属性"><a class="header-anchor" href="#DefaultLitePullConsumer核心属性"></a>DefaultLitePullConsumer核心属性</h3><ul><li><p>String consumerGroup</p><p>消息消费组。</p></li><li><p>long brokerSuspendMaxTimeMillis = 1000 * 20</p><p>长轮询模式，如果开启长轮询模式，当 Broker 收到客户端的消息拉取请求时如果当时并没有新的消息，可以在 Broker 端挂起当前请求，一旦新消息到达则唤醒线程，从 Broker 端拉取消息后返回给客户端，该值设置在 Broker 等待的最大超时时间，默认为 20s，建议保持默认值即可。</p></li><li><p>long consumerTimeoutMillisWhenSuspend = 1000 * 30</p><p>消息消费者拉取消息最大的超时时间，该值必须大于 brokerSuspendMaxTimeMillis，默认值为 30s，同样不建议修改该值。</p></li><li><p>long consumerPullTimeoutMillis = 1000 * 10</p><p>客户端与 Broker 建立网络连接的最大超时时间，默认为 10s。</p></li><li><p>MessageModel messageModel = MessageModel.CLUSTERING</p><p>消息组消费模型，可选值：集群模式、广播模式。</p></li><li><p>MessageQueueListener messageQueueListener</p><p>消息消费负载队列变更事件。</p></li><li><p>OffsetStore offsetStore</p><p>消息进度存储管理器，该属性为私有属性，不能通过 API 进行修改，该参数主要是根据消费模式在内部自动创建，RocketMQ 在广播消息、集群消费两种模式下消息消费进度的存储策略会有所不同。</p><ul><li>集群模式：RocketMQ 会将消息消费进度存储在 Broker 服务器，存储路径为 <code>$&#123;ROCKET_HOME&#125;/store/config/ consumerOffset.json</code> 文件中。</li><li>广播模式：RocketMQ 会将消息消费进存在在消费端所在的机器上，存储路径为 <code>$&#123;user.home&#125;/.rocketmq_offsets</code> 中。</li></ul><p>为了方便大家对消息消费进度有一个直接的理解，下面给出我本地测试时 Broker 集群中的消息消费进度文件，其截图如下：</p><p><img src="/2023/11/07/rocketmq-consumer/20200814230847619.png" alt="1"></p><p>消息消费进度，首先使用 topic@consumerGroup 为键，其值是一个 Map，键为 Topic 的队列序列，值为当前的消息消费位点。</p></li><li><p>AllocateMessageQueueStrategy allocateMessageQueueStrategy = new AllocateMessageQueueAveragely()</p><p>消息队列负载算法。主要解决的问题是消息消费队列在各个消费者之间的负载均衡策略，例如一个 Topic 有８个队列，一个消费组中有３个消费者，那这三个消费者各自去消费哪些队列。</p><p>RocketMQ 默认提供了如下负载均衡算法：</p><ul><li>AllocateMessageQueueAveragely：平均连续分配算法。</li><li>AllocateMessageQueueAveragelyByCircle：平均轮流分配算法。</li><li>AllocateMachineRoomNearby：机房内优先就近分配。</li><li>AllocateMessageQueueByConfig：手动指定，这个通常需要配合配置中心，在消费者启动时，首先先创建 AllocateMessageQueueByConfig 对象，然后根据配置中心的配置，再根据当前的队列信息，进行分配，即该方法不具备队列的自动负载，在 Broker 端进行队列扩容时，无法自动感知，需要手动变更配置。</li><li>AllocateMessageQueueByMachineRoom：消费指定机房中的队列，该分配算法首先需要调用该策略的 <code>setConsumeridcs(Set&lt;String&gt; consumerIdCs)</code> 方法，用于设置需要消费的机房，将刷选出来的消息按平均连续分配算法进行队列负载。</li></ul></li><li><p>boolean autoCommit = true</p><p>设置是否提交消息消费进度，默认为 true。</p></li><li><p>int pullThreadNums = 20</p><p>消息拉取线程数量，默认为 20 个，注意这个是每一个消费者默认 20 个线程往 Broker 拉取消息。这个应该是 Lite PULL 模式对比 PUSH 模式一个非常大的优势。</p></li><li><p>long autoCommitIntervalMillis = 5 * 1000</p><p>自动汇报消息位点的间隔时间，默认为 5s。</p></li><li><p>int pullBatchSize = 10</p><p>一次消息拉取最多返回的消息条数，默认为 10。</p></li><li><p>long pullThresholdForAll = 10000</p><p>针对所有队列的消息消费请求数触发限流的阔值，默认为 10000。</p></li><li><p>int consumeMaxSpan = 2000</p><p>单个消息处理队列中最大消息偏移量与最小偏移量的差值触发限流的阔值，默认为 2000。</p></li><li><p>int pullThresholdForQueue = 1000</p><p>对于单个队列挤压的消息条数触发限流的阔值，默认为 1000，即如果某一个队列在本地挤压超过 1000 条消息，则停止消息拉取。</p></li><li><p>int pullThresholdSizeForQueue = 100</p><p>对于单个队列挤压的消息总大小触发限流的阔值，默认为 100M。</p></li><li><p>long pollTimeoutMillis = 1000 * 5</p><p>一次消息拉取默认的超时时间为 5s。</p></li><li><p>long topicMetadataCheckIntervalMillis = 30 * 1000</p><p>topic 路由信息更新频率，默认 30s 更新一次。</p></li><li><p>ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET</p><p>一个消费者初次启动时（即消费进度管理器中无法查询到该消费组的进度）时从哪个位置开始消费的策略，可选值如下所示：</p><ul><li>CONSUME_FROM_LAST_OFFSET：从最新的消息开始消费。</li></ul><ul><li>CONSUME_FROM_FIRST_OFFSET：从最新的位点开始消费。</li><li>CONSUME_FROM_TIMESTAMP：从指定的时间戳开始消费，这里的实现思路是从 Broker 服务器寻找消息的存储时间小于或等于指定时间戳中最大的消息偏移量的消息，从这条消息开始消费。</li></ul></li><li><p>String consumeTimestamp = UtilAll.timeMillisToHumanString3(System.currentTimeMillis() - (1000 * 60 * 30))</p><p>指定从什么时间戳开始消费，其格式为 yyyyMMddHHmmss，默认值为 30 分钟之前，该参数只在 consumeFromWhere 为 CONSUME_FROM_TIMESTAMP 时生效。</p></li></ul><h2 id="封装消费者工具"><a class="header-anchor" href="#封装消费者工具"></a>封装消费者工具</h2><p>主要是对Consumer的封装，实现自定义方法自动消费消息，类似于rocketmq-spring-boot提供的<code>RocketMQMessageListener</code>功能。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MQConsumerListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeListenerByPush</span><span class="params">(UserVo msg)</span> &#123;</span><br><span class="line">     System.out.printf(<span class="string">&quot;消费者监听[%s]: %s\n&quot;</span>, Thread.currentThread().getName(), msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@MQConsumerListener</code>注解结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MQConsumerListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">NAME_SERVER_PLACEHOLDER</span> <span class="operator">=</span> <span class="string">&quot;$&#123;rocketmq.name-server:&#125;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">TOPIC_PLACEHOLDER</span> <span class="operator">=</span> <span class="string">&quot;$&#123;rocketmq.consumer.topic:&#125;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">GROUP_PLACEHOLDER</span> <span class="operator">=</span> <span class="string">&quot;$&#123;rocketmq.consumer.group:&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者名称，即Bean名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费监听模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ConsumeListeningMode <span class="title function_">consumeListeningMode</span><span class="params">()</span> <span class="keyword">default</span> ConsumeListeningMode.PUSH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息监听规则</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;仅在 ConsumeListeningMode.PUSH 模式下生效&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MessageListeningRule <span class="title function_">messageListeningRule</span><span class="params">()</span> <span class="keyword">default</span> MessageListeningRule.ORDERLY;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">nameServer</span><span class="params">()</span> <span class="keyword">default</span> NAME_SERVER_PLACEHOLDER;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">topic</span><span class="params">()</span> <span class="keyword">default</span> TOPIC_PLACEHOLDER;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> GROUP_PLACEHOLDER;</span><br><span class="line"></span><br><span class="line">    MessageModel <span class="title function_">messageModel</span><span class="params">()</span> <span class="keyword">default</span> MessageModel.CLUSTERING;</span><br><span class="line"></span><br><span class="line">    SelectorType <span class="title function_">selectorType</span><span class="params">()</span> <span class="keyword">default</span> SelectorType.TAG;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">selectorExpression</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体源代码地址：<a href="https://github.com/wangfarui/java-study/blob/main/rocketmq-study/src/main/java/com/itwray/study/rocketmq/consumer/MQConsumerListener.java">rocketmq-consumer-demo</a></p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-命令大全</title>
      <link href="/2023/11/02/git-study-commands/"/>
      <url>/2023/11/02/git-study-commands/</url>
      
        <content type="html"><![CDATA[<h3 id="配置命令"><a class="header-anchor" href="#配置命令"></a>配置命令</h3><h4 id="git-config"><a class="header-anchor" href="#git-config"></a>git config</h4><p><code>git config</code>是 Git 自带的一个命令工具，用于帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有的配置以及它们所在的文件</span></span><br><span class="line">git config --list --show-origin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将user.name配置到~/.gitconfig下，值为wray</span></span><br><span class="line">git config --global user.name wray</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将user.name配置到当前路径下的项目config中，值为project-wray</span></span><br><span class="line">git config user.name project-wray</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查配置项的值</span></span><br><span class="line">git config user.name</span><br></pre></td></tr></table></figure><h4 id="git-help"><a class="header-anchor" href="#git-help"></a>git help</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法如下，&lt;verb&gt;表示命令动作，例如config、add、commit</span></span><br><span class="line">git help &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --help</span><br><span class="line">man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取config命令的使用说明</span></span><br><span class="line">git help config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取config命令的简明说明</span></span><br><span class="line">git config -h</span><br></pre></td></tr></table></figure><h4 id="gitignore"><a class="header-anchor" href="#gitignore"></a>.gitignore</h4><p>git仓库的忽略文件，一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（``）表示匹配任意中间目录，比如 <code>a//z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p><p>我们再看一个 <code>.gitignore</code> 文件的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的 .a 文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略任何目录下名为 build 的文件夹</span></span><br><span class="line">build/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><blockquote><p>在最简单的情况下，一个仓库可能只根目录下有一个 <code>.gitignore</code> 文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的 <code>.gitignore</code> 文件。子目录中的 <code>.gitignore</code> 文件中的规则只作用于它所在的目录中。 （Linux 内核的源码库拥有 206 个 <code>.gitignore</code> 文件。）</p><p>多个 <code>.gitignore</code> 文件的具体细节超出了本书的范围，更多详情见 <code>man gitignore</code> 。</p></blockquote><h3 id="本地命令"><a class="header-anchor" href="#本地命令"></a>本地命令</h3><p>本地命令表示在本地计算机可以执行的命令，不需要互联网。</p><h4 id="git-init"><a class="header-anchor" href="#git-init"></a>git init</h4><p>语法：<code>git init</code></p><p>含义：将当前目录初始化为Git仓库，执行完后会在目录下生成一个<code>.git</code>隐藏目录。</p><blockquote><p>如果在已有<code>.git</code>的目录下执行，会报错提示Git仓库已存在。</p></blockquote><h4 id="git-clone"><a class="header-anchor" href="#git-clone"></a>git clone</h4><p>语法：<code>git clone &lt;url&gt;</code></p><p>含义：克隆远程仓库到本地。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从github上克隆libgit2项目</span></span><br><span class="line">git clone https://github.com/libgit2/libgit2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从github上克隆libgit2项目，并将项目的目录名更改为mylibgit</span></span><br><span class="line">git clone https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure><h4 id="git-status"><a class="header-anchor" href="#git-status"></a>git status</h4><p>语法：<code>git status</code></p><p>含义：检查当前文件状态</p><p><img src="/2023/11/02/git-study-commands/image-20231030161518755.png" alt="image-20231030161518755"></p><p>图中的“nothing to commit, working tree clean”表示工作区很干净，所有已跟踪文件在上次提交后都未发生变更。</p><p><img src="/2023/11/02/git-study-commands/image-20231030161817320.png" alt="image-20231030161817320"></p><p>图中的“Changes to be committed”表示已跟踪的文件，已经存放到Git暂存区中。</p><p>图中的“Untracked files”表示未跟踪的文件，不会被提交的git仓库。</p><h4 id="git-add"><a class="header-anchor" href="#git-add"></a>git add</h4><p>语法：<code>git add &lt;files&gt;</code></p><p>含义：跟踪文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跟踪README文件，README文件会处于暂存状态</span></span><br><span class="line">git add README</span><br></pre></td></tr></table></figure><h4 id="git-commit"><a class="header-anchor" href="#git-commit"></a>git commit</h4><p>语法：git commit</p><p>含义：这样会启动你选择的文本编辑器来输入提交说明，文件:w保存后，git会将暂存区的文件提交到git仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定-m，将提交说明与命令放在同一行，不用进入文本编辑器</span></span><br><span class="line">git commit -m &#x27;init project&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定-a，将所有未暂存的文件一并提交，可以跳过git add添加暂存区的操作</span></span><br><span class="line">git commit -a -m &#x27;commit all un add file&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定--amend，修改上一次的提交内容</span></span><br><span class="line">git commit --amend -m &#x27;重新提交&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;initial commit&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add forgotten_file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><p>当你在修补最后的提交时，与其说是修复旧提交，倒不如说是完全用一个 <strong>新的提交</strong> 替换旧的提交， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。</p></blockquote><h4 id="git-rm"><a class="header-anchor" href="#git-rm"></a>git rm</h4><p>语法：<code>git rm &lt;file&gt;</code></p><p>含义：将文件从已跟踪文件列表中移除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从已跟踪文件列表中移除PROJECT.md</span></span><br><span class="line">git rm PROJECT.md</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从已跟踪文件列表中移除PROJECT.md，连带删除工作目录中的PROJECT.md文件</span></span><br><span class="line">git rm -f PROJECT.md</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从已跟踪文件列表中移除PROJECT.md，保留工作目录的文件</span></span><br><span class="line">git rm --cached PROJECT.md</span><br></pre></td></tr></table></figure><blockquote><p><code>git rm</code>支持<code>glob</code>模式，<code>git rm</code> 命令后面可以列出文件或者目录的名字。比如：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*.<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> \*~</span></span><br></pre></td></tr></table></figure><p>该命令会删除所有名字以 <code>~</code> 结尾的文件。</p></blockquote><h4 id="git-mv"><a class="header-anchor" href="#git-mv"></a>git mv</h4><p>语法：<code>git mv &lt;old_file&gt; &lt;new_file&gt;</code></p><p>含义：修改已跟踪文件的文件名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将README文件改为README.md</span></span><br><span class="line">git mv README README.md</span><br></pre></td></tr></table></figure><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure><h4 id="git-log"><a class="header-anchor" href="#git-log"></a>git log</h4><p>语法：<code>git log</code></p><p>含义：不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p>其中一个比较有用的选项是 <code>-p</code> 或 <code>--patch</code> ，它会显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交。</p><h4 id="git-reset-HEAD"><a class="header-anchor" href="#git-reset-HEAD"></a>git reset HEAD</h4><p>语法：<code>git reset HEAD &lt;file&gt;</code></p><p>含义：取消暂存的文件</p><h4 id="git-restore"><a class="header-anchor" href="#git-restore"></a>git restore</h4><p>语法：<code>git restore &lt;file&gt;</code></p><p>含义：撤销对文件的修改。</p><blockquote><p><code>git checkout — &lt;file&gt;</code>与git restore都可以做到同样的功能，不过现在已不建议使用。</p></blockquote><h4 id="git-remote"><a class="header-anchor" href="#git-remote"></a>git remote</h4><p>语法：<code>git remote</code></p><p>含义：查看已经配置的远程仓库服务器。</p><blockquote><p>远程仓库可以在你的本地主机上</p><p>你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程仓库服务器的简写，一般默认为origin</span></span><br><span class="line">git remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询远程仓库使用 Git 保存的简写与其对应的 URL</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为当前git仓库添加一个远程仓库</span></span><br><span class="line">git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">远程仓库重命名，将pb改为paul</span></span><br><span class="line">git remote rename pb paul</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程仓库</span></span><br><span class="line">git remote remove paul</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置指定远程仓库的仓库地址</span></span><br><span class="line">git remote set-url origin &lt;新的仓库地址&gt;</span><br></pre></td></tr></table></figure><h4 id="git-tag"><a class="header-anchor" href="#git-tag"></a>git tag</h4><p>语法：git tag</p><p>含义：在 Git 中列出已有的标签</p><p>Git标签分为轻量标签（lightweight）与附注标签（annotated）。一般使用附注标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定-a，创建附注标签。-a后面是标签号，-m是标签的说明</span></span><br><span class="line">git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在git tag后不加任何参数，指定输入标签名，表示创建轻量标签</span></span><br><span class="line">git tag v1.4-lw</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本打标签。9fceb02是提交历史的校验和的部分（前部分）</span></span><br><span class="line">git tag -a v1.2 9fceb02</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询标签信息</span></span><br><span class="line">git show v1.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送标签到远程origin仓库</span></span><br><span class="line">git push origin v1.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除标签</span></span><br><span class="line">git tag -d v1.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程仓库中的标签</span></span><br><span class="line">git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h4 id="git-branch"><a class="header-anchor" href="#git-branch"></a>git branch</h4><p>查看本地分支列表：<code>git branch</code></p><p>查看远程分支列表：<code>git remote show &lt;remote&gt;</code></p><blockquote><p>&lt;remote&gt; 是指远程仓库名字，一般是origin。</p><p><img src="/2023/11/02/git-study-commands/image-20231206170139401.png" alt="image-20231206170139401"></p></blockquote><p>创建分支：<code>git branch &lt;branchname&gt;</code></p><p>切换分支：<code>git checkout &lt;branchname&gt;</code></p><p>切换并创建分支：<code>git checkout -b &lt;branchname&gt;</code></p><p>切换并创建分支，并且跟踪指定远程分支：<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code></p><blockquote><p><code>git checkout --track origin/serverfix</code>和<code>git checkout serverfix</code>是git的快捷方式，它们在切换分支是会自动创建本地分支，名称同远程分支名一样，并且自动跟踪该远程分支。</p><p>注意，对于新创建的远程分支，本地需要先<code>git fetch</code>拉取最新信息后，再checkout。</p></blockquote><p>手动跟踪远程分支：<code>git branch -u &lt;origin&gt;/&lt;branchname&gt;</code></p><p>删除分支：<code>git branch -d &lt;branchname&gt;</code></p><p>查看本地分支信息：<code>git branch -v</code></p><p>查看本地分支信息对应的远程分支信息：<code>git branch -vv</code></p><p>合并分支：<code>git merge &lt;branchname&gt;</code></p><p>合并时遇到冲突的场景：</p><p><img src="/2023/11/02/git-study-commands/image-20231030173522040.png" alt="image-20231030173522040"></p><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><p><img src="/2023/11/02/git-study-commands/image-20231030173602974.png" alt="image-20231030173602974"></p><p>最后对冲突文件执行<code>git add &lt;file&gt;</code>，一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>冲突都合并并且暂存完之后，执行<code>git commit</code>，完成此次的冲突合并操作。</p><p>git branch --merged：查看已合并到当前分支的其他分支，表示这些分支已经合并了，可以删除。</p><p>git branch --no-merged：查看未合并到当前分支的其他分支，此时执行删除分支操作会失败，除非改为使用<code>git branch -D &lt;branchname&gt;</code>命令强制删除。</p><h3 id="网络命令"><a class="header-anchor" href="#网络命令"></a>网络命令</h3><p>网络命令就是指需要互联网才能获取到信息的命令。</p><h4 id="git-fetch"><a class="header-anchor" href="#git-fetch"></a>git fetch</h4><p>语法：<code>git fetch &lt;remote&gt;</code></p><p>含义：这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><h4 id="git-push"><a class="header-anchor" href="#git-push"></a>git push</h4><p>语法：<code>git push &lt;remote&gt; &lt;branch&gt;</code></p><p>含义：将本地Git仓库推送到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将远程仓库origin中的serverfix分支删除</span></span><br><span class="line">git push origin --delete serverfix</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ-生产者之消息发送</title>
      <link href="/2023/11/01/rocketmq-producer/"/>
      <url>/2023/11/01/rocketmq-producer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为是初学RocketMQ，为了更快速上手，所以直接从<a href="https://github.com/apache/rocketmq-spring/tree/master/rocketmq-spring-boot-samples">rocketmq-spring-boot-samples</a>示例开始。</p><p>⚠️注意：<strong><code>rocketmq-spring-boot-starter</code></strong> 适用于 <strong>RocketMQ 4.x 客户端</strong>，主要面向依赖于 RocketMQ 4.x 的应用。</p></blockquote><h2 id="rocketmq-produce-demo"><a class="header-anchor" href="#rocketmq-produce-demo"></a>rocketmq-produce-demo</h2><p>进入到 rocketmq-spring-boot-samples 项目中，会发现如下模块：</p><p><img src="/2023/11/01/rocketmq-producer/image-20231101103949080.png" alt="image-20231101103949080"></p><p>从名称可以看出，客户端-生产者分为普通demo和acl-demo两种，消费者也是如此。</p><p>在RocketMQ中，ACL的含义是访问控制表（Access Control List，ACL）描述用户或角色对资源的访问控制权限。简单点说，ACL就是控制指定用户是否对指定主题和消费组是否具有发送和消费的权限。</p><p>既然是初学，就从普通demo开始，等后面高级进阶再展开了解acl-demo。rocketmq-produce-demo的项目结构如下：</p><p><img src="/2023/11/01/rocketmq-producer/image-20231101105015584.png" alt="image-20231101105015584"></p><p><code>ProducerApplication</code>是一个SpringBootApplication，它注入了<code>RocketMQTemplate</code>和一些Topic名称，通过rocketMQTemplate向指定topic发送消息，简略代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;demo.rocketmq.topic&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String springTopic;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ProducerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Send string</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> rocketMQTemplate.syncSend(springTopic, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;syncSend1 to topic %s sendResult=%s %n&quot;</span>, springTopic, sendResult);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>run</code>方法可以看到<code>rocketMQTemplate.syncSend</code>就是生产者发送消息的实现方法，关键对象就是<code>RocketMQTemplate</code>，它是通过spring依赖注入进来的，那么现在就观察它是如何注册到spring容器中的。</p><p>因为<code>RocketMQTemplate</code>没有显式构造方法，因此直接在class类上打断点，启动Application，可以发现其在<code>RocketMQAutoConfiguration#rocketMQTemplate</code>方法下被实例化。熟悉SpringBoot自动装配的话，可以猜到在rocketmq-spring-boot模块下会有spring.factories，找到EnableAutoConfiguration的实现类也是<code>RocketMQAutoConfiguration</code>，其源码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RocketMQProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;MQAdmin.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &quot;name-server&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@Import(&#123;MessageConverterConfiguration.class, ListenerContainerConfiguration.class, ExtProducerResetConfiguration.class,</span></span><br><span class="line"><span class="meta">        ExtConsumerResetConfiguration.class, RocketMQTransactionConfiguration.class, RocketMQListenerConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;MessageConverterConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;RocketMQTransactionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROCKETMQ_TEMPLATE_DEFAULT_GLOBAL_NAME</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;rocketMQTemplate&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRODUCER_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;defaultMQProducer&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONSUMER_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;defaultLitePullConsumer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nameServer</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;rocketmq.name-server&quot;</span>, String.class);</span><br><span class="line">        log.debug(<span class="string">&quot;rocketmq.nameServer = &#123;&#125;&quot;</span>, nameServer);</span><br><span class="line">        <span class="keyword">if</span> (nameServer == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The necessary spring property &#x27;rocketmq.name-server&#x27; is not defined, all rockertmq beans creation are skipped!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(PRODUCER_BEAN_NAME)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(DefaultMQProducer.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;&quot;name-server&quot;, &quot;producer.group&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultMQProducer <span class="title function_">defaultMQProducer</span><span class="params">(RocketMQProperties rocketMQProperties)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(CONSUMER_BEAN_NAME)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(DefaultLitePullConsumer.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;&quot;name-server&quot;, &quot;pull-consumer.group&quot;, &quot;pull-consumer.topic&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultLitePullConsumer <span class="title function_">defaultLitePullConsumer</span><span class="params">(RocketMQProperties rocketMQProperties)</span></span><br><span class="line">            <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(ProducerOrConsumerPropertyCondition.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = ROCKETMQ_TEMPLATE_DEFAULT_GLOBAL_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQTemplate <span class="title function_">rocketMQTemplate</span><span class="params">(RocketMQMessageConverter rocketMQMessageConverter)</span> &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProducerOrConsumerPropertyCondition</span> <span class="keyword">extends</span> <span class="title class_">AnyNestedCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ProducerOrConsumerPropertyCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ConditionalOnBean(DefaultMQProducer.class)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultMQProducerExistsCondition</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ConditionalOnBean(DefaultLitePullConsumer.class)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultLitePullConsumerExistsCondition</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RocketMQAutoConfiguration</code>注册了三个Bean（<code>DefaultMQProducer</code>、<code>DefaultLitePullConsumer</code>、<code>RocketMQTemplate</code>），看一下<code>RocketMQTemplate</code>的注册条件：</p><ol><li>spring容器中需要存在<code>DefaultMQProducer</code>和<code>DefaultLitePullConsumer</code>两个Bean。</li><li>容器中没有注册过bean名称为rocketMQTemplate的Bean。</li></ol><p>再看<code>RocketMQTemplate</code>注册为Bean的实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RocketMQTemplate <span class="title function_">rocketMQTemplate</span><span class="params">(RocketMQMessageConverter rocketMQMessageConverter)</span> &#123;</span><br><span class="line">    <span class="type">RocketMQTemplate</span> <span class="variable">rocketMQTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RocketMQTemplate</span>();</span><br><span class="line">    <span class="keyword">if</span> (applicationContext.containsBean(PRODUCER_BEAN_NAME)) &#123;</span><br><span class="line">        rocketMQTemplate.setProducer((DefaultMQProducer) applicationContext.getBean(PRODUCER_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (applicationContext.containsBean(CONSUMER_BEAN_NAME)) &#123;</span><br><span class="line">        rocketMQTemplate.setConsumer((DefaultLitePullConsumer) applicationContext.getBean(CONSUMER_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    rocketMQTemplate.setMessageConverter(rocketMQMessageConverter.getMessageConverter());</span><br><span class="line">    <span class="keyword">return</span> rocketMQTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<code>RocketMQTemplate</code>将生产者、消费者、消息类型转换器都集中在一起，做了一个统一模板。因此<code>RocketMQTemplate</code>除了发送消息外，还可以拉取消息并转换成客户端想要的消息类型。</p><h2 id="生产者发送消息原理"><a class="header-anchor" href="#生产者发送消息原理"></a>生产者发送消息原理</h2><p>跟踪进入<code>rocketMQTemplate.syncSend</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Same to &#123;<span class="doctag">@link</span> #syncSend(String, Message)&#125; with send timeout specified in addition.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> destination formats: `topicName:tags`</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message &#123;<span class="doctag">@link</span> org.springframework.messaging.Message&#125;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeout send timeout with millis</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> delayLevel level for the delay message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> SendResult&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> SendResult <span class="title function_">syncSend</span><span class="params">(String destination, Message&lt;?&gt; message, <span class="type">long</span> timeout, <span class="type">int</span> delayLevel)</span> &#123;</span><br><span class="line">     <span class="comment">// 校验参数合法性</span></span><br><span class="line">     <span class="keyword">if</span> (Objects.isNull(message) || Objects.isNull(message.getPayload())) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;syncSend failed. destination:&#123;&#125;, message is null &quot;</span>, destination);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;`message` and `message.payload` cannot be null&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 构建RocketMQ生产者发送消息需要的Message对象</span></span><br><span class="line">         org.apache.rocketmq.common.message.<span class="type">Message</span> <span class="variable">rocketMsg</span> <span class="operator">=</span> <span class="built_in">this</span>.createRocketMqMessage(destination, message);</span><br><span class="line">         <span class="comment">// 延迟消息的级别，普通消费默认为0</span></span><br><span class="line">         <span class="keyword">if</span> (delayLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             rocketMsg.setDelayTimeLevel(delayLevel);</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">// 同步发送消息并返回发送结果</span></span><br><span class="line">         <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(rocketMsg, timeout);</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span> sendResult;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;syncSend failed. destination:&#123;&#125;, message:&#123;&#125;, detail exception info: &quot;</span>, destination, message, e);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessagingException</span>(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里面<code>producer.send</code>方法的<code>producer</code>就是RocketMQ的生产者对象了，对象类型为<code>DefaultMQProducer</code>，再进入方法内部看看发送消息的原理。</p><p><img src="/2023/11/01/rocketmq-producer/image-20231101110309440.png" alt="image-20231101110309440"></p><p>可以发现<code>DefaultMQProducer</code>更像是一个代理类，具体实现类为<code>DefaultMQProducerImpl</code>，进入实现类的<code>DefaultMQProducerImpl#send</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(Message msg,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="literal">null</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>send</code>方法又调用内部的<code>DefaultMQProducerImpl#sendDefaultImpl</code>实现方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendDefaultImpl</span><span class="params">(</span></span><br><span class="line"><span class="params">    Message msg,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> <span class="type">long</span> timeout</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 确认服务状态是否正常运行</span></span><br><span class="line">    <span class="built_in">this</span>.makeSureStateOK();</span><br><span class="line">    <span class="comment">// 校验消息和topic是否合法，例如消息不能为空，消息字节长度不能超出限制，topic是否超长，topic是否为系统特殊topic</span></span><br><span class="line">    Validators.checkMessage(msg, <span class="built_in">this</span>.defaultMQProducer);</span><br><span class="line">    <span class="comment">// 生成随机id</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">invokeID</span> <span class="operator">=</span> random.nextLong();</span><br><span class="line">    <span class="comment">// 最开始发送消息的时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTimestampFirst</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 此次发送消息的时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTimestampPrev</span> <span class="operator">=</span> beginTimestampFirst;</span><br><span class="line">    <span class="comment">// 结束的时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimestamp</span> <span class="operator">=</span> beginTimestampFirst;</span><br><span class="line">    <span class="comment">// 从NameServer获取topic信息</span></span><br><span class="line">    <span class="type">TopicPublishInfo</span> <span class="variable">topicPublishInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="comment">// topic存在的情况下，执行发送消息动作。否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="literal">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">callTimeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 消息发送的重试次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">timesTotal</span> <span class="operator">=</span> communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="built_in">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次发送消息的brokerName</span></span><br><span class="line">        String[] brokersSent = <span class="keyword">new</span> <span class="title class_">String</span>[timesTotal];</span><br><span class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">            <span class="comment">// 上一次消息队列的brokerName</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lastBrokerName</span> <span class="operator">=</span> <span class="literal">null</span> == mq ? <span class="literal">null</span> : mq.getBrokerName();</span><br><span class="line">            <span class="comment">// 从TopicPublishInfo中选择一个消息队列，根据轮询方式拿取</span></span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mqSelected</span> <span class="operator">=</span> <span class="built_in">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">            <span class="keyword">if</span> (mqSelected != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 记录本次消息队列，用于下一次循环</span></span><br><span class="line">                mq = mqSelected;</span><br><span class="line">                <span class="comment">// 记录本次的brokerName</span></span><br><span class="line">                brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录本次发送消息的时间戳</span></span><br><span class="line">                    beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果是重试发送消息，则重置带有namespace的topic</span></span><br><span class="line">                        msg.setTopic(<span class="built_in">this</span>.defaultMQProducer.withNamespace(msg.getTopic()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前方法的所用时间</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                    <span class="comment">// 如果超时，则报错</span></span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                        callTimeout = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 发送消息的核心实现方法</span></span><br><span class="line">                    sendResult = <span class="built_in">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                    <span class="comment">// 发送消息的结束时间</span></span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">// 更新broker是否可用，用于上面的 selectOneMessageQueue 方法</span></span><br><span class="line">                    <span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                        <span class="keyword">case</span> ASYNC:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> SYNC:</span><br><span class="line">                            <span class="comment">// 同步发送时，如果发送失败</span></span><br><span class="line">                            <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                <span class="comment">// 生产者是否开启重试机制，默认不开启</span></span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> sendResult;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException | MQClientException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">true</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    exception = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 成功执行发送操作后，返回发送结果</span></span><br><span class="line">        <span class="keyword">if</span> (sendResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 以下均为还未执行发送操作的异常处理</span></span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validateNameServerSetting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;No route info of this topic: &quot;</span> + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</span><br><span class="line">        <span class="literal">null</span>).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>DefaultMQProducerImpl#sendDefaultImpl</code>方法这个代码量也可以看出，这里就是RocketMQ生产者发送消息的关键代码了，方法的每一行步骤都进行了注释说明，现在对其做个总结：</p><ol><li>校验服务器、校验参数，初始化一些记录值，例如时间戳。</li><li>根据topic名称获取<code>TopicPublishInfo</code>。</li><li>根据<code>TopicPublishInfo</code>获取准备发送的消息队列（<code>MessageQueue</code>）。</li><li>调用内核的发送消息实现方法（<code>sendKernelImpl</code>），参数大致有消息body、消息队列MessageQueue、发送方式CommunicationMode、异步发送时的回调方法SendCallback、topic信息TopicPublishInfo、超时时间timeout。</li><li>记录发送消息后broker的状态，通过耗时判断broker是否正常运行。</li><li>如果发送方式是同步发送，在发送失败后，判断是否需要重试发送。</li></ol><p>通过总结，可以发现<code>DefaultMQProducerImpl#sendDefaultImpl</code>其实更多的是在做发送消息前的准备工作，以及发送失败后的重试工作和异常处理工作。所以需要继续往下看，<code>DefaultMQProducerImpl#sendKernelImpl</code>方法的实现原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MQClientInstance mQClientFactory;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> SYNC:</span><br><span class="line">        <span class="type">long</span> <span class="variable">costTimeSync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingTooMuchRequestException</span>(<span class="string">&quot;sendKernelImpl call timeout&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sendResult = <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">            brokerAddr,</span><br><span class="line">            brokerName,</span><br><span class="line">            msg,</span><br><span class="line">            requestHeader,</span><br><span class="line">            timeout - costTimeSync,</span><br><span class="line">            communicationMode,</span><br><span class="line">            context,</span><br><span class="line">            <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>MQClientAPIImpl#sendMessage</code>在发送同步消息时，又会调用内部的<code>sendMessageSync</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RemotingClient remotingClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendMessageSync</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> String addr,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> String brokerName,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> Message msg,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> <span class="type">long</span> timeoutMillis,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> RemotingCommand request</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">    <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>.remotingClient.invokeSync(addr, request, timeoutMillis);</span><br><span class="line">    <span class="keyword">assert</span> response != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.processSendResponse(brokerName, msg, response, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RemotingClient</code>的实现类则是<code>NettyRemotingClient</code>，由此可知RocketMQ使用Netty作为底层网络编程框架。</p><p>在<code>MQClientAPIImpl</code>中纵观其他方法，可以推断RocketMQ的Client与Server交互都是基于此类，例如创建topic、发送消息、拉取消息、心跳检测等。</p><p><strong>小结</strong>：</p><p>生产者的核心类大致为 DefaultMQProducer -&gt; DefaultMQProducerImpl -&gt; MQClientInstance -&gt; MQClientAPIImpl -&gt; RemotingClient 。</p><p>DefaultMQProducer：生产者的包装类，提供多样的消息发送方式，以及控制消息发送时的行为。</p><p>DefaultMQProducerImpl：生产者的实现类，用于生产者对象与客户端Client的交互，为生产者提供服务，将生产者注册到服务端Server。</p><p>MQClientInstance：RocketMQ客户端的实例，用于客户端Client与服务端Server的交互，为客户端的生产者和消费者提供接口服务。</p><p>MQClientAPIImpl：RocketMQ客户端API层的实现类，为客户端提供服务端的API，并管理远程通信对象（RemotingClient）。</p><p>RemotingClient：RocketMQ底层实现网络通信的客户端工具，默认实现类为NettyRemotingClient。</p><h2 id="生产者核心参数"><a class="header-anchor" href="#生产者核心参数"></a>生产者核心参数</h2><p>在使用过程中，用户一般只与<code>DefaultMQProducer</code>进行交互，所以着重关注它下面的变量参数。</p><ul><li><p>InternalLogger log = ClientLogger.getLog()</p><p>客户端的日志实现类，RocketMQ 客户端的日志路径为 <code>$&#123;user.home&#125;/logs/rocketmqlogs/rocketmq_client.log</code>。在排查问题时可以从日志文件下手，寻找错误日志，为解决问题提供必要的信息。其中 user.home 为用户的主目录。</p></li><li><p>String producerGroup</p><p>发送者所属组，开源版本的 RocketMQ，发送者所属组主要的用途是事务消息，Broker 需要向消息发送者回查事务状态。可以通过相关命令或 RocketMQ-Console 查看某一个 Topic 指定消费组的客户端，如下图所示：</p><p><img src="/2023/11/01/rocketmq-producer/20200801154629423.png" alt="2"></p></li><li><p>int defaultTopicQueueNums = 4</p><p>通过生产者创建 Topic 时默认的队列数量。</p></li><li><p>int sendMsgTimeout = 3000</p><p>消息发送默认超时时间，单位为毫秒。值得注意的是在 RocketMQ 4.3.0 版本之前，由于存在重试机制，设置的设计为单次重试的超时时间，即如果设置重试次数为 3 次，则 <code>DefaultMQProducer#send</code> 方法可能会超过 9s 才返回；该问题在 RocketMQ 4.3.0 版本进行了优化，设置的超时时间为总的超时时间，即如果超时时间设置 3s，重试次数设置为 10 次，可能不会重试 10 次，例如在重试到第 5 次的时候，已经超过 3s 了，试图尝试第 6 次重试时会退出，抛出超时异常，停止重试。</p></li><li><p>int compressMsgBodyOverHowmuch = 1024 * 4</p><p>压缩的阔值，默认为 4k，即当消息的消息体超过 4k，则会使用 zip 对消息体进行压缩，会增加 Broker 端的 CPU 消耗，但能提高网络方面的开销。</p></li><li><p>int retryTimesWhenSendFailed = 2</p><p>同步消息发送重试次数。RocketMQ 客户端内部在消息发送失败时默认会重试 2 次。请主要该参数与 sendMsgTimeout 会联合起来生效，详情请参照上文所述。</p></li><li><p>int retryTimesWhenSendAsyncFailed = 2</p><p>异步消息发送重试次数，默认为 2，即重试 2 次，加上第一次发送的次数，所以总共有三次机会。</p></li><li><p>boolean retryAnotherBrokerWhenNotStoreOK = false</p><p>该参数的本意是如果客户端收到的结果不是 SEND_OK，应该是不问源由的继续向另外一个 Broker 重试，但默认设置为false后，就不会触发重试机制。</p></li><li><p>int maxMessageSize = 1024 * 1024 * 4</p><p>允许发送的最大消息体，默认为 4M，服务端（Broker）也有 maxMessageSize 这个参数的设置，故客户端的设置不能超过服务端的配置，最佳实践为客户端的配置小于服务端的配置。</p></li></ul><p>在消息发送失败后，会有重试机制，所以RocketMQ有一个对应的失败策略类<code>MQFaultStrategy</code>，核心参数如下：</p><ul><li><p>boolean sendLatencyFaultEnable = false</p><p>是否开启失败延迟规避机制。RocketMQ 客户端内部在重试时会规避上一次发送失败的 Broker，如果开启延迟失败规避，则在未来的某一段时间内不向该 Broker 发送消息，具体机制在本篇的第三部分详细展开。默认为 false，不开启。</p></li><li><p>long[] latencyMax = {50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L}</p><p>设置消息发送的最大延迟级别，默认值为 {50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L}，个数与 notAvailableDuration 对应。</p></li><li><p>long[] notAvailableDuration = {0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L}</p><p>不可用的延迟数组，默认值为 {0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L}，即每次触发 Broker 的延迟时间是一个阶梯的，会根据每次消息发送的延迟时间来选择在未来多久内不向该 Broker 发送消息。</p></li></ul><p>这三个参数，<code>MQFaultStrategy</code>类都提供了setter方法可供修改，在<code>DefaultMQProducer</code>都提供了对应方法。</p><p><code>DefaultMQProducer</code>还继承了<code>ClientConfig</code>类，核心参数如下：</p><ul><li><p>String namesrvAddr = NameServerAddressUtils.getNameServerAddresses()</p><p>NameServer 的地址列表。</p></li><li><p>String clientIP = RemotingUtil.getLocalAddress()</p><p>客户端 IP，通过 <code>RemotingUtil#getLocalAddress</code> 方法获取，在 4.7.0 版本中优先会返回不是 127.0.0.1 和 192.168 开头的最后一个 IPV4 或第一个 IPV6。客户端 IP 主要是用来定位消费者的，clientIP 会当成客户端 id 的组成部分。</p></li><li><p>String instanceName = System.getProperty(&quot;rocketmq.client.name&quot;, &quot;DEFAULT&quot;)</p><p>客户端实例名称，是客户端标识 CID 的组成部分。</p></li><li><p>String unitName</p><p>定义一个单元，主要用途：客户端 CID 的组成部分；如果获取 NameServer 的地址是通过 URL 进行动态更新的话，会将该值附加到当中，即可以区分不同的获取 NameServer 地址的服务。</p></li><li><p>int clientCallbackExecutorThreads = Runtime.getRuntime().availableProcessors()</p><p>客户端 public 回调的线程池线程数量，默认为 CPU 核数，不建议改变该值。</p></li><li><p>String namespace</p><p>客户端命名空间，从 4.5.1 版本被引入。</p></li><li><p>int pollNameServerInterval = 1000 * 30</p><p>客户端从 NameServer 更新 Topic 的间隔，默认值 30s，就 Producer、Consumer 会每隔 30s 向 NameServer 更新 Topic 的路由信息，该值不建议修改。</p></li><li><p>int heartbeatBrokerInterval = 1000 * 30</p><p>客户端向 Broker 发送心跳包的时间间隔，默认为 30s，该值不建议修改。</p></li><li><p>int persistConsumerOffsetInterval = 1000 * 5</p><p>客户端持久化消息消费进度的间隔，默认为 5s，该值不建议修改。</p></li></ul><h2 id="封装生产者工具"><a class="header-anchor" href="#封装生产者工具"></a>封装生产者工具</h2><p>RocketMQ生产者对象<code>MQProducer</code>其实已经封装的差不多了，大致就是通过<code>MQProducer</code>对象发送一个<code>Message</code>对象即可，为了让业务层更加方便的使用，不用去了解RocketMQ的<code>Message</code>对象含义，对其进行二次封装。</p><p>二次封装的主要作用：</p><ol><li>规避RocketMQ的类对象使用。</li><li>同一处理消息发送过程，例如日志链路。</li><li>同一处理消息发送异常，让业务层感知为运行时异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ProducerHelper.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MQProducer mqProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String defaultTopic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProducerHelper</span><span class="params">(<span class="meta">@Autowired</span> MQProducer mqProducer, <span class="meta">@Value(&quot;$&#123;rocketmq.demo.topic&#125;&quot;)</span> String topic)</span> &#123;</span><br><span class="line">        ProducerHelper.mqProducer = mqProducer;</span><br><span class="line">        ProducerHelper.defaultTopic = topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">send</span><span class="params">(Object message)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> buildMessage(message, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> doSend(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">send</span><span class="params">(Object message, String topic)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> buildMessage(message, topic, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> doSend(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">send</span><span class="params">(Object message, String topic, String tags)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> buildMessage(message, topic, tags, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> doSend(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">send</span><span class="params">(Object message, String topic, String tags, String keys)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> buildMessage(message, topic, tags, keys);</span><br><span class="line">        <span class="keyword">return</span> doSend(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">buildMessage</span><span class="params">(Object message, String topic, String tags, String keys)</span> &#123;</span><br><span class="line">        topic = StringUtils.hasText(topic) ? topic : defaultTopic;</span><br><span class="line">        <span class="type">byte</span>[] body = JSON.toJSONBytes(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic, tags, keys, body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">doSend</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> mqProducer.send(msg);</span><br><span class="line">            log.info(<span class="string">&quot;MQ消息发送成功，消息结果: &quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result.getMsgId();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;MQ消息发送异常, 消息内容: &quot;</span> + msg, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ-概念</title>
      <link href="/2023/10/23/rocketmq-concept/"/>
      <url>/2023/10/23/rocketmq-concept/</url>
      
        <content type="html"><![CDATA[<h2 id="RocketMQ基本概念"><a class="header-anchor" href="#RocketMQ基本概念"></a>RocketMQ基本概念</h2><p>RocketMQ 是一个分布式消息中间件，用于实现可靠的、可伸缩的消息传递。消息中间件大致上都分为消息生产端、消息存储端、消息消费端。RocketMQ的领域模型大致如下：</p><p><img src="/2023/10/23/rocketmq-concept/image-20231023152728033.png" alt="image-20231023152728033"></p><p>消息生产端：</p><ul><li><p>生产者（Producer）：</p><p>生产者是消息的发送方，负责产生并发送消息到 RocketMQ Broker。生产者将消息发送到指定的 Topic（主题）。</p></li></ul><p>消息存储端：</p><ul><li><p>主题（Topic）：</p><p>主题是 Apache RocketMQ 中消息传输和存储的顶层容器，用于标识同一类业务逻辑的消息，所有消息资源的定义都在主题内部完成，但主题是一个逻辑概念，并不是实际的消息容器。</p><p>主题内部由多个队列组成，消息的存储和水平扩展能力最终是由队列实现的；并且针对主题的所有约束和属性设置，最终也是通过主题内部的队列来实现。</p></li><li><p>队列（MessageQueue）：</p><p>队列是 Apache RocketMQ 中消息存储和传输的实际容器，也是 Apache RocketMQ 消息的最小存储单元。 Apache RocketMQ 的所有主题都是由多个队列组成，以此实现队列数量的水平拆分和队列内部的流式存储。</p></li><li><p>消息（Message）：</p><p>Apache RocketMQ 的最小传输单元。消息具备不可变性，在初始化发送和完成存储后即不可变。</p></li></ul><p>消息消费端：</p><ul><li><p>消费者分组（ConsumerGroup）：</p><p>Apache RocketMQ 发布订阅模型中定义的独立的消费身份分组，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持消费逻辑和配置一致，共同分担该消费组订阅的消息，实现消费能力的水平扩展。</p></li><li><p>消费者（Consumer）：</p><p>消费者是 Apache RocketMQ 中用来接收并处理消息的运行实体。 消费者通常被集成在业务系统中，从 Apache RocketMQ 服务端获取消息，并将消息转化成业务可理解的信息，供业务逻辑处理。</p><p>在消息消费端，可以定义如下传输行为：</p><ul><li>消费者身份：消费者必须关联一个指定的消费者分组，以获取分组内统一定义的行为配置和消费状态。</li><li>消费者类型：Apache RocketMQ 面向不同的开发场景提供了多样的消费者类型，包括PushConsumer类型、SimpleConsumer类型、PullConsumer类型（仅推荐流处理场景使用）等。具体信息，请参见<a href="https://rocketmq.apache.org/zh/docs/featureBehavior/06consumertype">消费者分类</a>。</li><li>消费者本地运行配置：消费者根据不同的消费者类型，控制消费者客户端本地的运行配置。例如消费者客户端的线程数，消费并发度等，实现不同的传输效果。</li></ul></li><li><p>订阅关系（Subscription）：</p><p>Apache RocketMQ 发布订阅模型中消息过滤、重试、消费进度的规则配置。订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。</p><p>Apache RocketMQ 的订阅关系除过滤表达式之外都是持久化的，即服务端重启或请求断开，订阅关系依然保留。</p></li></ul><h2 id="快速开始"><a class="header-anchor" href="#快速开始"></a>快速开始</h2><h3 id="安装服务端"><a class="header-anchor" href="#安装服务端"></a>安装服务端</h3><ol><li><p>下载Apache RocketMQ</p><p>在<a href="https://github.com/apache/rocketmq">GitHub releases</a>选择Source code下载zip文件。解压源码包并编译构建二进制可执行文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip rocketmq-all-5.1.4-source-release.zip</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> rocketmq-all-5.1.4-source-release/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn -Prelease-all -DskipTests -Dspotbugs.skip=<span class="literal">true</span> clean install -U</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> distribution/target/rocketmq-5.1.4/rocketmq-5.1.4</span></span><br></pre></td></tr></table></figure><blockquote><p>RocketMQ 的安装包分为两种，二进制包和源码包。 二进制包是已经编译完成后可以直接运行的，源码包是需要编译后运行的。</p></blockquote></li><li><p>启动NameServer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 启动namesrv</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证namesrv是否启动成功</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure></li><li><p>启动Broker+Proxy</p><p>NameServer成功启动后，再启动Broker和Proxy，5.x 版本下建议使用 Local 模式部署，即 Broker 和 Proxy 同进程部署。5.x 版本也支持 Broker 和 Proxy 分离部署以实现更灵活的集群能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 先启动broker</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 --enable-proxy &amp;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/proxy.log</span> </span><br><span class="line">The broker[broker-a,192.169.1.2:10911] boot success...</span><br></pre></td></tr></table></figure></li><li><p>关闭服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/mqshutdown broker</span></span><br><span class="line">The mqbroker(36695) is running...</span><br><span class="line">Send shutdown request to mqbroker with proxy enable OK(36695)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/mqshutdown namesrv</span></span><br><span class="line">The mqnamesrv(36664) is running...</span><br><span class="line">Send shutdown request to mqnamesrv(36664) OK</span><br></pre></td></tr></table></figure></li></ol><h3 id="测试消息收发"><a class="header-anchor" href="#测试消息收发"></a>测试消息收发</h3><ol><li><p>工具测试消息收发</p><p>在进行工具测试消息收发之前，我们需要告诉客户端NameServer的地址，RocketMQ有多种方式在客户端中设置NameServer地址，这里我们利用环境变量<code>NAMESRV_ADDR</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span></span><br><span class="line"> SendResult [sendStatus=SEND_OK, msgId= ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span></span><br><span class="line"><span class="meta prompt_"> ConsumeMessageThread_%</span><span class="language-bash">d Receive New Messages: [MessageExt...</span></span><br></pre></td></tr></table></figure></li><li><p>SDK测试消息收发</p><ol><li><p>添加pom依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;rocketmq-client-java-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>通过mqadmin创建 Topic。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/mqadmin updatetopic -n localhost:9876 -t TestTopic -c DefaultCluster</span></span><br></pre></td></tr></table></figure></li><li><p>在已创建的Java工程中，创建发送普通消息程序并运行，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.ClientConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.ClientConfigurationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.ClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.ClientServiceProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.producer.SendReceipt;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ProducerExample.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClientException &#123;</span><br><span class="line">        <span class="comment">// 接入点地址，需要设置成Proxy的地址和端口列表，一般是xxx:8081;xxx:8081。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;localhost:8081&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息发送的目标Topic名称，需要提前创建。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;TestTopic&quot;</span>;</span><br><span class="line">        <span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> ClientServiceProvider.loadService();</span><br><span class="line">        <span class="type">ClientConfigurationBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> ClientConfiguration.newBuilder().setEndpoints(endpoint);</span><br><span class="line">        <span class="type">ClientConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> builder.build();</span><br><span class="line">        <span class="comment">// 初始化Producer时需要设置通信配置以及预绑定的Topic。</span></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> provider.newProducerBuilder()</span><br><span class="line">            .setTopics(topic)</span><br><span class="line">            .setClientConfiguration(configuration)</span><br><span class="line">            .build();</span><br><span class="line">        <span class="comment">// 普通消息发送。</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> provider.newMessageBuilder()</span><br><span class="line">            .setTopic(topic)</span><br><span class="line">            <span class="comment">// 设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">            .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">            <span class="comment">// 设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">            .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">            <span class="comment">// 消息体。</span></span><br><span class="line">            .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">            .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发送消息，需要关注发送结果，并捕获失败等异常。</span></span><br><span class="line">            <span class="type">SendReceipt</span> <span class="variable">sendReceipt</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            logger.info(<span class="string">&quot;Send message successfully, messageId=&#123;&#125;&quot;</span>, sendReceipt.getMessageId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to send message&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// producer.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在已创建的Java工程中，创建订阅普通消息程序并运行。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.ClientConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.ClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.ClientServiceProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.consumer.ConsumeResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.consumer.FilterExpression;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.consumer.FilterExpressionType;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.apis.consumer.PushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PushConsumerExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(PushConsumerExample.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PushConsumerExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClientException, IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> ClientServiceProvider.loadService();</span><br><span class="line">        <span class="comment">// 接入点地址，需要设置成Proxy的地址和端口列表，一般是xxx:8081;xxx:8081。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">endpoints</span> <span class="operator">=</span> <span class="string">&quot;localhost:8081&quot;</span>;</span><br><span class="line">        <span class="type">ClientConfiguration</span> <span class="variable">clientConfiguration</span> <span class="operator">=</span> ClientConfiguration.newBuilder()</span><br><span class="line">            .setEndpoints(endpoints)</span><br><span class="line">            .build();</span><br><span class="line">        <span class="comment">// 订阅消息的过滤规则，表示订阅所有Tag的消息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">        <span class="type">FilterExpression</span> <span class="variable">filterExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterExpression</span>(tag, FilterExpressionType.TAG);</span><br><span class="line">        <span class="comment">// 为消费者指定所属的消费者分组，Group需要提前创建。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">consumerGroup</span> <span class="operator">=</span> <span class="string">&quot;YourConsumerGroup&quot;</span>;</span><br><span class="line">        <span class="comment">// 指定需要订阅哪个目标Topic，Topic需要提前创建。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;TestTopic&quot;</span>;</span><br><span class="line">        <span class="comment">// 初始化PushConsumer，需要绑定消费者分组ConsumerGroup、通信参数以及订阅关系。</span></span><br><span class="line">        <span class="type">PushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> provider.newPushConsumerBuilder()</span><br><span class="line">            .setClientConfiguration(clientConfiguration)</span><br><span class="line">            <span class="comment">// 设置消费者分组。</span></span><br><span class="line">            .setConsumerGroup(consumerGroup)</span><br><span class="line">            <span class="comment">// 设置预绑定的订阅关系。</span></span><br><span class="line">            .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))</span><br><span class="line">            <span class="comment">// 设置消费监听器。</span></span><br><span class="line">            .setMessageListener(messageView -&gt; &#123;</span><br><span class="line">                <span class="comment">// 处理消息并返回消费结果。</span></span><br><span class="line">                logger.info(<span class="string">&quot;Consume message successfully, messageId=&#123;&#125;&quot;</span>, messageView.getMessageId());</span><br><span class="line">                <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">        <span class="comment">// 如果不需要再使用 PushConsumer，可关闭该实例。</span></span><br><span class="line">        <span class="comment">// pushConsumer.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>消费消息时，消息对象是MessageView，它存放内容的实体是字节数组，可以使用Java NIO包的<code>Charset</code>来解码字节序列。以下是示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> StandardCharsets.UTF_8</span><br><span class="line">                      .decode(messageView.getBody())</span><br><span class="line">                      .toString();</span><br><span class="line">System.out.println(<span class="string">&quot;message&quot;</span> + message);</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习-起步(1)</title>
      <link href="/2023/10/13/git-study-1/"/>
      <url>/2023/10/13/git-study-1/</url>
      
        <content type="html"><![CDATA[<h2 id="学习大纲"><a class="header-anchor" href="#学习大纲"></a>学习大纲</h2><p>本次Git学习将全程按照<a href="https://git-scm.com/book/zh/v2">Git Book</a>的章节进行学习。学习目录分为：</p><ol><li>起步</li><li>Git基础</li><li>Git分支</li><li>服务器上的Git</li><li>分布式Git</li><li>GitHub</li><li>Git工具</li><li>自定义Git</li><li>Git与其他系统</li><li>Git内部原理</li></ol><blockquote><p>本次重新学习Git的初衷，也不是想要深入了解Git工作原理，掌握高端操作什么的。仅是希望在日后开发工作途中，坚持只使用Git命令行操作Git，理解每个Git命令的含义，能够轻松应付日常所需（例如克隆仓库、拉取代码、提交代码、远程推送、代码回退等）。除此之外，在学习途中将认为平常常使用的命令做一个归纳收集，便于后期温故。</p></blockquote><h2 id="Git的自述"><a class="header-anchor" href="#Git的自述"></a>Git的自述</h2><p>先说Git是什么，<strong>Git是一个分布式版本控制系统（Distributed Version Control System，简称 DVCS）</strong>。</p><p>而分布式版本控制系统是什么，就要说到为什么会出现版本控制系统这个东西。</p><h3 id="本地版本控制"><a class="header-anchor" href="#本地版本控制"></a>本地版本控制</h3><p>在早期，人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是<strong>采用某种简单的数据库来记录文件的历次更新差异</strong>。</p><p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p><p><strong>总结</strong>：通过本地数据库记录项目文件的修改记录。缺点就是只能在单机实现版本控制。</p><h3 id="集中化的版本控制系统"><a class="header-anchor" href="#集中化的版本控制系统"></a>集中化的版本控制系统</h3><p>集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都<strong>有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新</strong>。 多年以来，这已成为版本控制系统的标准做法。</p><p><strong>总结</strong>：通过中央服务器作为远程版本控制系统。优点是开发者们可以通过与中央服务器的交互，知道协同工作人员的修改记录，即可以多人协同工作。缺点是太依赖中央服务器，如果中央服务器出现问题，那么所有人都无法协同。</p><h3 id="分布式版本控制系统"><a class="header-anchor" href="#分布式版本控制系统"></a>分布式版本控制系统</h3><p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，<strong>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录</strong>。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><p><strong>总结</strong>：在集中化的版本控制系统基础上，将客户端也作为了完整的版本控制系统。优点是即使中央服务器挂了，也可以通过客户端还原所有版本记录，并且在项目文件发生变更做提交操作时可以先在本地提交，等中央服务器好了再同步。</p><h2 id="Git的基本介绍"><a class="header-anchor" href="#Git的基本介绍"></a>Git的基本介绍</h2><ul><li><p>Git在对待文件的版本控制上，是通过记录快照的方式，而非差异比较。</p></li><li><p>Git的命令操作，绝大多数都是本地执行。</p></li><li><p>Git保证完整性，即在Git工作目录下的文件，Git会计算校验和（SHA-1 散列）。</p></li><li><p>Git一般只添加数据，即Git的所有操作都是做增量记录，使得Git可以让工作目录回溯到以前的任何一个时间段。</p></li><li><p>Git项目包含三个组件：工作区、暂存区、存储库。</p><ul><li>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li><li>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</li><li>Git 仓库目录（存储库）是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</li></ul></li><li><p>Git管理的文件有三种状态：已修改、已暂存、已提交。</p><ul><li><p>已修改表示修改了文件，但还没保存到数据库中。</p></li><li><p>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p></li><li><p>已提交表示数据已经安全地保存在本地数据库中。</p></li></ul></li><li><p>Git的基本工作流程：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到存储库中。</li></ol></li></ul><h2 id="安装Git"><a class="header-anchor" href="#安装Git"></a>安装Git</h2><p>Git作为实现版本控制系统的软件，需要安装在本地环境。安装的Git版本尽量安装最新版本，因为Git对向后兼容做的比较好，在日常使用中不用担心版本兼容问题。</p><h3 id="Windows环境安装Git"><a class="header-anchor" href="#Windows环境安装Git"></a>Windows环境安装Git</h3><p>打开下面的官方下载地址，选择对应的操作系统安装即可。</p><p><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><h3 id="macOS环境安装Git"><a class="header-anchor" href="#macOS环境安装Git"></a>macOS环境安装Git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><h3 id="Linux环境安装Git"><a class="header-anchor" href="#Linux环境安装Git"></a>Linux环境安装Git</h3><p>打开下面的官方下载地址，选择对应Linux发行版的安装命令执行即可。</p><p><a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a></p><h2 id="Git环境配置"><a class="header-anchor" href="#Git环境配置"></a>Git环境配置</h2><p>在安装完Git后，可以定制一些全局配置，例如user.name、user.email等。</p><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li></ol><p>每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><h3 id="用户信息"><a class="header-anchor" href="#用户信息"></a>用户信息</h3><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;Wray&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email wray@example.com</span></span><br></pre></td></tr></table></figure><p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p><h3 id="检查配置信息"><a class="header-anchor" href="#检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list</span></span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><p>（需要注意的是，git config读取配置也是按照配置文件的优先级读取的）</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name</span></span><br><span class="line">Wray</span><br></pre></td></tr></table></figure><p>由于 Git 会从多个文件中读取同一配置变量的不同值，因此你可能会在其中看到意料之外的值而不知道为什么。 此时，你可以查询 Git 中该变量的 <strong>原始</strong> 值（也就是最终实际用到的值），它会告诉你哪一个配置文件最后设置了该值：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --show-origin user.name</span></span><br><span class="line">file:/Users/wangfarui/.gitconfigWray</span><br></pre></td></tr></table></figure><h2 id="Git的Help"><a class="header-anchor" href="#Git的Help"></a>Git的Help</h2><p>熟练使用git help，基本可以找到你想要的所有git命令语法。</p><p>使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">help</span> &lt;verb&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git &lt;verb&gt; --<span class="built_in">help</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man git-&lt;verb&gt;</span></span><br></pre></td></tr></table></figure><p>其中的<code>&lt;verb&gt;</code>表示git动作，例如config、add、commit等。如果不知道有哪些verb，可以输入<code>git help -a</code>，查看git的所有命令。</p><p>例如想要获取<code>git config</code>命令的手册，执行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">help</span> config</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2023/10/13/git-study-1/image-20231013170115289.png" alt="image-20231013170115289"></p><p>其中的命令语法参数，我将其大致分为 <strong>固定字符</strong>、<strong>动态字符</strong>、<strong>可选字符</strong>。</p><ul><li>固定字符：例如 <code>git</code> 、<code>config</code>、<code>--get-all</code>、<code>--type</code>、<code>-z</code>等。</li><li>动态字符：由<code>&lt;&gt;</code>括起来的参数就表示动态字符。例如<code>&lt;file-option&gt;</code>指输入指定配置文件名、<code>&lt;name&gt;</code>指config的参数名。</li><li>可选字符：由<code>[]</code>括起来的参数就表示可选字符，它不是必须输入的。例如<code>[file-option]</code>不指定时，git会配置文件的优先级选择对应的配置文件。</li></ul><br><p>使用<code>git config &lt;verb&gt;</code>获取的是全面的手册，如果只需要可用选项的快速参考，那么可以用 <code>-h</code> 选项获得更简明的帮助文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config -h</span></span><br><span class="line">usage: git config [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">Config file location</span><br><span class="line">    --global              use global config file</span><br><span class="line">    --system              use system config file</span><br><span class="line">    --local               use repository config file</span><br><span class="line">    --worktree            use per-worktree config file</span><br><span class="line">    -f, --file &lt;file&gt;     use given config file</span><br><span class="line">    --blob &lt;blob-id&gt;      read config from given blob object</span><br><span class="line"></span><br><span class="line">Action</span><br><span class="line">    --get                 get value: name [value-pattern]</span><br><span class="line">    --get-all             get all values: key [value-pattern]</span><br><span class="line">    --get-regexp          get values for regexp: name-regex [value-pattern]</span><br><span class="line">    --get-urlmatch        get value specific for the URL: section[.var] URL</span><br><span class="line">    --replace-all         replace all matching variables: name value [value-pattern]</span><br><span class="line">    --add                 add a new variable: name value</span><br><span class="line">    --unset               remove a variable: name [value-pattern]</span><br><span class="line">    --unset-all           remove all matches: name [value-pattern]</span><br><span class="line">    --rename-section      rename section: old-name new-name</span><br><span class="line">    --remove-section      remove a section: name</span><br><span class="line">    -l, --list            list all</span><br><span class="line">    --fixed-value         use string equality when comparing values to &#x27;value-pattern&#x27;</span><br><span class="line">    -e, --edit            open an editor</span><br><span class="line">    --get-color           find the color configured: slot [default]</span><br><span class="line">    --get-colorbool       find the color setting: slot [stdout-is-tty]</span><br><span class="line"></span><br><span class="line">Type</span><br><span class="line">    -t, --type &lt;type&gt;     value is given this type</span><br><span class="line">    --bool                value is &quot;true&quot; or &quot;false&quot;</span><br><span class="line">    --int                 value is decimal number</span><br><span class="line">    --bool-or-int         value is --bool or --int</span><br><span class="line">    --bool-or-str         value is --bool or string</span><br><span class="line">    --path                value is a path (file or directory name)</span><br><span class="line">    --expiry-date         value is an expiry date</span><br><span class="line"></span><br><span class="line">Other</span><br><span class="line">    -z, --null            terminate values with NUL byte</span><br><span class="line">    --name-only           show variable names only</span><br><span class="line">    --includes            respect include directives on lookup</span><br><span class="line">    --show-origin         show origin of config (file, standard input, blob, command line)</span><br><span class="line">    --show-scope          show scope of config (worktree, local, global, system, command)</span><br><span class="line">    --default &lt;value&gt;     with --get, use default value when missing entry</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot之Tomcat初始化过程的源码分析</title>
      <link href="/2023/10/08/springboot-tomcat-initialize/"/>
      <url>/2023/10/08/springboot-tomcat-initialize/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a class="header-anchor" href="#环境准备"></a>环境准备</h2><p>新建一个maven项目，引入 spring-boot-starter-web 依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.7</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>整个项目就只有如下一个类，用于SpringBoot应用程序的启动类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootApplicationDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootApplicationDemo.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>运行内容如下：</p><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008155355468.png" alt="image-20231008155355468"></p><p>从运行结果可以看出，SpringBoot启动了Tomcat服务，端口为8080，版本号为9.0.65。</p><h2 id="源码分析"><a class="header-anchor" href="#源码分析"></a>源码分析</h2><h3 id="SpringBoot初始化Tomcat服务的主流程"><a class="header-anchor" href="#SpringBoot初始化Tomcat服务的主流程"></a>SpringBoot初始化Tomcat服务的主流程</h3><ol><li>分析源码的入口就从日志出发，打印 &quot;Tomcat initialized with port(s): 8080 (http)&quot; 的类为 <code>TomcatWebServer</code>，全局搜索进入到该类，并找到这句话的代码位置。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008160529757.png" alt="image-20231008160529757"></p><p>从图中可以看出，日志只在 <code>initialize</code> 方法中出现过，并且该方法只被构造方法所调用，那么就看何时调用的该构造方法。</p><blockquote><p>注意观察 <code>TomcatWebServer</code> 的所在包（spring-boot-2.7.2.jar），说明该类是SpringBoot自己内嵌实现的，通过类的包名也可以大致猜到。org.springframework.boot是SpringBoot项目的根路径，web表示是一个web服务，embedded表示嵌入式，说明该web服务被内嵌到SpringBoot项目中了，tomcat是实现web服务的一种。</p></blockquote><ol start="2"><li>一步一步的往上看调用链，是<code>TomcatServletWebServerFactory</code>类的<code>getTomcatWebServer</code>方法实例化了 <code>TomcatWevServer</code>对象。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008161353363.png" alt="image-20231008161353363"></p><ol start="3"><li>而<code>getTomcatWebServer</code>方法是由内部的<code>getWebServer</code>方法所调用，<code>getWebServer</code>方法在调用前，实例化一个了<code>Tomcat</code>对象，并作为入参传递。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008161538986.png" alt="image-20231008161538986"></p><ol start="4"><li><p><code>getWebServer</code>方法则是由<code>ServletWebServerApplicationContext</code>类的<code>createWebServer</code>方法调用。</p><p>从图中可以看出，<code>createWebServer</code>方法先通过内部的<code>getWebServerFactory</code>方法获取的<code>TomcatServletWebServerFactory</code>对象，再通过<code>ServletWebServerFactory</code>接口对象调用<code>getWebServer</code>方法。</p></li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008162124639.png" alt="image-20231008162124639"></p><blockquote><p><code>ServletWebServerApplicationContext</code>的包路径为 org.springframework.boot.web.servlet.context 。</p></blockquote><p>从这里开始，源码分析就分为了两条线路。第一条，<code>getWebServerFactory</code>是如何获取到的<code>TomcatServletWebServerFactory</code>对象；第二条，就是源码分析的主线路，<code>createWebServer</code>方法的上层调用链是哪。</p><p>为了保证主线路的思路不中断，第一条疑问先暂时忽略。</p><ol start="5"><li><code>createWebServer</code>方法是由内部的<code>onRefresh</code>方法所调用。<code>onRefresh</code>方法是重写的父类<code>GenericWebApplicationContext</code>的方法，而父类是继承的<code>AbstractApplicationContext</code>抽象类。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008163113257.png" alt="image-20231008163113257"></p><ol start="6"><li>看到<code>AbstractApplicationContext</code>类，就可以猜到是Spring初始化上下文时构造的对象。所以现在就需要从<code>SpringApplication#run</code>入口开始分析。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008164245201.png" alt="image-20231008164245201"></p><ol start="7"><li><code>createApplicationContext</code>方法就是实例化<code>ConfigurableApplicationContext</code>对象的入口，这个方法使用了两个变量：<code>applicationContextFactory</code> 和 <code>webApplicationType</code>，对于这两个变量值的来源先暂时不管。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008164323793.png" alt="image-20231008164323793"></p><ol start="8"><li>再根据猜想，<code>applicationContextFactory</code>的实例对象是 <code>AnnotationConfigServletWebServerApplicationContext.Factory</code>，其<code>create</code>方法实例化了<code>AnnotationConfigServletWebServerApplicationContext</code>对象。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008165537906.png" alt="image-20231008165537906"></p><p><code>AnnotationConfigServletWebServerApplicationContext</code>类继承了<code>ServletWebServerApplicationContext</code>类。</p><p>回到第5步，<code>AbstractApplicationContext</code>的实现对象以及实现位置就算是找到了。再看何时调用的<code>onRefresh</code>方法。</p><ol start="9"><li>回到第6步，图中提到了<code>refreshContext</code>方法，其调用了内部的<code>refresh</code>方法。<code>refresh</code>方法则又调用了<code>ConfigurableApplicationContext</code>的<code>refresh</code>方法。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008170009513.png" alt="image-20231008170009513"></p><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008170125128.png" alt="image-20231008170125128"></p><ol start="10"><li>在第8步中，已经知道<code>ConfigurableApplicationContext</code>的实现类是<code>AnnotationConfigServletWebServerApplicationContext</code>，其父类为<code>ServletWebServerApplicationContext</code>，所以这里的<code>applicationContext.refresh()</code>方法是进入到了<code>ServletWebServerApplicationContext#refresh()</code>方法中。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008170433552.png" alt="image-20231008170433552"></p><p>其内部又调用了父类<code>AbstractApplicationContext</code>的<code>refresh</code>方法。</p><ol start="11"><li><code>AbstractApplicationContext#refresh</code>方法调用了内部的<code>onRefresh</code>方法，根据方法重写，实际是调用了<code>ServletWebServerApplicationContext#onRefresh</code>方法。至此，就对接上了第5步的主线路。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231008171426624.png" alt="image-20231008171426624"></p><p>主流程调用链路总结如下：</p><p>-&gt; SpringApplication#run(Class&lt;?&gt; primarySource, String... args)</p><p>-&gt; ConfigurableApplicationContext#refresh()</p><p>-&gt; ServletWebServerApplicationContext#onRefresh()</p><p>-&gt; ServletWebServerApplicationContext#createWebServer()</p><p>-&gt; TomcatServletWebServerFactory#getWebServer(ServletContextInitializer... initializers)</p><p>-&gt; TomcatServletWebServerFactory#getTomcatWebServer(Tomcat tomcat)</p><p>-&gt; TomcatWebServer#initialize()</p><h3 id="获取WebServer工厂对象"><a class="header-anchor" href="#获取WebServer工厂对象"></a>获取WebServer工厂对象</h3><p>出现在主流程的第4步，入口为：ServletWebServerApplicationContext#getWebServerFactory</p><ol><li><code>getWebServerFactory</code>方法是直接从Spring IOC容器中获取类型为<code>ServletWebServerFactory</code>的Bean，要求Bean的个数必须有且仅有一个。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009153300480.png" alt="image-20231009153300480"></p><ol start="2"><li>查看<code>ServletWebServerFactory</code>的实现类，可以发现都是SpringBoot内嵌实现的，包含有Jetty、Tomcat、Undertow。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009153536791.png" alt="image-20231009153536791"></p><p>进入到<code>TomcatServletWebServerFactory</code>类下，通过IDEA没法找到在何处引用到它（因为IDEA只搜索当前jar包）。</p><ol start="4"><li>既然如此，就直接启动程序，开启debug模式，在<code>TomcatServletWebServerFactory</code>类的构造方法上打上断点。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009155122871.png" alt="image-20231009155122871"></p><ol start="5"><li>查看上一层调用链，发现了一个新类<code>ServletWebServerFactoryConfiguration</code>，它处在于spring-boot-autoconfigure-2.7.2.jar下。</li></ol><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009155306802.png" alt="image-20231009155306802"></p><ol start="6"><li>观察<code>ServletWebServerFactoryConfiguration</code>类，它是通过条件装配扫描到了<code>TomcatServletWebServerFactory</code>，而Jetty和Undertow因为扫描顺序和条件判断的问题被忽略。</li></ol><blockquote><p>需要注意的是，在只引入spring-boot-starter-web依赖包的情况下，SpringBoot默认只支持Tomcat容器，Jetty和Undertow需要单独引入pom依赖。</p></blockquote><p>pom依赖参考如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 如果需要使用内嵌的Jetty或Undertow，就需要排除web包里面的tomcat依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Jetty --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Undertow --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ApplicationContextFactory和WebApplicationType来源"><a class="header-anchor" href="#ApplicationContextFactory和WebApplicationType来源"></a>ApplicationContextFactory和WebApplicationType来源</h3><p>出现在主流程的第7步，入口为：SpringApplication#createApplicationContext</p><h4 id="ApplicationContextFactory"><a class="header-anchor" href="#ApplicationContextFactory"></a>ApplicationContextFactory</h4><p><code>ApplicationContextFactory</code>是一个FunctionalInterface接口类，它具有默认实现类。</p><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009172433701.png" alt="image-20231009172433701"></p><p>默认实现类通过Spring的SPI机制加载指定类，并根据入参值决定使用哪个类。</p><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009172603997.png" alt="image-20231009172603997"></p><p>Spring Boot指定了两个<code>ApplicationContextFactory</code>实现类，分为Reactive和Servlet。</p><h4 id="WebApplicationType"><a class="header-anchor" href="#WebApplicationType"></a>WebApplicationType</h4><p><code>webApplicationType</code>变量赋值入口有两个，分别是SpringApplication的构造方法和setter方法。</p><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009172917167.png" alt="image-20231009172917167"></p><p>在本项目的示例中，采用的是最基本的SpringApplication#run方式启动，没有经过setter方法，从run方法一路debug下来，也可以发现<code>webApplicationType</code>是在实例化时进行的赋值操作。</p><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009173234092.png" alt="image-20231009173234092"></p><p>再看<code>WebApplicationType.deduceFromClasspath()</code>方法，它其实就是通过访问指定全量路径类是否存在，判断<code>WebApplicationType</code>类型。</p><p><img src="/2023/10/08/springboot-tomcat-initialize/image-20231009173327996.png" alt="image-20231009173327996"></p><h3 id="Tomcat服务启动过程"><a class="header-anchor" href="#Tomcat服务启动过程"></a>Tomcat服务启动过程</h3><p>Tomcat服务启动主要是经历 <code>initialize()</code> 和 <code>start()</code> 两个步骤。</p><h4 id="initialize"><a class="header-anchor" href="#initialize"></a>initialize()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException &#123;</span><br><span class="line">   logger.info(<span class="string">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class="literal">false</span>));</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.monitor) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 维护一个实例id到Tomcat引擎中</span></span><br><span class="line">         addInstanceIdToEngineName();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取Tomcat上下文</span></span><br><span class="line">         <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> findContext();</span><br><span class="line">         <span class="comment">// 给Tomcat上下文中添加一个生命周期监听器</span></span><br><span class="line">         context.addLifecycleListener((event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class="line">               <span class="comment">// Remove service connectors so that protocol binding doesn&#x27;t</span></span><br><span class="line">               <span class="comment">// happen when the service is started.</span></span><br><span class="line">               removeServiceConnectors();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 启动Tomcat服务器，并触发初始化侦听器</span></span><br><span class="line">         <span class="built_in">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将Tomcat启动时的异常抛出。用于判断Tomcat服务器状态是否为已启动</span></span><br><span class="line">         rethrowDeferredStartupExceptions();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Tomcat上下文的缓存绑定当前ClassLoader</span></span><br><span class="line">            ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (NamingException ex) &#123;</span><br><span class="line">            <span class="comment">// Naming is not enabled. Continue</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 创建并启动一个非守护线程。用于阻塞主线程结束</span></span><br><span class="line">         startDaemonAwaitThread();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         stopSilently();</span><br><span class="line">         destroySilently();</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WebServerException</span>(<span class="string">&quot;Unable to start embedded Tomcat&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码分析，可以发现，Tomcat在初始化时就已经启动了服务器，并内置有生命周期监听器，还创建了一个阻塞非守护线程。</p><h4 id="start"><a class="header-anchor" href="#start"></a>start()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.monitor) &#123;</span><br><span class="line">      <span class="comment">// 判断是否Tomcat服务器已启动</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.started) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 将已启动的连接从缓存移除</span></span><br><span class="line">         addPreviouslyRemovedConnectors();</span><br><span class="line">         <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="built_in">this</span>.tomcat.getConnector();</span><br><span class="line">         <span class="keyword">if</span> (connector != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.autoStart) &#123;</span><br><span class="line">            <span class="comment">// 执行延期启动的程序</span></span><br><span class="line">            performDeferredLoadOnStartup();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 检查Tomcat连接是否已启动</span></span><br><span class="line">         checkThatConnectorsHaveStarted();</span><br><span class="line">         <span class="comment">// 将Tomcat服务器设置为已启动状态</span></span><br><span class="line">         <span class="built_in">this</span>.started = <span class="literal">true</span>;</span><br><span class="line">         logger.info(<span class="string">&quot;Tomcat started on port(s): &quot;</span> + getPortsDescription(<span class="literal">true</span>) + <span class="string">&quot; with context path &#x27;&quot;</span></span><br><span class="line">               + getContextPath() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ConnectorStartFailedException ex) &#123;</span><br><span class="line">         stopSilently();</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         PortInUseException.throwIfPortBindingException(ex, () -&gt; <span class="built_in">this</span>.tomcat.getConnector().getPort());</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WebServerException</span>(<span class="string">&quot;Unable to start embedded Tomcat server&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> findContext();</span><br><span class="line">         ContextBindings.unbindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TomcatWebServer#start()</code>是通过Spring应用上下文的生命周期刷新事件触发的，在Spring启动阶段的<code>finishRefresh</code>阶段。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><ul><li><p>SpringBoot应用程序是如何启动Tomcat服务器的？</p><p>答：在Spring启动时，通过应用上下文调用refresh方法触发Tomcat服务启动。回看<em><strong>SpringBoot初始化Tomcat服务的主流程</strong></em>章节。</p></li><li><p>Tomcat服务器是何时启动的？</p><p>答：在Spring启动时初始化Tomcat Web服务对象时就启动了，最后在Spring启动的finishRefresh阶段被标注为已启动。回看<em><strong>Tomcat服务器启动过程</strong></em>章节。</p></li><li><p>SpringBoot Web服务是怎样做到Java程序不结束退出的。</p><p>答：做到Java程序不结束退出这一点是由Web服务实现方决定的，以Tomcat举例，在Tomcat服务器初始化时，创建了一个阻塞非守护线程，阻止了主线程的退出。回看<em><strong>Tomcat服务启动过程</strong></em>章节的initialize方法。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java获取资源文件的输入流</title>
      <link href="/2023/10/07/java-io-resource/"/>
      <url>/2023/10/07/java-io-resource/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-中获取资源文件输入流的方法"><a class="header-anchor" href="#Java-中获取资源文件输入流的方法"></a>Java 中获取资源文件输入流的方法</h2><p>方法一：利用线程的类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>像 Tomcat 之类的容器，使用了自定义类加载器加载 jar 包。下面的方法可能会失效，但方法一仍然可用。</p></blockquote><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br></pre></td></tr></table></figure><p>方法四：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> A.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>前四种方法都是在类路径下查找文件。</strong></p><p>方法五：(<strong>第五种方法是在 A.class 所在目录下查找文件。</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> A.class.getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br></pre></td></tr></table></figure><p>方法六：IO 流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Module0/src/jdbc.properties&quot;</span>)   <span class="comment">// 或</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/Module0/src/jdbc.properties&quot;</span>)</span><br></pre></td></tr></table></figure><p>第六种方法适用于资源文件不在类路径下的情况，例如，资源文件未打入 jar 包内，而是放在 jar 外。</p><h2 id="ClassLoader-的-getResource-和-getResources-的区别"><a class="header-anchor" href="#ClassLoader-的-getResource-和-getResources-的区别"></a>ClassLoader 的 getResource 和 getResources 的区别</h2><p>假设 a.jar 依赖 b.jar。它俩的类路径下都有一个 app.properties 文件。</p><p>在 a.jar 执行下面的代码，或在运行 a.jar 时，间接执行了 b.jar 中的下面代码，得到的都是 a.jar 的 app.properties 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">resource</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResource(<span class="string">&quot;app.properties&quot;</span>);</span><br><span class="line">System.out.println(resource);</span><br><span class="line"><span class="comment">// 输出：a.jar!/app.properties</span></span><br></pre></td></tr></table></figure><p>在 a.jar 执行下面的代码，或在运行 a.jar 时，间接执行了 b.jar 中的下面代码，会同时得到 a.jar 的 app.properties 文件，和 b.jar 的 app.properties 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; resources = ClassLoader.getSystemClassLoader().getResources(<span class="string">&quot;app.properties&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (resources.hasMoreElements()) &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> resources.nextElement();</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a.jar!/app.properties</span></span><br><span class="line"><span class="comment">// b.jar!/app.properties</span></span><br></pre></td></tr></table></figure><p>getResources 有一个差不多的流式 API：resources。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().resources(<span class="string">&quot;app.properties&quot;</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="Properties"><a class="header-anchor" href="#Properties"></a>Properties</h2><p>在 Java 中经常使用如下方法获取配置项：</p><p>新建一个 Properties 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br></pre></td></tr></table></figure><p>使用 load() 方法，将文本文件中的内容加载到 props 对象中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.load(InputStream inStream);  <span class="comment">// 入参是一个字节输入流对象</span></span><br></pre></td></tr></table></figure><p>使用 getProperty() 方法，获取属性值：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props.getProperty(&quot;jdbc.driver&quot;) </span><br><span class="line">// 或：props.getProperty(&quot;jdbc.driver&quot;, &quot;com.mysql.cj.jdbc.Driver&quot;) </span><br><span class="line">// 第二个参数是在第一个参数找不到的情况下返回的值</span><br></pre></td></tr></table></figure><h2 id="ResourceBundle"><a class="header-anchor" href="#ResourceBundle"></a>ResourceBundle</h2><p>Java 提供了一个 ResourceBundle 类。</p><p>该类有一个静态方法 getBundle()，可以用来获取 ResourceBundle 对象。</p><p>getBundle() 在类路径下查找资源。</p><p>例如，类路径下有如下文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config</span><br><span class="line">    |-- jdbc.properties       // 这三个文件会被当做一个 ResourceBundle。</span><br><span class="line">    |-- jdbc_zh_CN.properties</span><br><span class="line">    |-- jdbc_en_US.properties</span><br></pre></td></tr></table></figure><p>获取 ResourceBundle 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResourceBundle</span> <span class="variable">jdbc</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;config.jdbc&quot;</span>); <span class="comment">// 目录可以用句点或斜杠分隔</span></span><br></pre></td></tr></table></figure><p>获取 ResourceBundle 对象后，可以使用它的 getString() 方法获取属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> jdbc.getString(<span class="string">&quot;jdbc.driver&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
            <tag> InputStream </tag>
            
            <tag> Properties </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA Java项目的目录结构为什么要是 src/main/java 形式?</title>
      <link href="/2023/10/07/java-project-structure/"/>
      <url>/2023/10/07/java-project-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="起源"><a class="header-anchor" href="#起源"></a>起源</h2><p>每次新建项目时，都很好奇为什么Java文件需要放到项目下的 <code>src/main/java</code> 下？</p><p>Interllij IDEA 仿佛自带“魔力”，在项目下新建目录时，会自动提示还未存在的目录结构（Maven Source Directories），并提供一键新建目录功能。</p><p><img src="/2023/10/07/java-project-structure/image-20231007111209185.png" alt="image-20231007111209185"></p><h2 id="解释"><a class="header-anchor" href="#解释"></a>解释</h2><h3 id="Maven项目目录结构的解释"><a class="header-anchor" href="#Maven项目目录结构的解释"></a>Maven项目目录结构的解释</h3><p>关于Maven项目的Maven Source Directories的解释：</p><ul><li>src：翻译为source，表示源代码目录的根目录。</li><li>main：表示主要的代码目录，用于存放项目的主要功能代码。</li><li>java：表示Java代码的目录，用于存放Java类和包。</li><li>src/test/java：提供一个专门的位置用于编写和管理项目的单元测试、集成测试或其他类型的测试代码。</li><li>src/test/resources：提供一个专门的位置，用于存放测试过程中所需的资源文件。</li></ul><p>总结：这种目录结构其实是一种约定，src/main/java是一种常见的源代码目录结构约定，它遵循了Maven项目的标准布局。而idea内置功能在识别到项目为maven项目时，做新建目录操作时就会按照约定提供一键新建目录功能。</p><p>需要注意的是，src/main/java只是一种约定，并非强制规定。在某些特定情况下，可以根据项目需求进行自定义的目录结构，但建议遵循这种约定以保持代码的一致性和可读性。</p><h3 id="常见的源代码目录结构约定"><a class="header-anchor" href="#常见的源代码目录结构约定"></a>常见的源代码目录结构约定</h3><ol><li><strong>src/main/kotlin</strong>：用于Kotlin项目的源代码目录。与Java项目的约定类似，Kotlin项目通常将源代码放在<code>src/main/kotlin</code>目录下。</li><li><strong>src/main/scala</strong>：用于Scala项目的源代码目录。Scala是一种运行在Java虚拟机上的编程语言，它也有类似于Java和Kotlin的目录结构约定。</li><li><strong>src/main/python</strong>：用于Python项目的源代码目录。Python项目通常将源代码放在<code>src/main/python</code>目录下，以区分其他类型的文件，例如配置文件或测试代码。</li><li><strong>src/main/resources</strong>：用于存放项目的资源文件，如配置文件、静态文件、模板等。这个目录通常与源代码目录（如<code>src/main/java</code>）平行存在。</li><li><strong>src/test/java</strong>：用于存放测试代码的目录。测试代码通常位于<code>src/test/java</code>目录下，它与主要代码目录（如<code>src/main/java</code>）有类似的结构。</li><li><strong>src/test/resources</strong>：用于存放测试所需的资源文件，例如测试数据、配置文件等。与测试代码目录（如<code>src/test/java</code>）平行存在。</li></ol><h2 id="实测"><a class="header-anchor" href="#实测"></a>实测</h2><h3 id="src-main-java中的Java代码如何获取到src-main-resources下的文件信息"><a class="header-anchor" href="#src-main-java中的Java代码如何获取到src-main-resources下的文件信息"></a>src/main/java中的Java代码如何获取到src/main/resources下的文件信息</h3><p>目前项目的目录结构如下，有一个Java类（<code>ProjectStructure</code>）、一个resource资源文件（<code>jdbc.properties</code>）。</p><p><img src="/2023/10/07/java-project-structure/image-20231007112957213.png" alt="image-20231007112957213"></p><p><code>jdbc.properties</code> 文件信息如下：</p><p><img src="/2023/10/07/java-project-structure/image-20231007113114109.png" alt="image-20231007113114109"></p><p>现在想从<code>ProjectStructure</code>类中获取 <code>jdbc.properties</code> 文件的 jdbc.driver 属性值，Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 注意路径的写法 </span></span><br><span class="line">  props.load(ProjectStructure.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;jdbc.driver&quot;</span>);</span><br><span class="line">    System.out.println(driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="/2023/10/07/java-project-structure/image-20231007113754889.png" alt="image-20231007113754889"></p><p>结论：</p><ol><li>IDEA 中的所有文件（包括 Java 程序文件和资源文件）都是从“项目根目录”开始查找的。</li><li>Java 程序文件除了从“项目根目录”查找，还会从“类路径”查找。</li></ol><blockquote><p>Java获取资源文件信息的方法：<a href="https://blog.itwray.com/2023/10/07/java-io-resource/">Java如何获取资源文件的输入流</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Idea </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AspectJ之Execution表达式</title>
      <link href="/2023/09/26/aop-aspectj-execution/"/>
      <url>/2023/09/26/aop-aspectj-execution/</url>
      
        <content type="html"><![CDATA[<h2 id="Execution表达式语法"><a class="header-anchor" href="#Execution表达式语法"></a>Execution表达式语法</h2><p>在AspectJ中，Execution表达式用于定义切点，即指定在何处应用切面逻辑。Execution表达式可以在AspectJ注解或XML配置中使用。</p><p>Execution表达式的语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</span><br></pre></td></tr></table></figure><p>语法说明：带?的部分表示可省略，只看必须参数的话，语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(ret-type-pattern name-pattern(param-pattern))</span><br></pre></td></tr></table></figure><p>Execution表达式的各个部分的说明：</p><ul><li><code>modifiers-pattern</code>：可选项，用于指定方法的修饰符模式，如<code>public</code>、<code>private</code>、<code>protected</code>等。</li><li><code>ret-type-pattern</code>：可选项，用于指定方法的返回类型模式，如<code>void</code>、<code>int</code>、<code>java.util.List</code>等。可以使用<code>*</code>通配符匹配任意返回类型。</li><li><code>declaring-type-pattern</code>：可选项，用于指定方法所在类的模式。可以使用<code>*</code>通配符匹配任意类。</li><li><code>name-pattern</code>：用于指定方法名的模式，可以使用<code>*</code>通配符匹配任意方法名。</li><li><code>param-pattern</code>：用于指定方法参数的模式。可以使用<code>*</code>通配符匹配任意参数类型，也可以使用<code>..</code>表示匹配任意数量的参数。</li><li><code>throws-pattern</code>：可选项，用于指定方法抛出异常的模式。</li></ul><blockquote><p>从语法各部分的说明可以看出，execution表达式可以只带有 方法的返回类型 + 方法名 + 方法参数 ，这也是Java方法定义的最基本元素。</p></blockquote><h2 id="Execution扩展语法"><a class="header-anchor" href="#Execution扩展语法"></a>Execution扩展语法</h2><p>关于AspectJ的Execution表达式的一些额外细节：</p><ol><li>通配符（Wildcards）：Execution表达式中的通配符<code>*</code>用于匹配任意字符或任意数量的字符。可以在修饰符、返回类型、类名、方法名和参数类型等位置使用通配符来进行模式匹配。例如，<code>execution(public * *(..))</code>匹配所有公共方法，<code>execution(* com.example.*.*(..))</code>匹配指定包名下的所有方法。</li><li>参数模式（Parameter Patterns）：Execution表达式中的参数模式用于指定方法的参数类型。可以使用具体的类型来匹配特定的参数，也可以使用通配符<code>*</code>匹配任意类型。另外，使用<code>..</code>表示匹配任意数量的参数。例如，<code>execution(* *(com.example.MyClass))</code>匹配具有一个类型为<code>com.example.MyClass</code>的参数的所有方法，<code>execution(* *(..))</code>匹配任意参数类型的方法。</li><li>异常模式（Exception Patterns）：Execution表达式中的异常模式用于指定方法可能抛出的异常类型。可以使用具体的异常类型进行匹配，也可以使用通配符<code>*</code>匹配任意异常类型。例如，<code>execution(* *(..) throws Exception)</code>匹配所有可能抛出<code>Exception</code>类型异常的方法。</li><li>组合模式（Combining Patterns）：Execution表达式允许将多个模式组合在一起，以便更精确地匹配方法。可以使用逻辑运算符<code>&amp;&amp;</code>（与）、<code>||</code>（或）和<code>!</code>（非）来组合不同的模式。例如，<code>execution(public * *(..)) &amp;&amp; !execution(* get*(..))</code>匹配所有公共方法，但排除以&quot;get&quot;开头的方法。</li></ol><h2 id="Execution常用表达式"><a class="header-anchor" href="#Execution常用表达式"></a>Execution常用表达式</h2><ul><li><p>匹配所有公共方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配返回类型为<code>int</code>的所有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="type">int</span> * *(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配指定类中的所有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.example.MyClass.*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配指定类及其子类中的所有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.example.MyClass+.*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配指定方法名以&quot;get&quot;开头的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* get*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配指定参数类型的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* *(com.example.MyClass))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> AOP </tag>
            
            <tag> AspectJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解SAAS、PAAS、IAAS</title>
      <link href="/2023/09/25/other-software-saas/"/>
      <url>/2023/09/25/other-software-saas/</url>
      
        <content type="html"><![CDATA[<h2 id="SAAS（软件即服务）"><a class="header-anchor" href="#SAAS（软件即服务）"></a>SAAS（软件即服务）</h2><h3 id="概念"><a class="header-anchor" href="#概念"></a>概念</h3><p>SAAS是指软件即服务（Software as a Service）的缩写。它是一种云计算服务模型，通过互联网提供软件应用程序作为服务。</p><p>在SAAS模型中，软件供应商将应用程序部署在云平台上，并通过互联网提供给用户使用。用户可以通过各种终端设备（如个人电脑、智能手机、平板电脑等）通过网络访问和使用这些应用程序，而无需在本地安装和维护软件。</p><h3 id="优势"><a class="header-anchor" href="#优势"></a>优势</h3><p>SAAS模型的优势包括：</p><ul><li><p>可即时使用：用户无需购买、安装和配置软件，只需通过网络即可立即使用。</p></li><li><p>资源集中管理：软件供应商负责软件的部署、维护和更新，用户无需担心软件的管理和运维事务。</p></li><li><p>可按需扩展：用户可以根据需要灵活地增加或减少订阅的用户数或服务规模，以适应业务的变化。</p></li><li><p>跨平台和设备：SAAS应用程序通常支持多种终端设备，用户可以在不同的设备上无缝访问和使用。</p></li><li><p>降低成本：相对于传统的软件购买和部署模式，SAAS模型以订阅费或使用费的方式付费，可以降低初始投入和运营成本。</p></li></ul><h3 id="适用场景"><a class="header-anchor" href="#适用场景"></a>适用场景</h3><p>常见的SAAS应用包括客户关系管理（CRM）、企业资源规划（ERP）、人力资源管理（HRM）、在线办公工具、协作软件等。</p><h2 id="PAAS（平台即服务）"><a class="header-anchor" href="#PAAS（平台即服务）"></a>PAAS（平台即服务）</h2><h3 id="概念-2"><a class="header-anchor" href="#概念-2"></a>概念</h3><p>PAAS代表平台即服务（Platform as a Service）。它是一种云计算服务模型，为开发人员提供了一个完整的应用程序开发和部署平台。</p><p>在PAAS模型中，云服务提供商负责提供基础设施、操作系统和一系列开发工具、框架以及相关的服务，开发人员可以利用这些工具和平台来构建、测试、部署和托管应用程序，而无需关注底层的基础设施和操作系统的细节。</p><p>PAAS模型的特点包括：</p><ul><li><p>应用程序开发平台：PAAS提供了开发人员所需的开发工具、编程语言支持、库和框架等，使开发人员能够更高效地构建应用程序。</p></li><li><p>自动化部署和扩展：PAAS提供了自动化的应用程序部署和扩展功能，开发人员可以根据需求快速部署应用程序，并根据流量和负载的变化自动扩展应用程序的资源。</p></li><li><p>资源管理和监控：PAAS提供了资源管理和监控工具，开发人员可以监控应用程序的性能、运行状态和资源使用情况，以便进行优化和调整。</p></li><li><p>多租户架构：PAAS平台通常是多租户架构，多个开发团队可以共享同一平台，并独立开发、部署和管理自己的应用程序。</p></li><li><p>服务集成和生态系统：PAAS提供了各种服务和API，用于集成其他云服务（如数据库、消息队列、身份认证等）和第三方服务，以满足应用程序的需求。</p></li></ul><h3 id="优势-2"><a class="header-anchor" href="#优势-2"></a>优势</h3><p>PAAS模型的优势包括：</p><ul><li>提高开发效率：开发人员可以专注于应用程序的开发而无需关注底层基础设施的管理。</li><li>简化部署和扩展：PAAS提供了自动化的部署和扩展功能，使应用程序的部署和扩展变得更加简单和快速。</li><li>降低成本和风险：开发人员无需购买和维护基础设施，只需支付使用的平台和服务，降低了初始投资和运营成本，并减少了技术风险。</li></ul><h3 id="适用场景-2"><a class="header-anchor" href="#适用场景-2"></a>适用场景</h3><p>常见的PAAS平台包括Google App Engine、Microsoft Azure App Service、Heroku、IBM Cloud Foundry等。</p><p>国内的PAAS平台例如阿里云，其提供的容器服务、函数计算、云数据库、消息队列、日志服务等都是PAAS服务。阿里云是一个总的概念，PAAS服务只是其中一部分。</p><h2 id="IAAS（基础设施即服务）"><a class="header-anchor" href="#IAAS（基础设施即服务）"></a>IAAS（基础设施即服务）</h2><h3 id="概念-3"><a class="header-anchor" href="#概念-3"></a>概念</h3><p>IAAS代表基础设施即服务（Infrastructure as a Service）。它是一种云计算服务模型，提供了基础的计算资源和基础设施，如虚拟机、存储、网络等，以供用户使用和管理。</p><p>在IAAS模型中，云服务提供商负责提供和管理基础设施层，包括硬件设备、服务器、虚拟化技术等。用户可以根据自己的需求，在云平台上创建、配置和管理虚拟机实例，并通过网络访问这些实例。用户对操作系统、中间件、应用程序和数据的管理和控制权通常更高。</p><p>IAAS模型的特点包括：</p><ul><li>虚拟化资源：IAAS提供了虚拟化技术，用户可以通过虚拟机实例来访问计算、存储和网络资源，以满足其应用程序和业务的需求。</li><li>弹性扩展：用户可以根据需要动态扩展或缩减所使用的资源，以适应不同的工作负载和流量需求。</li><li>自助服务：用户可以通过自助服务界面或API来管理和配置虚拟机实例，包括创建、启动、停止、备份等操作，无需人工干预。</li><li>按需付费：用户按照他们所使用的资源量和时间进行计费，可以根据实际需求弹性地调整资源的使用量，降低了成本和浪费。</li><li>灵活性和可定制性：用户可以根据自己的需求自由选择操作系统、应用程序和配置，以满足其特定的业务要求。</li></ul><h3 id="优势-3"><a class="header-anchor" href="#优势-3"></a>优势</h3><p>IAAS的优势包括如下：</p><ul><li>灵活性和弹性扩展：IAAS模型允许用户根据需求快速扩展或缩减其基础设施资源。用户可以根据实际需求动态调整计算、存储和网络资源的使用量，以适应不同的工作负载和流量需求。</li><li>资源的按需使用和付费：用户可以根据实际使用情况，按需使用云服务提供商提供的计算资源，避免了不必要的资源浪费。此外，用户通常按照他们所使用的资源量和时间进行付费，从而降低了成本。</li><li>硬件和基础设施维护：在IAAS模型中，云服务提供商负责硬件设备、服务器和基础设施的维护和管理。用户无需关注硬件的购买、安装、维护和更新等问题，可以将精力集中在应用程序的开发和管理上。</li><li>快速部署和灵活性：IAAS模型提供了快速部署和配置基础设施的能力。用户可以通过自助服务界面或API快速创建、配置和管理虚拟机实例、存储空间和网络资源等。这种灵活性使用户能够快速响应业务需求，并快速启动新项目或应用程序。</li><li>可定制性和控制权：IAAS模型允许用户根据自己的需求选择操作系统、应用程序、配置和安全设置等。用户拥有更高的控制权和可定制性，以满足其特定的业务要求。</li><li>可靠性和高可用性：云服务提供商通常提供高可用性和容错机制，以确保用户的基础设施和应用程序在面对故障或意外情况时保持可用。这包括数据备份、容灾方案和自动故障恢复等。</li></ul><p>总的来说，IAAS模型提供了灵活、弹性和可定制的基础设施服务，使用户能够以更高效和经济的方式构建、管理和扩展他们的应用程序和服务。它减轻了硬件和基础设施管理的负担，提供了更高的灵活性和控制权，同时降低了成本和复杂性。</p><h3 id="适用场景-3"><a class="header-anchor" href="#适用场景-3"></a>适用场景</h3><p>阿里云的弹性计算服务（如云服务器ECS）、对象存储服务（如对象存储OSS）、弹性IP、负载均衡等。</p><p>IAAS提供商提供的虚拟机设备也是一种IAAS服务。</p><h2 id="三者的区别"><a class="header-anchor" href="#三者的区别"></a>三者的区别</h2><p>SAAS、PAAS和IAAS是云计算服务模型的三个主要类型，它们之间有以下区别：</p><ul><li>SAAS（软件即服务）：SAAS是一种云计算服务模型，提供完全托管的应用程序，用户通过互联网访问这些应用程序，而无需关心底层的基础设施和平台。SAAS提供商负责应用程序的部署、维护和更新。用户只需使用应用程序，而无需担心底层的硬件、操作系统或中间件。常见的SAAS应用包括电子邮件服务、在线办公套件和客户关系管理系统。</li><li>PAAS（平台即服务）：PAAS是一种云计算服务模型，提供了一个开发和部署应用程序的平台。PAAS提供商提供了基础设施、操作系统、开发工具和运行时环境，使开发人员能够构建、测试和部署应用程序。用户可以专注于应用程序的开发，而无需关心底层的基础设施。PAAS通常包括数据库服务、消息队列、身份验证和扩展性管理等功能。</li><li>IAAS（基础设施即服务）：IAAS是一种云计算服务模型，提供了基础设施资源，如虚拟机、存储和网络。IAAS提供商提供了可在其基础设施上创建和管理虚拟化资源的能力。用户可以根据需要配置和管理虚拟机、存储和网络设置，具有更大的灵活性和控制权。IAAS模型适用于需要更高级别的定制化和控制的用户，他们需要直接访问基础设施层。</li></ul><p>总结：</p><ul><li>SAAS提供完全托管的应用程序，用户只需使用应用程序，而无需关心底层基础设施和平台。</li><li>PAAS提供应用程序开发和部署的平台，用户可以构建、测试和部署应用程序，而无需关心底层基础设施。</li><li>IAAS提供基础设施资源，用户可以创建和管理虚拟化资源，具有更大的灵活性和控制权。</li></ul><p>软件即服务(SaaS)使应用程序可以通过互联网使用。客户不需要在他们的设备上安装或运行程序来使用SaaS解决方案。</p><p>平台即服务(PaaS)为创建和部署应用程序提供了框架，同时消除了基础设施管理的需要。 基础设施即服务(IaaS)为公司提供现收现付的基础设施，具有灵活性和控制权的优点。</p><p>三种云计算服务之间的差异实际上归结为控制层。IaaS为客户提供了最大的控制权，因为他们负责自己的应用程序、数据、运行时、中间件和操作系统。另一方面，PaaS客户只管理他们的应用程序和数据，而SaaS客户只负责他们自己在软件中的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SAAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell之alias别名</title>
      <link href="/2023/09/21/shell-alias/"/>
      <url>/2023/09/21/shell-alias/</url>
      
        <content type="html"><![CDATA[<p>在说alias之前，先大致说一下shell的相关知识点。</p><h2 id="Shell与bash"><a class="header-anchor" href="#Shell与bash"></a>Shell与bash</h2><p>Shell是用户与Linux系统进行交互的媒介。</p><p>bash是目前Linux最常用的Shell。除了bash之外，还有例如 sh、csh、ksh、zsh等。</p><p><strong>查看自己使用的是哪一个shell</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$0</span>也可以</span></span><br><span class="line">echo $0</span><br></pre></td></tr></table></figure><p><strong>查看系统安装了哪些shell</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p><strong>切换shell</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至bash</span></span><br><span class="line">chsh -s /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至zsh</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h2 id="profile和rc文件的解释"><a class="header-anchor" href="#profile和rc文件的解释"></a>profile和rc文件的解释</h2><p><u>***<strong>注意</strong>***：以下文件解释是以bash shell为准。</u></p><p>（1）<strong>/etc/profile：（系统环境变量）</strong> 此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行。并从/etc/profile.d目录的配置文件中搜集shell的设置。</p><p>（2） <b>/etc/bashrc：（用户变量）</b>为每一个<u>运行bash shell的用户</u>执行此文件。当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。</p><p>（3） <strong>~/.bash_profile</strong>： 每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次。随后该文件会显式调用 .bashrc. 其内容主要为设置环境变量。</p><p>（4） <strong>~/.bashrc</strong>：该文件包含专用于你的bash shell的bash信息，当登录时以及每次打开新的shell时，该该文件被读取。</p><p>（5） <strong>~/.bash_logout</strong>：当每次退出系统(退出bash shell)时，执行该文件。另外，/etc/profile中设定的变量(全局)的可以作用于任何用户，而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是&quot;父子&quot;关系。</p><h2 id="理解交互式与登录"><a class="header-anchor" href="#理解交互式与登录"></a>理解交互式与登录</h2><p><strong>交互式shell</strong>等待你输入命令, 然后执行并返回结果。</p><p><strong>非交互式shell</strong>则只是执行预设的命令, 比如读取脚本中的命令并执行, 执行到文件的末尾时shell即结束。</p><br><p><strong>登录</strong>通常就是指输入了用户名或者密码后启动的shell(比如系统启动, 远程登录等), 或者用<code>-l</code>或者<code>--login</code>方式启动的shell。</p><p><strong>非登录</strong>就是比如图形界面启动的终端, <code>su</code>切换的用户, 通过<code>bash</code>等命令的启动的shell。</p><br><p><strong>二者启动的条件及顺序</strong></p><p>bash的加载顺序如下：</p><ul><li>登录式SHELLL配置文件加载顺序：/etc/profile ⇒ ~/.bash_profile ⇒ ~/.bash_login ⇒ ～/.profile ⇒ ~/.bash_logout</li><li>非登录式SHELL配置文件加载顺序：/etc/bash.bashrc（/etc/bashrc）⇒ ~/.bashrc</li></ul><br><p>zsh的加载顺序如下（登录式和非登录时都是一样的）：</p><ol><li>/etc/zshenv</li><li>~/.zshenv</li><li>/etc/zprofile</li><li>~/.zprofile</li><li>/etc/zshrc</li><li>~/.zshrc</li><li>/etc/zlogin</li><li>~/.zlogin</li><li>~/.zlogout</li><li>/etc/zlogout</li></ol><h2 id="Linux之souce命令"><a class="header-anchor" href="#Linux之souce命令"></a>Linux之souce命令</h2><p>source命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。</p><p>功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。</p><br><p><strong>source filename、sh filename、./filename三者之间的区别</strong></p><ol><li>source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。</li><li>sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。</li><li>当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有&quot;.&quot;是用来表示当前目录的。</li></ol><p>举例说明：</p><ol><li>新建一个test.sh脚本，内容为:A=1</li><li>然后使其可执行chmod +x test.sh</li><li>运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell</li><li>运行./test.sh后，也是一样的效果</li><li>运行source test.sh 或者 . ./test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell（当前终端）中</li></ol><h2 id="Shell之alias别名"><a class="header-anchor" href="#Shell之alias别名"></a>Shell之alias别名</h2><p>语法：alias name=value</p><p>语法解释：其中name表示命令别名的名称，value表示命令别名的值。当用户输入name时，系统会自动将其转换为value。</p><p>语法注意点：</p><ul><li>name不能有空格</li><li>=前后也不能有空格</li><li>value命令携带参数（或者携带空格时），需要使用单引号或双引号括起来</li><li>alias只生效于当前shell会话，要想每次一直生效，可以将其放到shell的startup文件中，例如zsh的~/.zshrc，或者bash的~/.bashrc中。</li></ul><br><p><strong>alias命令</strong></p><ul><li><strong>alias</strong> ：列出已定义的所有alias别名</li><li><strong>alias name=value</strong> ：设置别名</li><li><strong>unalias name</strong> ：取消别名（只对当前shell终端生效）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> alias </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次使用Arthas的过程</title>
      <link href="/2023/09/20/arthas-use/"/>
      <url>/2023/09/20/arthas-use/</url>
      
        <content type="html"><![CDATA[<p>Arthas是Alibaba开发的一款线上监控诊断产品。</p><p>文档地址：<a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></p><br><p>在学习AOP时，想要查看运行时生成的代理类的结构，于是了解到Arthas这款产品。</p><p>说一下使用Arthas的操作：</p><ol><li><p>下载Arthas（其实它就是一个jar），并启动它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>java -jar</code>后，Arthas会扫描正在运行的java进程，并列举出1、2、3。。。</p><p><img src="/2023/09/20/arthas-use/image-20230920172607140.png" alt="image-20230920172607140"></p><p>输入【1】，进入目标进程。</p><p><img src="/2023/09/20/arthas-use/image-20230920172703659.png" alt="image-20230920172703659"></p></li><li><p>输入 <code>sc *UserService*</code>，模糊查找类名为 UserService 的class。</p><p><img src="/2023/09/20/arthas-use/image-20230920172810887.png" alt="image-20230920172810887"></p><p><code>sc</code>是“Search-Class”的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息。</p></li><li><p>输入 <code>jad aop.UserService$$EnhancerBySpringCGLIB$$e31ac034</code>，就可以查看到运行时的代理类了。</p><p><code>jad</code> 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于理解业务逻辑。</p></li><li><p>在 Arthas Console 下，输入 <code>quit</code> 退出当前 Arthas 客户端。输入 <code>stop</code> 关闭 Arthas 服务端，所有 Arthas 客户端也会退出。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arthas </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础学习</title>
      <link href="/2023/09/20/docker-study-basic/"/>
      <url>/2023/09/20/docker-study-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker是什么"><a class="header-anchor" href="#Docker是什么"></a>Docker是什么</h2><p>基于Linux内核的 Cgroups、Namespace 技术，以及 UnionFS（Union File System）组成 rootfs（Root File System）等技术，对进程进行封装隔离，实现操作系统层面的虚拟化技术。</p><p>从上面的介绍直观感受来说，Docker更像一个技术概念，它利用已有的技术特性和理念，使用Go语言开发了一个项目，叫做Docker。</p><p>它实现的进程隔离独立于宿主和其他隔离的进程外，因此被称为容器。</p><p>Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使其相比于虚拟机技术更为轻便、快捷。</p><p>Docker技术相比较于虚拟机技术：虚拟机技术是虚拟出一套完整的操作系统（自己的内核、硬件资源），再在该系统上运行所需的应用进程；而Docker容器没有自己的内核，也没有进行硬件虚拟，只是通过技术手段重新挂载一套新的文件系统，并在此文件系统上运行应用进程。</p><p>Docker技术相比较于虚拟机技术的优势：</p><ol><li>更高效的利用系统资源</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付（CI）和部署（CD）</li><li>更轻松的迁移</li><li>更轻松的维护和扩展</li></ol><h2 id="Docker基本概念"><a class="header-anchor" href="#Docker基本概念"></a>Docker基本概念</h2><p>Docker的三大基本概念：</p><ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul><h3 id="Docker镜像"><a class="header-anchor" href="#Docker镜像"></a>Docker镜像</h3><p>前言：操作系统的组成分为 内核 和 用户空间，对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统（rootfs）为其提供用户空间支持。</p><p>Docker镜像（Image），就相当于是一个特殊的 rootfs ，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变（抽象点说，Docker镜像是一个只读的模版）。</p><p>因为Docker镜像包含有操作系统的完整的 rootfs，其体积往往是庞大的（百兆或者GB大小），这与介绍Docker时说它是轻量级的概念不符。所以Docker在设计时，利用了 <code>Union FS</code>技术，将镜像设计为多层储存的架构。严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>例如：从Docker Hub下载一个 <code>MySQL</code>镜像时，MySQL需要有一个操作系统作为运行环境，但它不会拿宿主机的操作系统，而是根据构建MySQL镜像的代码判断，从上一层获取镜像。</p><p><img src="/2023/09/20/docker-study-basic/image-20230920114306998.png" alt="image-20230920114306998"></p><p>从图中可以看出，mysql:5.7.41镜像的上一层是oraclelinux:7-slim镜像。</p><h3 id="Docker容器"><a class="header-anchor" href="#Docker容器"></a>Docker容器</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就类似于面向对象编程中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>每个容器都是相互隔离的运行环境，具有自己的文件系统、进程空间和网络接口。容器可以与主机和其他容器进行通信。</p><h3 id="Docker-Registry"><a class="header-anchor" href="#Docker-Registry"></a>Docker Registry</h3><p>Docker Registry翻译为Docker注册表，又叫做Docker中央仓库。中央仓库可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应一个Docker镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><h2 id="Docker常用命令"><a class="header-anchor" href="#Docker常用命令"></a>Docker常用命令</h2><h3 id="镜像管理命令"><a class="header-anchor" href="#镜像管理命令"></a>镜像管理命令</h3><ol><li><code>docker pull &lt;image&gt;</code>：从注册表中拉取一个镜像。</li><li><code>docker build [options] &lt;path/to/dockerfile&gt;</code>：根据Dockerfile构建一个镜像。</li><li><code>docker push &lt;image&gt;</code>：将一个镜像推送到注册表中。</li><li><code>docker images</code>：列出本地已有的镜像。等同于 <code>docker image ls</code>。</li><li><code>docker rmi &lt;image&gt;</code>：删除一个镜像。</li></ol><h3 id="容器管理命令"><a class="header-anchor" href="#容器管理命令"></a>容器管理命令</h3><ol><li><p><code>docker run [options] &lt;image&gt; [COMMAND] [ARG...]</code>：创建并运行一个新的容器。</p><ul><li><code>[OPTIONS]</code>是可选的参数，用于配置容器的各种选项，例如端口映射、卷挂载、环境变量等。</li><li><code>IMAGE</code>是容器所基于的镜像名称或镜像ID。</li><li><code>[COMMAND] [ARG...]</code>是容器启动时要执行的命令和参数。</li></ul><p>下面是一些常用的<code>docker run</code>命令选项（options）：</p><ul><li><code>-d</code>：以后台模式（detached）运行容器。</li><li><code>-p &lt;host-port&gt;:&lt;container-port&gt;</code>：将主机的端口映射到容器的端口。</li><li><code>-v &lt;host-path&gt;:&lt;container-path&gt;</code>：将主机的目录或文件挂载到容器的目录。</li><li><code>-e &lt;key&gt;=&lt;value&gt;</code>：设置环境变量。</li><li><code>--name &lt;container-name&gt;</code>：为容器指定一个名称。</li><li><code>--restart &lt;restart-policy&gt;</code>：设置容器的重启策略。</li><li><code>-it</code>：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。一般会在command写bash。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。</li></ul></li><li><p><code>docker start &lt;container&gt;</code>：启动已经创建的容器。</p></li><li><p><code>docker stop &lt;container&gt;</code>：停止正在运行的容器。</p></li><li><p><code>docker restart &lt;container&gt;</code>：重启容器。</p></li><li><p><code>docker rm &lt;container&gt;</code>：删除容器。</p></li><li><p><code>docker ps [options]</code>：列出正在运行的容器。</p><ol><li><code>docker ps -a</code>：列出所有容器，包括正在运行的和已停止的容器。</li><li><code>docker ps -q</code>：只显示容器的ID。</li><li><code>docker ps -l</code>：显示最近创建的容器。</li><li><code>docker ps --filter &lt;key&gt;=&lt;value&gt;</code>：根据指定的键值对筛选容器，例如<code>docker ps --filter status=running</code>只显示正在运行的容器。</li></ol></li><li><p><code>docker logs &lt;container&gt;</code>：查看容器的日志。默认输出所有日志。</p><ol><li><code>docker logs --tail 100 &lt;container&gt;</code> ：只展示最后100行日志</li><li><code>docker logs -f &lt;container&gt;</code> ：实时（follow）模式下查看容器日志。</li></ol></li><li><p><code>docker exec [options] &lt;container&gt; &lt;command&gt;</code>：在正在运行的容器中执行命令。</p><ol><li><code>docker exec -it &lt;container&gt; &lt;command&gt;</code> ：在正在运行的容器中执行交互式命令。<ul><li><code>-it</code>选项用于指定交互式会话（Interactive）和终端（TTY）连接，以便你可以与容器进行交互。</li><li><code>&lt;container&gt;</code>是容器的名称或容器ID。</li><li><code>&lt;command&gt;</code>是要在容器内部执行的命令。例如：bash</li></ul></li></ol></li></ol><h3 id="网络和存储命令"><a class="header-anchor" href="#网络和存储命令"></a>网络和存储命令</h3><ol><li><code>docker network create &lt;network&gt;</code>：创建一个新的网络。</li><li><code>docker network connect &lt;network&gt; &lt;container&gt;</code>：将容器连接到网络。</li><li><code>docker volume create &lt;volume&gt;</code>：创建一个数据卷。</li><li><code>docker volume ls</code>：列出本地已有的数据卷。</li><li><code>docker volume rm &lt;volume&gt;</code>：删除一个数据卷。</li></ol><h3 id="其他常用命令"><a class="header-anchor" href="#其他常用命令"></a>其他常用命令</h3><ol><li><code>docker info</code>：显示Docker系统信息。</li><li><code>docker version</code>：显示Docker客户端和服务器版本信息。</li><li><code>docker inspect &lt;container/image&gt;</code>：获取容器或镜像的详细信息。</li><li><code>docker attach &lt;container&gt;</code>：附加到正在运行的容器的标准输入、输出和错误流。</li><li><code>docker cp &lt;container&gt;:&lt;path/to/file&gt; &lt;host/path&gt;</code>：从容器复制文件到主机。</li><li><code>docker-compose up</code>：使用Docker Compose启动多个容器应用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SPI机制分析</title>
      <link href="/2023/09/18/java-spi-understand/"/>
      <url>/2023/09/18/java-spi-understand/</url>
      
        <content type="html"><![CDATA[<h2 id="SPI是什么"><a class="header-anchor" href="#SPI是什么"></a>SPI是什么</h2><p>SPI全称为Service Provider Interface，直译就是服务提供方的接口。一种用于定义服务提供商与应用程序之间通信的接口，通常用于实现模块化和可插拔的系统。</p><blockquote><p>Q：为什么会有SPI这种机制？</p><p>A：因为在Java面向对象编程中，基于开闭原则和解耦的需要，一般建议用接口进行模块之间的通信编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。</p><p>为了实现在模块装配的时候不用在程序里面动态指明，这就需要一种服务发现机制。Java SPI 就是提供了这样一个机制：为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配的控制权移交到了程序之外。</p></blockquote><h2 id="Java-SPI机制"><a class="header-anchor" href="#Java-SPI机制"></a>Java SPI机制</h2><p>Java实现SPI机制的核心类叫 <code>ServiceLoader</code> ，Java的SPI实现约定了以下两件事：</p><ul><li>文件必须放在META-INF/services/目录底下，并且必须使用UTF-8编码。</li><li>文件名必须为接口的全限定名，内容为接口实现的全限定名。</li></ul><h3 id="示例"><a class="header-anchor" href="#示例"></a>示例</h3><p>第一步，定义一个接口，以及它的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrinterEventListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is PrinterEventListener: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackupEventListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is BackupEventListener: &quot;</span> + event);</span><br><span class="line">        <span class="built_in">this</span>.backup(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backup</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，在 <code>META-INF/services</code> 目录下创建 EventListener 类的全限定名的文件，文件内容为 PrinterEventListener、BackupEventListener 类的全限定名。</p><p><img src="/2023/09/18/java-spi-understand/image-20230919094459759.png" alt="image-20230919094459759"></p><p><img src="/2023/09/18/java-spi-understand/image-20230919094528669.png" alt="image-20230919094528669"></p><p>第三步，定义一个测试类，使用Java的 ServiceLoader 加载文件，并发起调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSpiDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Java SPI加载</span></span><br><span class="line">        ServiceLoader&lt;EventListener&gt; serviceLoader = ServiceLoader.load(EventListener.class);</span><br><span class="line">        <span class="comment">// 获取接口迭代器</span></span><br><span class="line">        Iterator&lt;EventListener&gt; listenerIterator = serviceLoader.iterator();</span><br><span class="line">        <span class="comment">// 定义事件监听消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">event</span> <span class="operator">=</span> <span class="string">&quot;Java SPI机制&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历调用事件监听器</span></span><br><span class="line">        listenerIterator.forEachRemaining(eventListener -&gt; &#123;</span><br><span class="line">            eventListener.onEvent(event);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2023/09/18/java-spi-understand/image-20230919094753460.png" alt="image-20230919094753460"></p><p>此时成功通过Java SPI获取到了实现类。</p><h3 id="实现原理"><a class="header-anchor" href="#实现原理"></a>实现原理</h3><p>通过测试类 JavaSpiDemo 的代码大致可知，首先通过 ServiceLoader 加载指定类 ，然后获取到一个迭代器，迭代器的元素就是指定类的实现类。</p><blockquote><p>Q：为什么通过ServiceLoader加载的是“指定类”，而不是接口？</p><p>A：因为提供者提供的类也可以是抽象类，实现类可以通过extends继承的方式实现。Java SPI 判断文件中的类是否为实现类的方式就是 Class.isInstance(Object obj) 方法，该方法等同于 instanceof 。</p></blockquote><p>先看加载原理：</p><p><img src="/2023/09/18/java-spi-understand/image-20230919095229544.png" alt="image-20230919095229544"></p><p>首先获取一个fullName，其实就是 <code>META-INF/services/</code> 指定类的全限定名。</p><p>然后通过ClassLoader获取到资源，其实就是接口的全限定名文件对应的资源，然后交给 <code>parse</code> 方法解析资源。</p><p><img src="/2023/09/18/java-spi-understand/image-20230919100654882.png" alt="image-20230919100654882"></p><p><img src="/2023/09/18/java-spi-understand/image-20230919100929032.png" alt="image-20230919100929032"></p><p>parse方法其实就是通过IO流读取文件的内容，然后通过 <code>parseLine</code> 方法获取实现类的全限定名。</p><p>最后在迭代器调用 <code>next</code> 方法时，调用内部的 <code>nextService</code> 方法，通过反射构造实现类的实例化对象。</p><p><img src="/2023/09/18/java-spi-understand/image-20230919101514809.png" alt="image-20230919101514809"></p><blockquote><p>💡注意：通过此处源码可以看出，ServiceLoader实例化实现类的方式是 Class.newInstance() 方法，所以通过Java SPI实现SPI机制时，实现类必须要有无参构造方法。</p></blockquote><h3 id="优缺点"><a class="header-anchor" href="#优缺点"></a>优缺点</h3><p>从示例代码和源码可以看出，Java实现的SPI机制比较简单，所以更容易于开发者理解和使用。也因为此会有一点缺点。</p><p>第一点就是浪费资源，虽然例子中只有一个实现类，但是实际情况下可能会有很多实现类，而Java的SPI会一股脑全进行实例化，但是这些实现了不一定都用得着，所以就会白白浪费资源。</p><p>第二点就是无法对区分具体的实现，也就是这么多实现类，到底该用哪个实现呢？如果要判断具体使用哪个，只能依靠接口本身的设计，比如接口可以设计为一个策略接口，又或者接口可以设计带有优先级的，但是不论怎样设计，框架作者都得写代码进行判断。</p><p>所以总得来说就是ServiceLoader无法做到按需加载或者按需获取某个具体的实现。</p><h3 id="使用场景"><a class="header-anchor" href="#使用场景"></a>使用场景</h3><p>一般适用于：</p><ul><li>不需要选择具体的实现，每个被加载的实现都需要被用到</li><li>虽然需要选择具体的实现，但是可以通过对接口的设计来解决</li></ul><p>例如：全局拦截器、过滤器、校验器。</p><p>我在项目中用过 javax.validation.spi.ValidationProvider ，hibernate对其做了较为全面的封装，其实现类为 org.hibernate.validator.HibernateValidator 。</p><h2 id="Spring-SPI机制"><a class="header-anchor" href="#Spring-SPI机制"></a>Spring SPI机制</h2><p>Spring实现SPI机制的核心类叫 <code>SpringFactoriesLoader</code> ，Spring的SPI机制约定如下：</p><ul><li>配置文件必须在<code>META-INF/</code>目录下，文件名必须为spring.factories</li><li>文件内容为键值对，一个键可以有多个值，只需要用逗号分割就行，同时键值都需要是类的全限定名，键和值可以没有任何类与类之间的关系，当然也可以有实现的关系。</li></ul><p>从约定内容可以看出，Spring的SPI机制与Java的SPI机制相比，文件约定和接口类约定都不相同。</p><h3 id="示例-2"><a class="header-anchor" href="#示例-2"></a>示例</h3><p>第一步，定义文件。</p><p><img src="/2023/09/18/java-spi-understand/image-20230919112022912.png" alt="image-20230919112022912"></p><p><img src="/2023/09/18/java-spi-understand/image-20230919111948099.png" alt="image-20230919111948099"></p><p>第二步，定义测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSpiDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;EventListener&gt; eventListeners = SpringFactoriesLoader.loadFactories(EventListener.class, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">event</span> <span class="operator">=</span> <span class="string">&quot;Spring SPI机制&quot;</span>;</span><br><span class="line">        eventListeners.forEach(eventListener -&gt; eventListener.onEvent(event));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring 6.0开始废弃此方法</span></span><br><span class="line">        List&lt;String&gt; factoryNames = SpringFactoriesLoader.loadFactoryNames(EventListener.class, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(factoryNames);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2023/09/18/java-spi-understand/image-20230919112138626.png" alt="image-20230919112138626"></p><p>成功获取到实现对象。</p><h3 id="实现原理-2"><a class="header-anchor" href="#实现原理-2"></a>实现原理</h3><p>大致原理为：</p><ol><li>解析 <code>META-INF/spring.factories</code> 文件，获取实现类的全限定名。</li><li>反射实例化对象。</li><li>Spring 排序。</li></ol><p><img src="/2023/09/18/java-spi-understand/image-20230919112747587.png" alt="image-20230919112747587"></p><p>第一步，解析文件是Spring实现SPI机制的关键，它默认解析 <code>FACTORIES_RESOURCE_LOCATION</code>  = &quot;META-INF/spring.factories&quot; 下的文件内容。源码如下：</p><p><img src="/2023/09/18/java-spi-understand/image-20230919112433720.png" alt="image-20230919112433720"></p><p>第二步，实例化对象时也是先获取Class类对象，再通过反射构造实例化对象，与Java SPI不同的是，它是使用的 Constructor.newInstance() 方法，但并不支持有参构造，还是得需要无参构造方法。</p><p><img src="/2023/09/18/java-spi-understand/image-20230919113511676.png" alt="image-20230919113511676"></p><p>第三部，Spring内置排序功能，AnnotationAwareOrderComparator.sort(List&lt;?&gt; list) 方法的作用是判断对象是否实现了 <code>Ordered</code> 类，或者是否标记了 <code>Order</code> 注解。排序功能的实现类为 <code>AnnotationAwareOrderComparator</code> 。</p><blockquote><p>这也是Spring SPI机制与Java SPI机制的不同点，ServiceLoader是按顺序加载并返回，而SpringFactoriesLoader是按顺序加载，正序排序后再返回。</p></blockquote><h3 id="使用场景-2"><a class="header-anchor" href="#使用场景-2"></a>使用场景</h3><p>Spring的SPI机制在内部使用的非常多，尤其在SpringBoot中大量使用，SpringBoot启动过程中很多扩展点都是通过SPI机制来实现的，例如：</p><p>1、自动装配</p><p>在SpringBoot3.0之前的版本，自动装配是通过SpringFactoriesLoader来加载的。</p><p><img src="/2023/09/18/java-spi-understand/image-20230919114212629.png" alt="image-20230919114212629"></p><p>但是SpringBoot3.0之后不再使用SpringFactoriesLoader，而是Spring重新从 <code>META-INF/spring/</code> 目录下的 <code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中读取了。</p><p>2、PropertySourceLoader的加载</p><p>PropertySourceLoader是用来解析application配置文件的，它是一个接口。</p><p><img src="/2023/09/18/java-spi-understand/image-20230919114314107.png" alt="image-20230919114314107"></p><p>SpringBoot默认提供了 PropertiesPropertySourceLoader 和 YamlPropertySourceLoader两个实现，就是对应properties和yaml文件格式的解析。</p><p>SpringBoot在加载PropertySourceLoader时就用了SPI机制。</p><p><img src="/2023/09/18/java-spi-understand/image-20230919114432063.png" alt="image-20230919114432063"></p><h3 id="与Java-SPI机制对比"><a class="header-anchor" href="#与Java-SPI机制对比"></a>与Java SPI机制对比</h3><p>首先Spring的SPI机制对Java的SPI机制对进行了一些简化，Java的SPI每个接口都需要对应的文件，而Spring的SPI机制只需要一个spring.factories文件。</p><p>其次是内容，Java的SPI机制文件内容必须为接口的实现类，而Spring的SPI并不要求键值对必须有什么关系，更加灵活。</p><p>第三点就是Spring的SPI机制提供了获取类限定名的方法loadFactoryNames，而Java的SPI机制是没有的。通过这个方法获取到类限定名之后就可以将这些类注入到Spring容器中，用Spring容器加载这些Bean，而不仅仅是通过反射。</p><p>但是Spring的SPI也同样没有实现获取指定某个指定实现类的功能，所以要想能够找到具体的某个实现类，还得依靠具体接口的设计。</p><p>所以不知道你有没有发现，PropertySourceLoader它其实就是一个策略接口，注释也有说，所以当你的配置文件是properties格式的时候，他可以找到解析properties格式的PropertiesPropertySourceLoader对象来解析配置文件。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>通过以上分析可以看出，实现SPI机制的核心原理就是通过IO流读取指定文件的内容，然后解析，最后加入一些自己的特性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化-LIMIT查询</title>
      <link href="/2023/09/11/mysql-optimization-limit/"/>
      <url>/2023/09/11/mysql-optimization-limit/</url>
      
        <content type="html"><![CDATA[<p>在业务开发中，<strong>分页查询</strong> 是经常碰到的接口功能之一，一般分页查询都会使用有顺序性的字段作为排序字段，例如更新时间、创建时间、等级。。。</p><p>假如现在系统中有这样一张表t：</p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911154335378.png" alt="image-20230911154335378"></p><p>id为主键，grade表示等级，score表示分数，业务中一个等级表示一个分数范围，现有如下数据：</p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911154513509.png" alt="image-20230911154513509"></p><p>数据范围模拟分布如下：</p><p>grade == 1: score &lt; 2</p><p>grade == 2: 2 &lt;= score &lt; 3</p><p>grade == 3: score &gt;= 3</p><p>现在有一个分页查询：<em><strong>要求用等级升序排序，每页查询5条数据</strong></em></p><p>一开始的sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一页</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> grade limit <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二页</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> grade limit <span class="number">5</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>理想情况下，第一页查询结果应该是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">1.1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1.2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1.3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1.4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1.5</span>)</span><br></pre></td></tr></table></figure><p>第二页的查询结果应该是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">0.1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">0.2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">0.3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2.1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2.2</span>)</span><br></pre></td></tr></table></figure><p>可实际情况是：</p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911155613090.png" alt="image-20230911155613090"></p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911155633378.png" alt="image-20230911155633378"></p><p>从这里可以大致猜到：</p><ol><li><p>如果 ORDER BY 的字段，存在相同值，并且 相同值的数据量 &gt; limit的数量，MySQL不会对符合ORDER BY条件的所有行进行内部排序，而是随机读取。</p></li><li><p>按照 innodb 索引树的规则（相同索引值，按照聚簇索引列有序排序），这个查询语句应该是没有使用到 i_grade 索引树的。</p></li></ol><p>执行一下EXPLAIN，看看MySQL优化器的解析计划：</p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911161345089.png" alt="image-20230911161345089"></p><p>表t上是有grade的索引的，possible_keys却没有解析到，更别说使用到了，那感觉就是MySQL优化器认为走聚簇索引再内部排序更快。</p><p>既然如此，那么强制让查询数据使用 i_grade 索引试试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(i_grade) <span class="keyword">order</span> <span class="keyword">by</span> grade limit <span class="number">0</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>查询结果如下：</p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911162857621.png" alt="image-20230911162857621"></p><p>查询结果与预期结果一致了，那证明 i_grade 索引树的存储规则肯定是没问题的，只是MySQL优化器使用的执行计划与预期不一致。</p><p>再看下第二页：</p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911163406666.png" alt="image-20230911163406666"></p><p>第二页的查询结果与预期结果也是一致的，所以问题就出在了MySQL优化器上，两个问题：</p><ol><li>为什么不使用 ORDER BY 指定列上包含的索引？</li><li>为什么 Using filesort 排序的结果集不是按照聚簇索引有序排序的？</li></ol><br><p>直接上官方解释：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html">https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html</a></p><p>对于文档说明总结如下：</p><ol><li>ORDER BY（GROUP BY）的排序结果会受 LIMIT row_count 的 row_count 影响，如果指定了row_count，MySQL在通常情况下更愿意使用全表扫描，即使可能使用索引会更快。</li><li>MySQL 使用 filesort 排序时，如果查询命令携带 LIMIT row_count ，那么MySQL只会对扫描到的这些数据（row_count行数据）做排序。</li></ol><br><p>解决方案：</p><p>在 ORDER BY 后加上其他列，这个最好是有顺序性并且唯一的，例如id。</p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911165313416.png" alt="image-20230911165313416"></p><p>解析计划如下：</p><p><img src="/2023/09/11/mysql-optimization-limit/image-20230911165352012.png" alt="image-20230911165352012"></p><p>可见它默认还是走的全表扫描，并使用filesort排序，但是此时需要对 id 进行排序，所以保证了数据是按照预期读取的。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> LIMIT </tag>
            
            <tag> SQL语句优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Git项目添加README文件</title>
      <link href="/2023/09/05/hexo-readme/"/>
      <url>/2023/09/05/hexo-readme/</url>
      
        <content type="html"><![CDATA[<p>首先，说下操作步骤：</p><ol><li>在hexo站点项目的source目录下，新建自己的 README.md 文件。</li><li>修改hexo站点配置文件，skip_render 参数增加 README.md 配置。</li><li>重新部署hexo。</li></ol><br><p>再说下我的尝试步骤。</p><p>首先，我“傻乎乎”的进入到<code>xxx.github.io</code>项目，直接在根目录下点击<code>Create new file</code>创建了个README.md文件，以为就可以了。</p><p>直到我后面使用<code>hexo d</code>发布博客时，才发现README.md文件被覆盖了。</p><br><p>一番查阅资料才知道，使用<code>hexo d</code>部署到git时，hexo是不会进行<code>git pull</code>操作的。</p><p>因此，想要在hexo部署的项目中新增文件，就得从hexo站点项目下手。</p><p>在hexo站点项目下，有一个 source 目录，直接在此目录下新建 README.md 文件，部署时就会生成在git项目的根目录下。（之前配置GitHub Pages到个人站点时的CNAME文件就是如此）</p><br><p>不过，README.md 文件比较特殊，因为它是md文件，hexo编写博客使用的文件格式就是md，在<code>hexo g</code>生成静态文件时，会默认将 .md 文件转为html文件，所以还需要为 README.md 文件增加忽略配置。</p><p>在hexo的站点配置文件（_config.yml）中，有一个 <code>skip_render</code> 参数，表示需要跳过渲染的文件，添加 README.md 即可。</p><p><img src="/2023/09/05/hexo-readme/image-20230905153527438.png" alt="image-20230905153527438"></p><p>再次重新执行三部曲 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d </code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> README.md </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作小结-钉钉OA审批(2)</title>
      <link href="/2023/09/01/work-report-ddoa2/"/>
      <url>/2023/09/01/work-report-ddoa2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>在 <a href="https://blog.itwray.com/2023/08/25/work-report-ddoa/">工作小结-钉钉OA审批</a> 中，介绍了钉钉OA审批的基础概念，以及常用的API示例。本章则主要是整理项目搭建钉钉OA审批底层框架的设计思路，并附上源码。</p><p>源码地址：<a href="https://github.com/wangfarui/java-study/tree/main/third-study/dingtalk/dingtalk-oa">https://github.com/wangfarui/java-study/tree/main/third-study/dingtalk/dingtalk-oa</a></p><h2 id="框架目录结构"><a class="header-anchor" href="#框架目录结构"></a>框架目录结构</h2><p><img src="/2023/09/01/work-report-ddoa2/image-20230901165428927.png" alt="image-20230901165428927"></p><p>annotation: 关于钉钉OA审批的自定义注解</p><p>client：与钉钉服务端API交互</p><p>config：钉钉的属性配置、钉钉相关的Spring Bean配置类</p><p>dao：数据持久层</p><p>form：钉钉OA审批表单</p><p>listener：钉钉回调事件监听器</p><p>mapper：数据ORM映射层</p><p>model：数据表实体；钉钉OA审批相关对象、枚举</p><p>runner：服务启动时，钉钉的启动器</p><p>service：钉钉服务层</p><p>util：钉钉相关的工具类，例如表单数据格式化工具、Client统一生成工具等</p><p>DingTalkAuthManager：钉钉鉴权服务管理器，获取钉钉参数配置的入口</p><h2 id="设计思路"><a class="header-anchor" href="#设计思路"></a>设计思路</h2><h3 id="数据表设计"><a class="header-anchor" href="#数据表设计"></a>数据表设计</h3><ol><li>钉钉创建审批表单模板需要 name（模板名称）、formComponents（表单控件）等，因此需要一张审批表单关联表（<em><strong>dd_approval_form_rel</strong></em>）记录业务表单与钉钉表单模板之间的关联信息。</li><li>钉钉发起OA审批需要 processCode（模板编号）、originatorUserId（发起人id）、deptId（发起人部门id）等，processCode可以从审批表单关联表获取，但发起人信息得从钉钉获取，获取方式是通过业务系统与钉钉有唯一关联关系的值（例如手机号）进行关联查询，而唯一关联关系的值一般情况下不会变动，所以为了减少不必要的网络请求开销，就需要一张用户关联表（<em><strong>dd_user_rel</strong></em>）记录钉钉用户与业务系统用户之间的关联关系。</li><li>在发起OA审批后，钉钉会返回一个 instanceId（审批实例id），通过审批实例id可以随时查看该审批记录的最新操作记录、任务状态、表单控件数据等。为了审批回调时能够快速定位到业务系统的业务单据，所以需要一个审批业务关联表（<em><strong>dd_approval_business_rel</strong></em>）记录钉钉OA审批实例与业务系统的业务单据的关联关系。</li><li>因为业务需要，钉钉审批流程的记录希望同步展示到业务系统页面上。通过跑审批示例流程观察，审批流程记录的数据节点与钉钉回调事件中的审批任务事件返回数据节点是一致的，因此审批记录就监听该事件就好。审批记录的内容一般包括审批人、审批流程类型（同意、拒绝、评论、转交、撤销等）、审批评论内容、审批时间，其中审批评论内容支持评论图片以及上传附件，所以需要一个审批流程记录表（<em><strong>dd_approval_process_log</strong></em>）和一个审批流程记录附件表（<em><strong>dd_approval_process_log_attachment</strong></em>）。</li></ol><h3 id="关键类设计"><a class="header-anchor" href="#关键类设计"></a>关键类设计</h3><ol><li><p>钉钉的服务端API基本上都要token入参，有些接口还需要用户id、应用id、存储空间id等，而这些参数基本上都是“固定的”。因此需要一个统一获取钉钉参数配置类，并且这个类具有缓存效果。（<strong>DingTalkAuthManager</strong>）</p></li><li><p>钉钉服务端API的交互方式是使用SDK，而SDK又分为新版SDK和旧版SDK，为了方便管理，因此使用 <strong>DingTalkApiClientUtil</strong> 创建Client，在 client 包下实现与API的交互，根据Client类型分为多个类进行管理。</p><p><img src="/2023/09/01/work-report-ddoa2/image-20230901174559277.png" alt="image-20230901174559277"></p></li><li><p>因为是搭建钉钉OA审批底层框架，要支持业务服务能够快捷、易用、低侵入的接入，同时支持各种场景下的审批控件内容，就需要设计一个表单工具类，可以解析各种表单控件类型并格式化表单数据。</p><ol><li>钉钉OA审批的表单控件类型都是纯文本描述的，SDK未提供相关的字典类，所以首先需要自己维护一个表单控件类型字典（<strong>ComponentType</strong>），为了尽可能的易用，我创造了一个 <strong>AUTO</strong> 控件类型，让框架通过“约定”的方式自动识别控件类型。相应实现方法在 <em><strong>DingTalkFormUtil#generateFormComponent(Field field)</strong></em> 。</li><li>不同的表单控件类型在发起审批实例时，需要的表单数据格式是不一样的（在整体上如钉钉开放平台文档所说确实结构一致），例如表格、附件、关联审批单等，它们的 value 参数值就与平常控件区别很大。相应实现方法在 <em><strong>DingTalkFormUtil#generateFormComponentValues(Field field, ApprovalFormEngine approvalForm)</strong></em> 。</li></ol></li><li><p>第3条说的表单工具类是为了解析表单对象，表单对象就是一个Java Class类，通过注解（<em><strong>FormComponent</strong></em>）标记字段以表示表单控件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FormComponent &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表单控件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表单控件id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;表单控件列表中唯一&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表单控件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ComponentType <span class="title function_">componentType</span><span class="params">()</span> <span class="keyword">default</span> ComponentType.AUTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否非空, 默认不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段为&#123;<span class="doctag">@link</span> java.util.Date&#125;时，日期格式化样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">pattern</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="发起审批流程"><a class="header-anchor" href="#发起审批流程"></a>发起审批流程</h3><p>实现方法在 <em><strong>DingTalkApprovalService#startApprovalFlowInstance(ApprovalFormInstance instance)</strong></em>。</p><p>发起审批流程可以细分为四部分：</p><ol><li>创建并获取审批模板</li><li>获取审批发起人对应的钉钉用户信息</li><li>发起审批实例，拿取实例id</li><li>保存审批实例与业务单据的关联信息</li></ol><h4 id="入参对象分析"><a class="header-anchor" href="#入参对象分析"></a>入参对象分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApprovalFormInstance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scm业务id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long businessId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批流程表单模板对象</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApprovalFormEngine approvalForm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scm租户id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空字段，为空时默认从UserUtils获取&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long tenantId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scm操作人id</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;非空字段，为空时默认从UserUtils获取&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钉钉部门id</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * TODO 钉钉存在多部门时，需要指定。后期根据产品需求决定是手动指定还是默认指定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long departmentId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自身关联审批单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">selfRelateField</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个对象中，最关键的就是<code>businessId</code>和<code>approvalForm</code>，它们决定了此次发起审批流程的业务关联数据、审批表单数据。</p><h4 id="创建并获取审批模板"><a class="header-anchor" href="#创建并获取审批模板"></a>创建并获取审批模板</h4><p>实际上，第一步应该叫 <em><strong>获取审批模板编号</strong></em> ，但编号不会凭空产生，所以方法内部的实际操作为：</p><ol><li>查询审批表单模板关联信息。</li><li>查询结果分为两种：<ol><li>关联信息不存在，创建表单模板并返回模板编号。</li><li>关联信息存在，判断当前模板版本与关联信息存储的版本是否一致。（版本的存在是为了防止业务端在开发过程中修改已存在的表单模板对象）<ol><li>若一致，直接返回关联信息存储的模板编号。</li><li>若不一致，更新表单模板并返回模板编号。</li></ol></li></ol></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DdApprovalFormRel <span class="title function_">resolveDdApprovalFormRel</span><span class="params">(ApprovalFormInstance instance)</span> &#123;</span><br><span class="line">    <span class="type">ApprovalFormEngine</span> <span class="variable">approvalForm</span> <span class="operator">=</span> instance.getApprovalForm();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从关联表中查询钉钉表单模板Code</span></span><br><span class="line">    <span class="type">DdApprovalFormRel</span> <span class="variable">ddApprovalFormRel</span> <span class="operator">=</span> ddApprovalFormRelDao.lambdaQuery()</span><br><span class="line">            .eq(DdApprovalFormRel::getTenantId, instance.getTenantId())</span><br><span class="line">            .eq(DdApprovalFormRel::getTypeCode, approvalForm.getBusinessApprovalTypeEnum().getCode())</span><br><span class="line">            .last(<span class="string">&quot;limit 1&quot;</span>)</span><br><span class="line">            .one();</span><br><span class="line">    <span class="keyword">if</span> (ddApprovalFormRel != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> approvalForm.version();</span><br><span class="line">      <span class="comment">// 版本号是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (version.equals(ddApprovalFormRel.getFormVersion())) &#123;</span><br><span class="line">            <span class="keyword">return</span> ddApprovalFormRel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updateDdApprovalFormRel(approvalForm, ddApprovalFormRel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关联表无映射时，生成关联数据并返回</span></span><br><span class="line">    <span class="keyword">return</span> createDdApprovalFormRel(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取审批发起人对应的钉钉用户信息"><a class="header-anchor" href="#获取审批发起人对应的钉钉用户信息"></a>获取审批发起人对应的钉钉用户信息</h4><p>首先，查询用户关联数据；</p><p>然后，关联数据为空的话，通过业务用户信息调用钉钉API，查询钉钉用户详情；</p><p>最后，建立业务用户与钉钉用户的关联关系数据对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DdUserRel <span class="title function_">resolveDdUserRel</span><span class="params">(ApprovalFormInstance instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询已关联的用户信息</span></span><br><span class="line">    <span class="type">DdUserRel</span> <span class="variable">ddUserRel</span> <span class="operator">=</span> ddUserRelDao.lambdaQuery()</span><br><span class="line">            .eq(DdUserRel::getTenantId, instance.getTenantId())</span><br><span class="line">            .eq(DdUserRel::getScmUserId, instance.getUserId())</span><br><span class="line">            .last(<span class="string">&quot;limit 1&quot;</span>)</span><br><span class="line">            .one();</span><br><span class="line">    <span class="keyword">if</span> (ddUserRel != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ddUserRel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过业务用户信息 创建钉钉用户关联数据</span></span><br><span class="line">    <span class="keyword">return</span> createDdUserRelByScmUser(instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DdUserRel <span class="title function_">createDdUserRelByBusinessUser</span><span class="params">(ApprovalFormInstance dto)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 根据业务系统用户id查询用户详情</span></span><br><span class="line">    <span class="type">UserResponse</span> <span class="variable">userResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过手机号码查询钉钉用户id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ddUserId</span> <span class="operator">=</span> DingTalkUserInfoClient.getUserIdByMobile(userResponse.getMobile());</span><br><span class="line">    <span class="comment">// 通过钉钉用户id查询钉钉用户详情</span></span><br><span class="line">    OapiV2UserGetResponse.<span class="type">UserGetResponse</span> <span class="variable">ddUserRsp</span> <span class="operator">=</span> DingTalkUserInfoClient.getUserById(ddUserId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增关联对象</span></span><br><span class="line">    <span class="type">DdUserRel</span> <span class="variable">newEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DdUserRel</span>();</span><br><span class="line">    newEntity.setTenantId(dto.getTenantId());</span><br><span class="line">    newEntity.setScmUserId(dto.getUserId());</span><br><span class="line">    newEntity.setDdUserId(ddUserId);</span><br><span class="line">    newEntity.setDdUserName(userResponse.getUserName());</span><br><span class="line">    newEntity.setUserMobile(userResponse.getMobile());</span><br><span class="line">    newEntity.setDdDeptId(ddUserRsp.getDeptIdList().get(<span class="number">0</span>));</span><br><span class="line">    ddUserRelDao.save(newEntity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过业务用户信息查询钉钉用户详情时，关键参数是“手机号码”。同理，也可以通过钉钉用户的手机号码查询业务用户详情，在“钉钉OA审批回调事件”中就会用到此方法。</p><p>还有点需要注意的是，钉钉API目前只支持通过id查详情（不仅限于查询用户详情接口），所以针对查询钉钉id数据的接口，可以统一封装要求返回id不能为空。</p><h4 id="发起审批实例"><a class="header-anchor" href="#发起审批实例"></a>发起审批实例</h4><p>在第一步和第二步中分别拿到了发起审批实例需要的审批模板编号和审批发起人id，所以现在只需要准备表单数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起审批实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> instance          审批表单流程实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ddUserRel         钉钉用户关联数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ddApprovalFormRel 钉钉审批表单关联数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> instanceId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">processInstances</span><span class="params">(ApprovalFormInstance instance, DdUserRel ddUserRel, DdApprovalFormRel ddApprovalFormRel,</span></span><br><span class="line"><span class="params">                                      Supplier&lt;StartProcessInstanceRequestFormComponentValues&gt;... expandValues)</span> &#123;</span><br><span class="line">    <span class="type">ApprovalFormEngine</span> <span class="variable">approvalForm</span> <span class="operator">=</span> instance.getApprovalForm();</span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    <span class="type">StartProcessInstanceHeaders</span> <span class="variable">startProcessInstanceHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartProcessInstanceHeaders</span>();</span><br><span class="line">    startProcessInstanceHeaders.setXAcsDingtalkAccessToken(DingTalkAuthManager.getToken());</span><br><span class="line">    <span class="comment">// 构建表单控件元素</span></span><br><span class="line">    List&lt;StartProcessInstanceRequestFormComponentValues&gt; formComponentValues = approvalForm.buildFormComponentValues();</span><br><span class="line">    <span class="comment">// 组装扩展控件值</span></span><br><span class="line">    <span class="keyword">for</span> (Supplier&lt;StartProcessInstanceRequestFormComponentValues&gt; supplier : expandValues) &#123;</span><br><span class="line">        <span class="type">StartProcessInstanceRequestFormComponentValues</span> <span class="variable">value</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            formComponentValues.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表单实例请求对象</span></span><br><span class="line">    <span class="type">StartProcessInstanceRequest</span> <span class="variable">startProcessInstanceRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartProcessInstanceRequest</span>()</span><br><span class="line">            .setOriginatorUserId(ddUserRel.getDdUserId())</span><br><span class="line">            .setProcessCode(ddApprovalFormRel.getProcessCode())</span><br><span class="line">            .setDeptId(ddUserRel.getDdDeptId())</span><br><span class="line">            .setMicroappAgentId(DingTalkConfig.getTenantPropertiesValue(DingTalkTenantProperties::getAgentId))</span><br><span class="line">            .setFormComponentValues(formComponentValues);</span><br><span class="line">    <span class="comment">// 创建Client并发送请求</span></span><br><span class="line">    <span class="type">Client</span> <span class="variable">workflowClient</span> <span class="operator">=</span> DingTalkApiClientUtil.createWorkflowClient();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">StartProcessInstanceResponse</span> <span class="variable">response</span> <span class="operator">=</span> workflowClient.startProcessInstanceWithOptions(</span><br><span class="line">                startProcessInstanceRequest, startProcessInstanceHeaders, <span class="keyword">new</span> <span class="title class_">RuntimeOptions</span>()</span><br><span class="line">        );</span><br><span class="line">        log.info(<span class="string">&quot;[DingTalkWorkflowClient]processInstances: &#123;&#125;&quot;</span>, JSON.toJSONString(response));</span><br><span class="line">        <span class="keyword">return</span> response.getBody().getInstanceId();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TeaException err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception _err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TeaException</span>(_err.getMessage(), _err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，由于当初开发时间节点问题以及业务需求的渗透，该方法没有经过 service 做二次封装，所以在扩展性方面不够友好，为了兼容业务需要的特殊控件，在构建表单控件元素时引入了扩展参数。</p><h3 id="审批事件回调"><a class="header-anchor" href="#审批事件回调"></a>审批事件回调</h3><p>钉钉回调事件是一个统一入口，OA审批事件是其中的一种。</p><p>注册钉钉回调事件分为Http、Stream两种，这里只展示Stream方式接入。</p><h4 id="业务回调使用方式"><a class="header-anchor" href="#业务回调使用方式"></a>业务回调使用方式</h4><p>业务实现审批回调后置处理的入口就是在Bean对象的方法上加上自定义注解 <code>ApprovalCallback</code> ，并配置相应的业务类型值、审批事件类型即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApprovalCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务审批类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BusinessApprovalTypeEnum <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批事件类型</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;默认所有审批事件都回调&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ApprovalEventType <span class="title function_">eventType</span><span class="params">()</span> <span class="keyword">default</span> ApprovalEventType.ALL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在业务项目的OA审批中，审批结果大致分为审批同意、审批拒绝、审批中，所以审批事件类型枚举类就设计为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ApprovalEventType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有审批事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALL,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批 - 同意</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AGREE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批 - 拒绝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REJECT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批 - 进行中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IN_PROGRESS</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ALL</code> 表示所有审批结果。</p><h4 id="回调方法实现原理"><a class="header-anchor" href="#回调方法实现原理"></a>回调方法实现原理</h4><p>在Spring启动应用上下文时，指定扫描自定义的 <code>DingTalkCallbackProcessor</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DingTalkCallbackProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(<span class="meta">@NonNull</span> Object bean, <span class="meta">@NonNull</span> String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">        <span class="comment">// Bean初始化前, 扫描Bean的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : findAllMethod(clazz)) &#123;</span><br><span class="line">            processMethod(bean, method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processMethod</span><span class="params">(Object bean, Method method)</span> &#123;</span><br><span class="line">        <span class="type">ApprovalCallback</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(method, ApprovalCallback.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法的入参，要求回调方法的入参个数有切仅有一个，并且入参对象继承自DingTalkCallbackEvent</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        Preconditions.checkArgument(parameterTypes.length == <span class="number">1</span>,</span><br><span class="line">                <span class="string">&quot;Invalid number of parameters: %s for method: %s, should be 1&quot;</span>, parameterTypes.length,</span><br><span class="line">                method);</span><br><span class="line">        Preconditions.checkArgument(DingTalkCallbackEvent.class.isAssignableFrom(parameterTypes[<span class="number">0</span>]),</span><br><span class="line">                <span class="string">&quot;Invalid parameter type: %s for method: %s, should be DingTalkCallbackEvent&quot;</span>, parameterTypes[<span class="number">0</span>],</span><br><span class="line">                method);</span><br><span class="line"></span><br><span class="line">        ReflectionUtils.makeAccessible(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个钉钉回调监听器，回调实现方法默认调用当前bean对象的方法</span></span><br><span class="line">        <span class="type">DingTalkCallbackListener</span> <span class="variable">dingTalkCallbackListener</span> <span class="operator">=</span> (callbackEvent) -&gt;</span><br><span class="line">                ReflectionUtils.invokeMethod(method, bean, callbackEvent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将监听器添加到缓存</span></span><br><span class="line">        DingTalkConfig.addCallbackListener(annotation, dingTalkCallbackListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Method&gt; <span class="title function_">findAllMethod</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Method&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        ReflectionUtils.doWithMethods(clazz, res::add);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DingTalkCallbackProcessor</code> 类会在启动时，扫描所有Bean对象，并将带有 <code>ApprovalCallback</code> 注解的方法添加到容器中。</p><p>容器的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DingTalkConfig</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 回调监听器的k-v为：业务审批类型 -&gt; 审批事件类型 -&gt; 监听器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;BusinessApprovalTypeEnum, Map&lt;ApprovalEventType, List&lt;DingTalkCallbackListener&gt;&gt;&gt; CALLBACK_LISTENER_MAP;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      CALLBACK_LISTENER_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addCallbackListener</span><span class="params">(ApprovalCallback annotation, DingTalkCallbackListener listener)</span> &#123;</span><br><span class="line">        Map&lt;ApprovalEventType, List&lt;DingTalkCallbackListener&gt;&gt; eventTypeMap = CALLBACK_LISTENER_MAP.computeIfAbsent(</span><br><span class="line">                annotation.value(), t -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">ApprovalEventType</span> <span class="variable">approvalEventType</span> <span class="operator">=</span> annotation.eventType();</span><br><span class="line">        <span class="keyword">if</span> (ApprovalEventType.ALL.equals(approvalEventType)) &#123;</span><br><span class="line">            addCallbackListener(eventTypeMap, ApprovalEventType.AGREE, listener);</span><br><span class="line">            addCallbackListener(eventTypeMap, ApprovalEventType.REJECT, listener);</span><br><span class="line">            addCallbackListener(eventTypeMap, ApprovalEventType.IN_PROGRESS, listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addCallbackListener(eventTypeMap, approvalEventType, listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addCallbackListener</span><span class="params">(Map&lt;ApprovalEventType, List&lt;DingTalkCallbackListener&gt;&gt; eventTypeMap,</span></span><br><span class="line"><span class="params">                                            ApprovalEventType approvalEventType,</span></span><br><span class="line"><span class="params">                                            DingTalkCallbackListener listener)</span> &#123;</span><br><span class="line">        List&lt;DingTalkCallbackListener&gt; listeners = eventTypeMap.get(approvalEventType);</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="literal">null</span>) &#123;</span><br><span class="line">            listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">        eventTypeMap.put(approvalEventType, listeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;DingTalkCallbackListener&gt; <span class="title function_">getCallbackListener</span><span class="params">(BusinessApprovalTypeEnum approvalTypeEnum,</span></span><br><span class="line"><span class="params">                                                                     ApprovalEventType approvalEventType)</span> &#123;</span><br><span class="line">        Map&lt;ApprovalEventType, List&lt;DingTalkCallbackListener&gt;&gt; eventTypeMap = CALLBACK_LISTENER_MAP.get(approvalTypeEnum);</span><br><span class="line">        <span class="keyword">if</span> (eventTypeMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eventTypeMap.get(approvalEventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注解将对应的监听器存放到指定key下，等钉钉回调时，根据钉钉审批回调数据判断审批事件类型，再通过业务审批关联表获取对应的业务审批类型，就可以拿到指定的监听器，发起回调。</p><h4 id="回调统一处理方法"><a class="header-anchor" href="#回调统一处理方法"></a>回调统一处理方法</h4><p>上文已经说过，钉钉事件回调可以通过Stream方法接入，钉钉用 <code>OpenDingTalkClient</code> 表示钉钉客户端接口，接口就两个方法：启动、停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OpenDingTalkClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例化客户端时，往里面插入事件监听器，再启动，就可以实现钉钉事件回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 钉钉客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;OpenDingTalkClient&gt; CLIENTS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册钉钉事件Stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerEventStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    Collection&lt;DingTalkTenantProperties&gt; allUniqueAppKeyTenantProperties = DingTalkConfig.getUniqueAppKeyTenantProperties();</span><br><span class="line">    List&lt;OpenDingTalkClient&gt; clientList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(allUniqueAppKeyTenantProperties.size());</span><br><span class="line">    <span class="keyword">for</span> (DingTalkTenantProperties properties : allUniqueAppKeyTenantProperties) &#123;</span><br><span class="line">        <span class="type">OpenDingTalkClient</span> <span class="variable">dingTalkClient</span> <span class="operator">=</span> OpenDingTalkStreamClientBuilder</span><br><span class="line">                .custom()</span><br><span class="line">                .credential(<span class="keyword">new</span> <span class="title class_">AuthClientCredential</span>(properties.getAppKey(), properties.getAppSecret()))</span><br><span class="line">                <span class="comment">// 注册事件监听</span></span><br><span class="line">                .registerAllEventListener(<span class="keyword">new</span> <span class="title class_">ApprovalCallbackEventListener</span>())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dingTalkClient.start();</span><br><span class="line">            clientList.add(dingTalkClient);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;钉钉AppKey为[&quot;</span> + properties.getAppKey() + <span class="string">&quot;]的Stream Client启用失败&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭已启动的client</span></span><br><span class="line">    <span class="keyword">for</span> (OpenDingTalkClient client : CLIENTS) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            status = <span class="literal">false</span>;</span><br><span class="line">            log.error(<span class="string">&quot;钉钉Client关闭失败&quot;</span>, e);</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CLIENTS.clear();</span><br><span class="line">    CLIENTS.addAll(clientList);</span><br><span class="line">    log.info(<span class="string">&quot;钉钉Client注册列表: &quot;</span> + allUniqueAppKeyTenantProperties);</span><br><span class="line">    log.info(<span class="string">&quot;钉钉Client注册&quot;</span> + (status ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;异常&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>ApprovalCallbackEventListener</code> 就是我们自定义实现的回调OA审批事件监听器，它需要实现钉钉的 <code>GenericEventListener</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericEventListener</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">GenericEventListener</span> <span class="variable">DEFAULT</span> <span class="operator">=</span> event -&gt; EventAckStatus.SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EventAckStatus <span class="title function_">onEvent</span><span class="params">(<span class="keyword">final</span> GenericOpenDingTalkEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApprovalCallbackEventListener</code> 类继承 <code>AbstractDingTalkStreamEventListener</code> 类，表示OA审批回调监听器继承了钉钉回调事件监听器的功能。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDingTalkStreamEventListener</span> <span class="keyword">implements</span> <span class="title class_">GenericEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批任务回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BPMS_TASK_CHANGE</span> <span class="operator">=</span> <span class="string">&quot;bpms_task_change&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审批实例回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BPMS_INSTANCE_CHANGE</span> <span class="operator">=</span> <span class="string">&quot;bpms_instance_change&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EventAckStatus <span class="title function_">onEvent</span><span class="params">(GenericOpenDingTalkEvent event)</span> &#123;</span><br><span class="line">        MDC.put(<span class="string">&quot;traceId&quot;</span>, UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;钉钉回调事件对象: &quot;</span> + JSON.toJSONString(event));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//事件类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">eventType</span> <span class="operator">=</span> event.getEventType();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确定事件类型，决定data</span></span><br><span class="line">            <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">                <span class="keyword">case</span> BPMS_TASK_CHANGE:</span><br><span class="line">                <span class="keyword">case</span> BPMS_INSTANCE_CHANGE:</span><br><span class="line">                    <span class="type">DingTalkCallbackChange</span> <span class="variable">change</span> <span class="operator">=</span> BeanUtil.copyProperties(event, DingTalkCallbackChange.class);</span><br><span class="line">                    handleApprovalEvent(change);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="comment">// 未知的事件类型，忽略</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//消费成功</span></span><br><span class="line">            <span class="keyword">return</span> EventAckStatus.SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;钉钉回调事件消费失败&quot;</span>, e);</span><br><span class="line">            <span class="comment">//消费失败</span></span><br><span class="line">            <span class="keyword">return</span> EventAckStatus.LATER;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MDC.remove(<span class="string">&quot;traceId&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleApprovalEvent</span><span class="params">(DingTalkCallbackChange eventChange)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApprovalCallbackEventListener</span> <span class="keyword">extends</span> <span class="title class_">AbstractDingTalkStreamEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DdApprovalBusinessRelService ddApprovalBusinessRelService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DdUserRelService ddUserRelService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DdApprovalProcessLogService ddApprovalProcessLogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleApprovalEvent</span><span class="params">(DingTalkCallbackChange eventChange)</span> &#123;</span><br><span class="line">        <span class="type">ApprovalCallbackEvent</span> <span class="variable">approvalCallbackEvent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApprovalCallbackEvent</span>();</span><br><span class="line"></span><br><span class="line">        ApprovalBaseChange approvalBaseChange;</span><br><span class="line">        <span class="keyword">if</span> (BPMS_TASK_CHANGE.equals(eventChange.getEventType())) &#123;</span><br><span class="line">            approvalCallbackEvent.setApprovalEventType(ApprovalEventType.IN_PROGRESS);</span><br><span class="line">            approvalBaseChange = BeanUtil.copyProperties(eventChange.getData(), ApprovalTaskChange.class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ApprovalInstanceChange</span> <span class="variable">instanceChange</span> <span class="operator">=</span> BeanUtil.copyProperties(eventChange.getData(), ApprovalInstanceChange.class);</span><br><span class="line">            approvalBaseChange = instanceChange;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ApprovalProcessType.TYPE_FINISH.equals(instanceChange.getType())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ApprovalProcessType.RESULT_AGREE.equals(instanceChange.getResult())) &#123;</span><br><span class="line">                    approvalCallbackEvent.setApprovalEventType(ApprovalEventType.AGREE);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ApprovalProcessType.RESULT_REFUSE.equals(instanceChange.getResult())) &#123;</span><br><span class="line">                    approvalCallbackEvent.setApprovalEventType(ApprovalEventType.REJECT);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;未知的审批实例结果. instanceChange: &quot;</span> + instanceChange);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ApprovalProcessType.TYPE_TERMINATE.equals(instanceChange.getType())) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发起人撤销审批单. instanceChange: &quot;</span> + instanceChange);</span><br><span class="line">                approvalCallbackEvent.setApprovalEventType(ApprovalEventType.REJECT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;未知的审批实例状态变更类型. instanceChange: &quot;</span> + instanceChange);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置事件基础值</span></span><br><span class="line">        approvalBaseChange.setEventId(eventChange.getEventId());</span><br><span class="line">        approvalBaseChange.setEventType(eventChange.getEventType());</span><br><span class="line">        approvalBaseChange.setEventBornTime(eventChange.getEventBornTime());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询审批实例对应的租户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">tenantId</span> <span class="operator">=</span> <span class="built_in">this</span>.getDdApprovalBusinessRelService().getTenantIdByInstance(approvalBaseChange.getProcessInstanceId());</span><br><span class="line">        <span class="keyword">if</span> (tenantId == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;无法确定钉钉审批实例对应的租户信息，请确认审批实例数据来源是否合规.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 业务系统 手动切换数据源</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 上下文配置租户信息</span></span><br><span class="line">            DingTalkConfig.setTenantIdContext(tenantId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据流程实例id 查询审批业务关联单据</span></span><br><span class="line">            <span class="type">DdApprovalBusinessRel</span> <span class="variable">ddApprovalBusinessRel</span> <span class="operator">=</span> <span class="built_in">this</span>.getDdApprovalBusinessRelService().getDdApprovalBusinessRelByInstance(approvalBaseChange.getProcessInstanceId());</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">tenantName</span> <span class="operator">=</span> DingTalkConfig.getTenantPropertiesValue(tenantId, DingTalkTenantProperties::getTenantName);</span><br><span class="line">            <span class="keyword">if</span> (ddApprovalBusinessRel == <span class="literal">null</span>) &#123;</span><br><span class="line">                log.error(String.format(<span class="string">&quot;租户[%s]审批实例不存在, instanceId: %s&quot;</span>, tenantName, approvalBaseChange.getProcessInstanceId()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据code获取枚举</span></span><br><span class="line">            <span class="type">BusinessApprovalTypeEnum</span> <span class="variable">approvalTypeEnum</span> <span class="operator">=</span> BusinessApprovalTypeEnum.getApprovalFormEnum(ddApprovalBusinessRel.getTypeCode());</span><br><span class="line">            <span class="keyword">if</span> (approvalTypeEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">                log.error(String.format(<span class="string">&quot;租户[%s]找不到对应的业务审批类型，请确认是否进行过变更。业务审批关联数据: %s&quot;</span>, tenantName, ddApprovalBusinessRel));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取审批人</span></span><br><span class="line">            <span class="type">DdUserRel</span> <span class="variable">ddUserRel</span> <span class="operator">=</span> getDdUserRelService().resolveDdUserRel(tenantId, approvalBaseChange.getStaffId());</span><br><span class="line">            <span class="keyword">if</span> (ddUserRel == <span class="literal">null</span>) &#123;</span><br><span class="line">                log.warn(String.format(<span class="string">&quot;租户[%s]无法找到可以关联的用户，钉钉用户id为[%s]&quot;</span>, tenantName, approvalBaseChange.getStaffId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                approvalCallbackEvent.setUserId(ddUserRel.getScmUserId());</span><br><span class="line">                approvalBaseChange.setStaffName(ddUserRel.getDdUserName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据审批任务生成审批流程日志</span></span><br><span class="line">            <span class="keyword">if</span> (approvalBaseChange <span class="keyword">instanceof</span> ApprovalTaskChange) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getDdApprovalProcessLogService().generateLog((ApprovalTaskChange) approvalBaseChange, tenantId, ddApprovalBusinessRel.getId());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据枚举+钉钉事件类型 调用监听的方法</span></span><br><span class="line">            List&lt;DingTalkCallbackListener&gt; listeners = DingTalkConfig.getCallbackListener(approvalTypeEnum, approvalCallbackEvent.getApprovalEventType());</span><br><span class="line">            <span class="keyword">if</span> (listeners == <span class="literal">null</span>) &#123;</span><br><span class="line">                log.warn(String.format(<span class="string">&quot;租户[%s]未配置审批类型为[%s],事件类型为[%s]的回调监听器, 跳过钉钉回调事件&quot;</span>, tenantName, approvalTypeEnum.getName(), approvalCallbackEvent.getApprovalEventType().name()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 填充回调事件对象数据</span></span><br><span class="line">            approvalCallbackEvent.setEventId(eventChange.getEventId());</span><br><span class="line">            approvalCallbackEvent.setEventType(eventChange.getEventType());</span><br><span class="line">            approvalCallbackEvent.setEventBornTime(eventChange.getEventBornTime());</span><br><span class="line">            approvalCallbackEvent.setTenantId(tenantId);</span><br><span class="line">            approvalCallbackEvent.setBusinessId(ddApprovalBusinessRel.getBusinessId());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 业务回调处理</span></span><br><span class="line">            <span class="keyword">for</span> (DingTalkCallbackListener listener : listeners) &#123;</span><br><span class="line">                listener.callback(approvalCallbackEvent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(String.format(<span class="string">&quot;租户[%s]处理钉钉回调事件完成, 回调事件对象: %s&quot;</span>, tenantName, approvalCallbackEvent));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DingTalkConfig.removeTenantIdContext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DdApprovalProcessLogService <span class="title function_">getDdApprovalProcessLogService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.ddApprovalProcessLogService == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.ddApprovalProcessLogService = SpringUtil.getBean(DdApprovalProcessLogService.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ddApprovalProcessLogService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DdApprovalBusinessRelService <span class="title function_">getDdApprovalBusinessRelService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.ddApprovalBusinessRelService == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.ddApprovalBusinessRelService = SpringUtil.getBean(DdApprovalBusinessRelService.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ddApprovalBusinessRelService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DdUserRelService <span class="title function_">getDdUserRelService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.ddUserRelService == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.ddUserRelService = SpringUtil.getBean(DdUserRelService.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ddUserRelService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractDingTalkStreamEventListener</code> 通过模板模式，将审批事件的实现方法进行抽象。这样做的目的是为了后期可能会接入钉钉的其他事件类型，例如通讯录变更事件。。。</p><p>在 <code>ApprovalCallbackEventListener</code> 重写的 <code>handleApprovalEvent</code> 方法的最后，可以看到通过遍历 <code>listeners</code> 变量，回调了业务方法。</p><h4 id="回调的流程记录"><a class="header-anchor" href="#回调的流程记录"></a>回调的流程记录</h4><p>钉钉OA审批流程记录的数据与审批任务是保持一致的，因此在审批事件回调中，对审批事件类型为审批任务的事件进行拦截处理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DdApprovalProcessLogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DdApprovalProcessLogDao ddApprovalProcessLogDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DdApprovalProcessLogAttachmentDao ddApprovalProcessLogAttachmentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateLog</span><span class="params">(ApprovalTaskChange taskChange, Long tenantId, Long businessRelId)</span> &#123;</span><br><span class="line">        <span class="comment">// 钉钉事件id已存在业务系统数据表中，忽略重复请求</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> ddApprovalProcessLogDao.lambdaQuery()</span><br><span class="line">                .eq(DdApprovalProcessLog::getTenantId, tenantId)</span><br><span class="line">                .eq(DdApprovalProcessLog::getEventId, taskChange.getEventId())</span><br><span class="line">                .count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 已生成日志 ignore</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存审批流程记录</span></span><br><span class="line">        <span class="type">DdApprovalProcessLog</span> <span class="variable">approvalProcessLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DdApprovalProcessLog</span>();</span><br><span class="line">        approvalProcessLog.setTenantId(tenantId);</span><br><span class="line">        approvalProcessLog.setBusinessRelId(businessRelId);</span><br><span class="line">        approvalProcessLog.setEventId(taskChange.getEventId());</span><br><span class="line">        approvalProcessLog.setTaskId(taskChange.getTaskId());</span><br><span class="line">        approvalProcessLog.setStaffId(taskChange.getStaffId());</span><br><span class="line">        approvalProcessLog.setStaffName(taskChange.getStaffName());</span><br><span class="line">        approvalProcessLog.setProcessContent(taskChange.getContent() != <span class="literal">null</span> ? taskChange.getContent() : taskChange.getRemark());</span><br><span class="line">        approvalProcessLog.setCreateTime(taskChange.getEventBornTime());</span><br><span class="line">        <span class="type">ApprovalProcessType</span> <span class="variable">processType</span> <span class="operator">=</span> ApprovalProcessType.confirmProcessType(taskChange.getType(), taskChange.getResult());</span><br><span class="line">        approvalProcessLog.setProcessType(processType.getCode());</span><br><span class="line">        ddApprovalProcessLogDao.save(approvalProcessLog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前审批操作中附带的附件</span></span><br><span class="line">        <span class="built_in">this</span>.saveLogAttachment(taskChange, tenantId, approvalProcessLog.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveLogAttachment</span><span class="params">(ApprovalTaskChange taskChange, Long tenantId, Long logId)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询审批实例详情</span></span><br><span class="line">        GetProcessInstanceResponseBody.<span class="type">GetProcessInstanceResponseBodyResult</span> <span class="variable">instanceResponse</span> <span class="operator">=</span> DingTalkWorkflowClient.getProcessInstanceById(taskChange.getProcessInstanceId());</span><br><span class="line">        List&lt;GetProcessInstanceResponseBody.GetProcessInstanceResponseBodyResultOperationRecords&gt; operationRecords = instanceResponse.getOperationRecords();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm&#x27;Z&#x27;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">eventBornTime</span> <span class="operator">=</span> simpleDateFormat.format(taskChange.getEventBornTime());</span><br><span class="line">        <span class="comment">// 遍历审批实例详情中的操作记录，找到与当前审批操作匹配的记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> operationRecords.size() - <span class="number">1</span>; len &gt;= <span class="number">0</span>; len--) &#123;</span><br><span class="line">            GetProcessInstanceResponseBody.<span class="type">GetProcessInstanceResponseBodyResultOperationRecords</span> <span class="variable">records</span> <span class="operator">=</span> operationRecords.get(len);</span><br><span class="line">            <span class="keyword">if</span> (!taskChange.getStaffId().equals(records.getUserId())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!eventBornTime.equals(records.getDate())) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(records.getDate());</span><br><span class="line">                    <span class="type">long</span> <span class="variable">after</span> <span class="operator">=</span> parse.getTime() + (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (after &lt; taskChange.getEventBornTime().getTime()) &#123;</span><br><span class="line">                        <span class="comment">// 操作记录的时间点 小于 事件发生的事件点</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                    <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 匹配到审批操作记录，判断当前审批操作是否携带附件</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(records.getAttachments())) &#123;</span><br><span class="line">                List&lt;String&gt; fileIdList = records.getAttachments()</span><br><span class="line">                        .stream()</span><br><span class="line">                        .map(GetProcessInstanceResponseBody.GetProcessInstanceResponseBodyResultOperationRecordsAttachments::getFileId)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">                <span class="comment">// 为附件临时授权可访问</span></span><br><span class="line">                DingTalkWorkflowClient.authorizeApprovalDentry(fileIdList);</span><br><span class="line">                <span class="comment">// 遍历获取附件信息并上传到业务系统文件服务器，保存审批流程记录的附件信息</span></span><br><span class="line">                <span class="keyword">for</span> (GetProcessInstanceResponseBody.GetProcessInstanceResponseBodyResultOperationRecordsAttachments attachment : records.getAttachments()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">wyysFileUrl</span> <span class="operator">=</span> <span class="built_in">this</span>.uploadFileToBusinessSystem(attachment.getFileId(), attachment.getFileName());</span><br><span class="line">                    <span class="keyword">if</span> (wyysFileUrl == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">DdApprovalProcessLogAttachment</span> <span class="variable">logAttachment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DdApprovalProcessLogAttachment</span>();</span><br><span class="line">                    logAttachment.setTenantId(tenantId);</span><br><span class="line">                    logAttachment.setLogId(logId);</span><br><span class="line">                    logAttachment.setFileName(attachment.getFileName());</span><br><span class="line">                    logAttachment.setFileType(attachment.getFileType());</span><br><span class="line">                    logAttachment.setFileUrl(wyysFileUrl);</span><br><span class="line">                    ddApprovalProcessLogAttachmentDao.save(logAttachment);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">uploadFileToBusinessSystem</span><span class="params">(String fileId, String fileName)</span> &#123;</span><br><span class="line">        GetFileDownloadInfoResponseBody.<span class="type">GetFileDownloadInfoResponseBodyHeaderSignatureInfo</span> <span class="variable">headerSignatureInfo</span> <span class="operator">=</span> DingTalkStorageClient.getFileDownloadInfo(fileId);</span><br><span class="line">        <span class="keyword">if</span> (headerSignatureInfo == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// http下载文件</span></span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> HttpRequest.post(headerSignatureInfo.getResourceUrls().get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : headerSignatureInfo.getHeaders().entrySet()) &#123;</span><br><span class="line">            httpRequest.header(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> httpRequest.execute();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> httpResponse.bodyStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存到业务系统文件服务器，并返回全量路径地址</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><ol><li>钉钉开放平台的接口太“开放”了，大多数请求基本上都很难通过一个接口搞定。但人家这样设计自然有它的道理，个人猜想它的设计思路：<ol><li>从功能模块方面：将每个接口所做的功能尽可能细化，做到服务端实现逻辑的解耦。</li><li>从接口响应方面：因为接口功能涉及影响面较小，需要处理的数据交互也小很多，响应时间也会缩短。</li></ol></li><li>在搭建整个钉钉OA审批框架时，在包定义、类名定义上不够严谨，感觉子模块的区分还是没有做好，Config与Model有点混乱，还是需要多看看大佬的框架源码。</li><li>Client的异常处理，还是没有想出好的方法做通用处理，每个方法都要try-catch一模一样的内容。</li><li>没有考虑高并发情况，核心模块需要做锁处理；另外，没有考虑分布式微服务场景。</li><li>审批回调的重试机制不能单方面依赖钉钉，需要自己做一层异常重试处理机制；此外，钉钉重试间隔时间很短暂，因此回调处理时间不能太长。可以结合自己做异常重试机制，将回调事件做异步操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作小结 </tag>
            
            <tag> OA审批 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages配置到个人站点</title>
      <link href="/2023/08/29/hexo-github-site/"/>
      <url>/2023/08/29/hexo-github-site/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建GitHub-Pages"><a class="header-anchor" href="#搭建GitHub-Pages"></a>搭建GitHub Pages</h2><p>首先，需要搭建好自己的GitHub Pages，保证访问xxx.github.io正常。</p><p>使用Hexo搭建的文档地址：</p><p><a href="https://blog.itwray.com/2023/07/28/hexo-study/">https://blog.itwray.com/2023/07/28/hexo-study/</a></p><h2 id="配置个人域名"><a class="header-anchor" href="#配置个人域名"></a>配置个人域名</h2><p>在各大云服务厂商都可以购买域名，这里展示使用阿里云购买域名的操作步骤。</p><p>一、注册域名</p><p>进入<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.34.532c4f153NDovr">阿里云注册域名地址</a></p><p><img src="/2023/08/29/hexo-github-site/image-20230829110239853.png" alt="image-20230829110239853"></p><p>输入自己想要的域名，并选择想要的根域名，点击查找，若域名未注册，可直接加入清单进行购买。</p><p>购买完后，域名需要实名认证。</p><p>二、域名解析配置</p><p>在阿里云的<code>域名列表</code>找到自己购买的域名，点击<code>解析</code>，进入<code>解析设置</code>页面。</p><p><img src="/2023/08/29/hexo-github-site/image-20230829111326607.png" alt="image-20230829111326607"></p><p>为站点配置两条主机记录，分别为 @、www 类型。</p><p>@的主机记录：记录值是ip地址，可以通过 ping xxx.github.io 查看。</p><p>www的主机记录：记录值就是自己的xxx.github.io地址，记录类型选择为CNAME。</p><h2 id="GitHub-Pages绑定自定义域名"><a class="header-anchor" href="#GitHub-Pages绑定自定义域名"></a>GitHub Pages绑定自定义域名</h2><p>绑定方式有两种：GitHub Settings、Hexo CNAME文件</p><p><strong>第一种：GitHub Settings</strong></p><p>GitHub官方有一个操作文档，用于手动在GitHub上配置自己的域名：</p><p><a href="https://docs.github.com/en/pages/quickstart">https://docs.github.com/en/pages/quickstart</a></p><p>最终效果如下：</p><p><img src="/2023/08/29/hexo-github-site/image-20230829113637633.png" alt="image-20230829113637633"></p><br><p><strong>第二种：Hexo CNAME文件</strong></p><p>Hexo支持动态配置，只需要在hexo git根目录下的source目录下，创建一个CNAME文件，文件内容就是自己的域名地址。</p><p><img src="/2023/08/29/hexo-github-site/image-20230829113055624.png" alt="image-20230829113055624"></p><p>然后执行 <code>hexo d</code> 命令将这个文件上传到GitHub即可。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub Pages </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作小结-钉钉OA审批</title>
      <link href="/2023/08/25/work-report-ddoa/"/>
      <url>/2023/08/25/work-report-ddoa/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2><p>因为业务需求原因，业务单据的审批功能需要接入到钉钉OA审批上。</p><p>因为未接触过钉钉OA审批这方面的东西，所以第一步肯定是打开<a href="https://open.dingtalk.com/">钉钉开放平台</a>。</p><p><img src="/2023/08/25/work-report-ddoa/image-20230825155240047.png" alt="image-20230825155240047"></p><p>进了开放平台，肯定就得找文档，不过我看到了搜索框，既然明确自己需要查询<strong>OA审批</strong>，那就直接搜索了。</p><p><img src="/2023/08/25/work-report-ddoa/image-20230825155422768.png" alt="image-20230825155422768"></p><p>根据搜索结果，有两百多条，可见找对地方了。看推荐提示，钉钉的OA审批有多种（官方、自有...），点进“官方OA审批”。</p><p><img src="/2023/08/25/work-report-ddoa/image-20230825155626324.png" alt="image-20230825155626324"></p><p>结果跑进“常见问题”来了，切换目录到“概述”，先了解下整个OA审批。</p><p><img src="/2023/08/25/work-report-ddoa/image-20230825155802447.png" alt="image-20230825155802447"></p><p>文档内容“一目了然”（接口参数文档和错误码解释给我整麻了），也确定了OA审批分为了“官方OA审批”和“自有OA审批”两种。</p><p>把目录菜单都大致点完一遍，总结如下：</p><ul><li>官方OA审批是走的钉钉审批流；自有OA审批只是做了层跳转和展示，可用于多系统的统一审批入口。</li><li>OA审批的元素有：审批表单、审批实例、审批任务。</li><li>审批单据里面的附件是必须要上传到钉钉的钉盘，才能展示到审批详情里面的。</li><li>审批回调需要单独配置，属于钉钉事件订阅中的一种，事件推送方式有HTTP推送、Stream推送两种（个人推荐首选Stream方式），配置完推送方式后还需要配置需要订阅的事件。</li><li>HTTP推送就是将公网地址接口提供给钉钉，让钉钉回调；Stream推送是业务系统与钉钉开放平台通过Websocket连接。Stream模式介绍：<a href="https://open.dingtalk.com/document/resourcedownload/Introduction-to-stream-mode">服务端Stream模式</a></li><li>与钉钉开放平台的API交互，全程都要有token，因此在<strong>应用开发</strong>中需要配置钉钉应用，获取对应的AppKey、AppSecret，通过AK和AS调用接口获取token。</li><li>使用钉钉开放平台的OA审批功能，是需要钉钉用户具有开发者权限的（偷懒方式是直接使用拥有主管理员权限的账号），也需要开启应用的接口权限，在<strong>应用开发-权限管理</strong>下申请如下权限：<ul><li>成员信息读权限</li><li>工作流实例写权限</li><li>OA审批和存储的所有权限 （工作流模板写权限、工作流模板读权限）</li><li>根据手机号姓名获取成员信息的接口访问权限</li></ul></li></ul><h2 id="官方OA审批示例"><a class="header-anchor" href="#官方OA审批示例"></a>官方OA审批示例</h2><p>了解文档大致后，与需求方确定使用“官方OA审批”，因此后续示例中都默认表示官方OA审批的demo。</p><p>接下来，将通过发起一个OA审批单来展示调用API的全过程。</p><h3 id="添加maven依赖"><a class="header-anchor" href="#添加maven依赖"></a>添加maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 钉钉新版SDK --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dingtalk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 截止20230825的最新版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 钉钉旧版SDK --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>alibaba-dingtalk-service-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 钉钉事件回调Stream推送SDK --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dingtalk.open<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>app-stream-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取token"><a class="header-anchor" href="#获取token"></a>获取token</h3><p>在概述里也说明了，钉钉开放平台的所有接口基本都是需要使用token的，一是确保数据安全，二是根据token识别钉钉企业。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetTokenSample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DingTalkClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultDingTalkClient</span>(<span class="string">&quot;https://oapi.dingtalk.com/gettoken&quot;</span>);</span><br><span class="line">            <span class="type">OapiGettokenRequest</span> <span class="variable">req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OapiGettokenRequest</span>();</span><br><span class="line">            req.setAppkey(<span class="string">&quot;AppKey&quot;</span>);</span><br><span class="line">            req.setAppsecret(<span class="string">&quot;AppSecret&quot;</span>);</span><br><span class="line">            req.setHttpMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">            <span class="type">OapiGettokenResponse</span> <span class="variable">rsp</span> <span class="operator">=</span> client.execute(req);</span><br><span class="line">            System.out.println(rsp.getBody());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ApiException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印响应数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;errcode&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;7011eb7b5a5e37c694b18c6c79406111&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;errmsg&quot;</span><span class="punctuation">:</span><span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span><span class="number">7200</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="创建审批表单模板"><a class="header-anchor" href="#创建审批表单模板"></a>创建审批表单模板</h3><p>示例代码展示创建一个“最简单”的审批表单模板，详情的参数说明、示例代码可以参考钉钉开放平台文档-<a href="https://open.dingtalk.com/document/isvapp/create-or-modify-an-approval-form-template#h2-yxg-rus-wbn">创建或更新审批表单模板</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateFormTemplateSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Token 初始化账号Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.aliyun.dingtalkworkflow_1_0.Client <span class="title function_">createClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.protocol = <span class="string">&quot;https&quot;</span>;</span><br><span class="line">        config.regionId = <span class="string">&quot;central&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dingtalkworkflow_1_0.Client(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args_)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        com.aliyun.dingtalkworkflow_1_0.<span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> CreateFormTemplateSample.createClient();</span><br><span class="line">        <span class="type">FormCreateHeaders</span> <span class="variable">formCreateHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormCreateHeaders</span>();</span><br><span class="line">        formCreateHeaders.xAcsDingtalkAccessToken = <span class="string">&quot;7011eb7b5a5e37c694b18c6c79406111&quot;</span>;</span><br><span class="line">        <span class="comment">// 1. 单行输入控件</span></span><br><span class="line">        <span class="type">FormComponentProps</span> <span class="variable">formComponentProps1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormComponentProps</span>()</span><br><span class="line">                .setLabel(<span class="string">&quot;名称&quot;</span>);</span><br><span class="line">        <span class="type">FormComponent</span> <span class="variable">formComponent1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormComponent</span>()</span><br><span class="line">                .setComponentType(<span class="string">&quot;TextField&quot;</span>)</span><br><span class="line">                .setProps(formComponentProps1);</span><br><span class="line"></span><br><span class="line">        <span class="type">FormCreateRequest</span> <span class="variable">formCreateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormCreateRequest</span>()</span><br><span class="line">                .setName(<span class="string">&quot;表单示例&quot;</span>)</span><br><span class="line">                .setFormComponents(java.util.Arrays.asList(</span><br><span class="line">                        formComponent1</span><br><span class="line">                ));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FormCreateResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.formCreateWithOptions(formCreateRequest, formCreateHeaders, <span class="keyword">new</span> <span class="title class_">RuntimeOptions</span>());</span><br><span class="line">            System.out.println(JSON.toJSONString(response));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception _err) &#123;</span><br><span class="line">            _err.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印响应数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;processCode&quot;</span><span class="punctuation">:</span><span class="string">&quot;PROC-0FAB48EA-FB39-4981-AD80-E67D552B3355&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="发起审批实例"><a class="header-anchor" href="#发起审批实例"></a>发起审批实例</h3><p>示例代码展示发起一个“最简单”的审批实例，详情的参数说明、示例代码可以参考钉钉开放平台文档-<a href="https://open.dingtalk.com/document/isvapp/initiate-approval-new#h2-uoy-vng-a26">发起审批实例</a>。</p><blockquote><p>💡提示：钉钉开放平台在<strong>创建审批实例</strong>的文档中，有个“巨大”的坑。在<strong>body参数</strong>的介绍中，未提及到deptId（用户所属部门id）字段，在API Explorer中才有介绍，根据提示说明，在approvers（审批人对象）未传值时，deptId为必填字段，根部门传-1。</p><p>如果没有传approvers，同时也没有传deptId，接口回调就会返回异常信息，异常信息就提示个“审批实例参数错误”，根本无从分析具体是哪里错误，这种情况充斥在钉钉OA审批相关的各个API中。</p><p>如果你“恰好”碰到了这种类似的“参数错误”，不要着急，仔细浏览钉钉开放平台的文档、示例代码、API Explorer，再不济可以调成功的接口进行分析。例如这里如果创建审批实例错误，可以用钉钉直接人为发起一个审批，接着调用“获取审批实例ID列表”接口得到审批实例id，再调用“获取单个审批实例详情”接口得到审批实例详情数据，进而与自己的代码进行比较分析。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartInstanceSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Token 初始化账号Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.aliyun.dingtalkworkflow_1_0.Client <span class="title function_">createClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.protocol = <span class="string">&quot;https&quot;</span>;</span><br><span class="line">        config.regionId = <span class="string">&quot;central&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dingtalkworkflow_1_0.Client(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args_)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        com.aliyun.dingtalkworkflow_1_0.<span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> StartInstanceSample.createClient();</span><br><span class="line">        <span class="type">StartProcessInstanceHeaders</span> <span class="variable">startProcessInstanceHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartProcessInstanceHeaders</span>();</span><br><span class="line">        startProcessInstanceHeaders.xAcsDingtalkAccessToken = <span class="string">&quot;7011eb7b5a5e37c694b18c6c79406111&quot;</span>;</span><br><span class="line">        StartProcessInstanceRequest.<span class="type">StartProcessInstanceRequestFormComponentValues</span> <span class="variable">formComponentValues0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartProcessInstanceRequest</span>.StartProcessInstanceRequestFormComponentValues()</span><br><span class="line">                .setName(<span class="string">&quot;名称&quot;</span>)</span><br><span class="line">                .setValue(<span class="string">&quot;wray&quot;</span>);</span><br><span class="line">        <span class="type">StartProcessInstanceRequest</span> <span class="variable">startProcessInstanceRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartProcessInstanceRequest</span>()</span><br><span class="line">                .setOriginatorUserId(<span class="string">&quot;306354436429120376&quot;</span>)</span><br><span class="line">                .setProcessCode(<span class="string">&quot;PROC-0FAB48EA-FB39-4981-AD80-E67D552B3355&quot;</span>)</span><br><span class="line">                .setDeptId(-<span class="number">1L</span>)</span><br><span class="line">                .setFormComponentValues(Collections.singletonList(formComponentValues0));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">StartProcessInstanceResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.startProcessInstanceWithOptions(startProcessInstanceRequest, startProcessInstanceHeaders, <span class="keyword">new</span> <span class="title class_">RuntimeOptions</span>());</span><br><span class="line">            System.out.println(JSON.toJSONString(response));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception _err) &#123;</span><br><span class="line">            _err.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;instanceId&quot;</span><span class="punctuation">:</span><span class="string">&quot;KW2ZY679TRyy3Nupz5MN8A10181692956791&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查询审批实例详情"><a class="header-anchor" href="#查询审批实例详情"></a>查询审批实例详情</h3><p>审批实例详情大致包含了一个审批实例的实例基础信息（审批状态、发起人信息等）、操作记录、任务列表、组件详情列表。</p><p>示例代码展示查询上述发起的审批实例详情，详情的参数说明、示例代码可以参考钉钉开放平台文档-<a href="https://open.dingtalk.com/document/orgapp/obtains-the-details-of-a-single-approval-instance-pop#h2-hoq-2ua-50d">获取单个审批实例详情</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetInstanceDetailSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Token 初始化账号Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.aliyun.dingtalkworkflow_1_0.Client <span class="title function_">createClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        com.aliyun.teaopenapi.models.<span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.teaopenapi.models.Config();</span><br><span class="line">        config.protocol = <span class="string">&quot;https&quot;</span>;</span><br><span class="line">        config.regionId = <span class="string">&quot;central&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dingtalkworkflow_1_0.Client(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args_)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        com.aliyun.dingtalkworkflow_1_0.<span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> GetInstanceDetailSample.createClient();</span><br><span class="line">        com.aliyun.dingtalkworkflow_1_0.models.<span class="type">GetProcessInstanceHeaders</span> <span class="variable">getProcessInstanceHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dingtalkworkflow_1_0.models.GetProcessInstanceHeaders();</span><br><span class="line">        getProcessInstanceHeaders.xAcsDingtalkAccessToken = <span class="string">&quot;d62086b9f7943eedb06ee0c096d9e111&quot;</span>;</span><br><span class="line">        com.aliyun.dingtalkworkflow_1_0.models.<span class="type">GetProcessInstanceRequest</span> <span class="variable">getProcessInstanceRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dingtalkworkflow_1_0.models.GetProcessInstanceRequest()</span><br><span class="line">                .setProcessInstanceId(<span class="string">&quot;KW2ZY679TRyy3Nupz5MN8A10181692956791&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">GetProcessInstanceResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.getProcessInstanceWithOptions(getProcessInstanceRequest, getProcessInstanceHeaders, <span class="keyword">new</span> <span class="title class_">RuntimeOptions</span>());</span><br><span class="line">            System.out.println(JSON.toJSONString(response));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception _err) &#123;</span><br><span class="line">            _err.printStackTrace();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;attachedProcessInstanceIds&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bizAction&quot;</span><span class="punctuation">:</span><span class="string">&quot;NONE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;businessId&quot;</span><span class="punctuation">:</span><span class="string">&quot;202308251746000319111&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-08-25T17:46Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;finishTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-08-25T17:46Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;formComponentValues&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;componentType&quot;</span><span class="punctuation">:</span><span class="string">&quot;TextField&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;TextField_HWna4IkQPgtWz&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;名称&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="string">&quot;wray&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;operationRecords&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-08-25T17:46Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span><span class="string">&quot;NONE&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;START_PROCESS_INSTANCE&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span><span class="string">&quot;306354436429120111&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originatorDeptId&quot;</span><span class="punctuation">:</span><span class="string">&quot;-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originatorDeptName&quot;</span><span class="punctuation">:</span><span class="string">&quot;开发部&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;originatorUserId&quot;</span><span class="punctuation">:</span><span class="string">&quot;306354436429120111&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span><span class="string">&quot;agree&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;COMPLETED&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;Wray提交的表单示例&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="OA审批事件回调"><a class="header-anchor" href="#OA审批事件回调"></a>OA审批事件回调</h3><p>OA审批事件是钉钉事件消息的一种，在「<strong>概述-总结</strong>」中也提到过，这里主要就展示Stream推送的代码示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamCallbackSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        OpenDingTalkStreamClientBuilder</span><br><span class="line">                .custom()</span><br><span class="line">                .credential(<span class="keyword">new</span> <span class="title class_">AuthClientCredential</span>(<span class="string">&quot;AppKey&quot;</span>, <span class="string">&quot;AppSecret&quot;</span>))</span><br><span class="line">                <span class="comment">//注册事件监听</span></span><br><span class="line">                .registerAllEventListener(<span class="keyword">new</span> <span class="title class_">GenericEventListener</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> EventAckStatus <span class="title function_">onEvent</span><span class="params">(GenericOpenDingTalkEvent event)</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//事件类型 根据事件类型推断是否为OA审批事件</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">eventType</span> <span class="operator">=</span> event.getEventType();</span><br><span class="line">                            <span class="comment">//获取事件体</span></span><br><span class="line">                            <span class="type">JSONObject</span> <span class="variable">bizData</span> <span class="operator">=</span> event.getData();</span><br><span class="line">                            <span class="comment">//处理事件</span></span><br><span class="line">                            System.out.println(JSON.toJSONString(bizData));</span><br><span class="line">                            <span class="comment">//消费成功</span></span><br><span class="line">                            <span class="keyword">return</span> EventAckStatus.SUCCESS;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="comment">//消费失败</span></span><br><span class="line">                            <span class="keyword">return</span> EventAckStatus.LATER;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动代码后，在钉钉后台验证Stream模式通道。</p><p><img src="/2023/08/25/work-report-ddoa/image-20230827115355744.png" alt="image-20230827115355744"></p><p>推送数据分为两个部分，一个部分为事件的基础信息，另一个部分为事件业务数据信息。</p><p>格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;eventBornTime&quot;</span><span class="punctuation">:</span><span class="number">1684132707000</span><span class="punctuation">,</span>  <span class="comment">//事件生成时间</span></span><br><span class="line">    <span class="attr">&quot;eventCorpId&quot;</span><span class="punctuation">:</span><span class="string">&quot;ding9f50b15b*****41&quot;</span><span class="punctuation">,</span> <span class="comment">//事件所属的corpId</span></span><br><span class="line">    <span class="attr">&quot;eventId&quot;</span><span class="punctuation">:</span><span class="string">&quot;c69632e6e3794bfbb07d33fad9fa82d2&quot;</span><span class="punctuation">,</span> <span class="comment">//事件的唯一Id</span></span><br><span class="line">    <span class="attr">&quot;eventType&quot;</span><span class="punctuation">:</span><span class="string">&quot;suite_ticket&quot;</span><span class="punctuation">,</span> <span class="comment">//事件类型</span></span><br><span class="line">    <span class="attr">&quot;eventUnifiedAppId&quot;</span><span class="punctuation">:</span><span class="string">&quot;unifiedAppId1&quot;</span><span class="punctuation">,</span> <span class="comment">//统一应用身份Id</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> <span class="comment">//事件的业务信息</span></span><br><span class="line">        <span class="attr">&quot;suiteTicket&quot;</span><span class="punctuation">:</span><span class="string">&quot;1234455&quot;</span> <span class="comment">//suiteTicke业务信息</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接入成功之后，对钉钉实例进行操作，例如现在对OA审批任务进行评论，推送的业务信息如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;processInstanceId&quot;</span><span class="punctuation">:</span><span class="string">&quot;FiFx7mFVTX6R9Iw8TOeheQ10181693105111&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="number">1693108281607</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processCode&quot;</span><span class="punctuation">:</span><span class="string">&quot;PROC-4650E083-0D7F-42BD-BC1A-30043D5BC111&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;businessId&quot;</span><span class="punctuation">:</span><span class="string">&quot;202308271058000577111&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;wray提交的表单示例&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;comment&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;businessType&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;staffId&quot;</span><span class="punctuation">:</span><span class="string">&quot;306354436429120376&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="相关文章"><a class="header-anchor" href="#相关文章"></a>相关文章</h2><p>项目搭建钉钉OA审批底层框架的历程：<a href="https://blog.itwray.com/2023/09/01/work-report-ddoa2/">工作小结-钉钉OA审批（2）</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作小结 </tag>
            
            <tag> OA审批 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal解析</title>
      <link href="/2023/08/18/java-threadlocal/"/>
      <url>/2023/08/18/java-threadlocal/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal简介"><a class="header-anchor" href="#ThreadLocal简介"></a>ThreadLocal简介</h2><p><code>java.lang.ThreadLocal</code>的JDK文档介绍如下：</p><p><img src="/2023/08/18/java-threadlocal/image-20230819132045069.png" alt="image-20230819132045069"></p><p><img src="/2023/08/18/java-threadlocal/image-20230819132053823.png" alt="image-20230819132053823"></p><p>个人理解就是：</p><ol><li>ThreadLocal为线程提供了局部变量，每个线程访问ThreadLocal实例获取到的值都是独立存在的变量副本。</li><li>当Thread线程消失后，线程持有的变量副本都会被垃圾回收（除非这个变量副本还在被其他对象所引用，即强引用）。</li></ol><h2 id="使用ThreadLocal"><a class="header-anchor" href="#使用ThreadLocal"></a>使用ThreadLocal</h2><p>先上示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; LOCAL_VARIABLE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        LOCAL_VARIABLE.set(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printWithRemove</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;变量值为：&quot;</span> + LOCAL_VARIABLE.get());</span><br><span class="line">        LOCAL_VARIABLE.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">ThreadLocalDemo</span> <span class="variable">threadLocalDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">            threadLocalDemo.setValue(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            threadLocalDemo.printWithRemove();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;变量值为：&quot;</span> + LOCAL_VARIABLE.get());</span><br><span class="line">        &#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;变量值为：&quot;</span> + LOCAL_VARIABLE.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">ThreadLocalDemo</span> <span class="variable">threadLocalDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">            threadLocalDemo.setValue(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">            threadLocalDemo.printWithRemove();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;变量值为：&quot;</span> + LOCAL_VARIABLE.get());</span><br><span class="line">        &#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2023/08/18/java-threadlocal/image-20230819140625134.png" alt="image-20230819140625134"></p><p>在程序中，新启动了两个线程A、B，并在每个线程中对ThreadLocal进行了<code>set</code>、<code>get</code>、<code>remove</code>操作。</p><p>在<code>printWithRemove</code>方法中，通过get()方法直接拿取当前线程ThreadLocal实例的变量副本，拿取到了之前<code>setValue</code>方法赋予的值。</p><p>在调用ThreadLocal的<code>remove</code>方法后，再次使用<code>get</code>获取，会发现value变为了null，表示当前线程下ThreadLocal实例的变量副本已被删除。</p><p>在main方法中，直接获取ThreadLocal实例的变量副本结果为null，是因为main方法所运行的线程与A、B线程不为同一线程，通过<code>Thread.currentThread().getName()</code>也可以证明。由此也说明了，同一个ThreadLocal实例对象，在不同线程之间管理的变量副本是独立的。</p><h3 id="正确使用ThreadLocal"><a class="header-anchor" href="#正确使用ThreadLocal"></a>正确使用ThreadLocal</h3><ol><li><p>将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p></li><li><p>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。可以使用try-finally形式。</p></li></ol><h2 id="ThreadLocal源码解析"><a class="header-anchor" href="#ThreadLocal源码解析"></a>ThreadLocal源码解析</h2><p>首先看其类定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现它就是一个public修饰的普通类，特殊点在于它存放于java.lang包下。</p><p>它有两个静态内部类：<code>SuppliedThreadLocal</code>、<code>ThreadLocalMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An extension of ThreadLocal that obtains its initial value from</span></span><br><span class="line"><span class="comment"> * the specified &#123;<span class="doctag">@code</span> Supplier&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SuppliedThreadLocal的内部结构比较简单，通过注释也可以发现，它是一个支持扩展初始化值方法的类。</p><p>再看ThreadLocalMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment"> * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment"> * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment"> * allow declaration of fields in class Thread.  To help deal with</span></span><br><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment"> * WeakReferences for keys. However, since reference queues are not</span></span><br><span class="line"><span class="comment"> * used, stale entries are guaranteed to be removed only when</span></span><br><span class="line"><span class="comment"> * the table starts running out of space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">  </span><br><span class="line">  ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">          table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">          table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">          size = <span class="number">1</span>;</span><br><span class="line">          setThreshold(INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap类内部还有一个Entry类，通过命名约定和注释文档可以大致了解到，ThreadLocalMap是一个定制的散列映射对象，只被ThreadLocal所使用，内部对象使用Entry存储，Entry的key为ThreadLocal，value为变量副本。</p><p>观察Entry的类结构以及构造方法，发现它继承了WeakReference（弱引用），并在实例化时调用了<code>super(k)</code>，也就是说被指定为弱引用的ThreadLocal在作为key时，可能会出现entry(null, value)的情况，ThreadLocalMap会将这类entry标记为过期类型，在下一次使用中，将其value置为null，便于JVM垃圾回收。value被置为null的逻辑在<code>expungeStaleEntry</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>再回过头从ThreadLocal看<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 从当前线程拿取ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// map为空时，生成一个map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有两个逻辑是关键，第一个<strong>从当前线程拿取ThreadLocalMap</strong>，代表着是线程存储的ThreadLocalMap，而第二个<strong>map为空时，生成一个map</strong>，代表是ThreadLocal为Thread生成的ThreadLocalMap对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是ThreadLocal的实例方法</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">     <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码，也说明了，ThreadLocal.ThreadLocalMap是存储在Thread中的，而Thread里面的threadLocals变量是通过ThreadLocal控制的。</p><br><p>再看ThreadLocal的<code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 从当前线程拿取ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前ThreadLocal实例对象作为key，从Entru拿取value</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// value不为空时就返回，为空也是走 setInitialValue 方法</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程中的ThreadLocalMap为空时，设置初始值并返回</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ThreadLocal获取线程变量副本的初始值</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><code>remove</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap#remove方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 将Entry的key置为null</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 将Entry的value置为null</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal的使用场景"><a class="header-anchor" href="#ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h2><p>ThreadLocal一般适用于如下场景：</p><ol><li>每个线程需要有自己独立的实例</li><li>实例需要在多个方法中被共享，又不希望被多线程共享</li></ol><br><p>业务场景有：</p><ol><li><p>存储用户session信息</p><p>从token解析出用户信息之后，可能会在多处都要使用到，但又不想重复从token解析。</p></li><li><p>数据跨层传递（controller、service、dao）</p><p>为了避免显式传参的麻烦。</p></li><li><p>链路id</p><p>例如日志链路，为了方便后期使用日志排查问题，一般会将一个api请求的日志都加上一个相同链路id。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo草稿</title>
      <link href="/2023/08/18/hexo-draft/"/>
      <url>/2023/08/18/hexo-draft/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo草稿"><a class="header-anchor" href="#Hexo草稿"></a>Hexo草稿</h2><p>因为一些不可抗力原因，一篇文章可能无法及时发布，但又想发布其他文章，就需要将未完成的文章暂存，所以就学习了下Hexo的draft功能。</p><p>draft也就是草稿，在使用hexo创建文章时，可以先指定为草稿。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure><p>然后在完成之后，使用<code>publish</code>命令将draft转移到post下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure><h2 id="Hexo删除已生成的文章"><a class="header-anchor" href="#Hexo删除已生成的文章"></a>Hexo删除已生成的文章</h2><p>Hexo未提供命令交互式删除方法，可直接在<code>$&#123;hexo&#125;/source/_post</code>目录下删除对应的.md文件。</p><p>对于已经发布的文章，还需要删除<code>$&#123;hexo&#125;/.deploy_git</code>文件，再重新clean -&gt; generate -&gt; deploy。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Hexo Draft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题-NexT</title>
      <link href="/2023/08/10/hexo-theme-next/"/>
      <url>/2023/08/10/hexo-theme-next/</url>
      
        <content type="html"><![CDATA[<h3 id="安装NexT"><a class="header-anchor" href="#安装NexT"></a>安装NexT</h3><h4 id="下载主题"><a class="header-anchor" href="#下载主题"></a>下载主题</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>下载完后在站点目录下的<code>themes</code>目录下，可以看到新生成的next目录。</p><h4 id="启用主题"><a class="header-anchor" href="#启用主题"></a>启用主题</h4><p>打开<code>站点配置文件</code>，找到<code>theme</code>字段，更改值为<code>next</code>。</p><blockquote><p>Tips：在vi编辑模式下，使用<code>?keyword</code>，搜索文件关键字，使用<code>N</code>(shift+n)跳转下一条，使用<code>n</code>跳转上一条。</p></blockquote><img src="/2023/08/10/hexo-theme-next/image-20230810105037026.png" alt="image-20230810105037026" style="zoom:150%;"><br><h3 id="主题设定"><a class="header-anchor" href="#主题设定"></a>主题设定</h3><p>参考地址：<a href="http://theme-next.iissnan.com/getting-started.html#select-scheme">http://theme-next.iissnan.com/getting-started.html#select-scheme</a></p><h4 id="基础设置"><a class="header-anchor" href="#基础设置"></a>基础设置</h4><p>在主题目录下，一般会有一个<code>_config.yml</code>主题配置文件，NexT的配置信息大致如下：</p><ul><li>scheme：主题外观</li><li>menu：菜单</li><li>darkmode：暗黑模式</li><li>social：社交链接</li><li>footer：页脚</li><li>scrollpercent：浏览进度</li><li>codeblock：代码复制按钮</li></ul><h4 id="阅读次数、访问量"><a class="header-anchor" href="#阅读次数、访问量"></a>阅读次数、访问量</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">false</span> <span class="comment"># 文章底部</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">false</span> <span class="comment"># 文章底部</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span> <span class="comment"># 文章开头展示的阅读量</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure><h4 id="字数统计和阅读时长：（需要安装插件）"><a class="header-anchor" href="#字数统计和阅读时长：（需要安装插件）"></a>字数统计和阅读时长：（需要安装插件）</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p><code>站点配置文件</code>配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span> <span class="comment">#平均每个字符的长度</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span> <span class="comment"># 设定每分钟可阅读的字符数</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment">#是否统计字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span> <span class="comment">#是否统计阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span> <span class="comment">#是否统计总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span> <span class="comment">#是否统计总阅读时长</span></span><br></pre></td></tr></table></figure><p><code>主题配置文件</code>配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment">#分隔线</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment">#文章中的显示是否显示文本</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment">#网页底部的显示是否显示文本</span></span><br></pre></td></tr></table></figure><h4 id="设置阅读全文"><a class="header-anchor" href="#设置阅读全文"></a>设置阅读全文</h4><p>NexT支持三种方式控制文章在首页的显示方式：</p><ol><li>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式 <strong>NexT推荐</strong></li><li>在文章的 <a href="https://hexo.io/docs/front-matter.html">front-matter</a> 中添加 <code>description</code>，并提供文章摘录</li><li>自动形成摘要，在 <strong>主题配置文件</strong> 中添加：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span> <span class="comment"># 默认截取的长度为 150 字符，可以根据需要自行设定</span></span><br></pre></td></tr></table></figure><h4 id="代码块高亮主题"><a class="header-anchor" href="#代码块高亮主题"></a>代码块高亮主题</h4><p>codeblock.highlight_theme</p><p>NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties.</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Hexo Themes </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpolar安装与使用</title>
      <link href="/2023/08/09/cpolar-use/"/>
      <url>/2023/08/09/cpolar-use/</url>
      
        <content type="html"><![CDATA[<h2 id="cpolar介绍"><a class="header-anchor" href="#cpolar介绍"></a>cpolar介绍</h2><p>只需一行命令，就可以将内网站点发布至公网，方便给客户演示。高效调试微信公众号、小程序、对接支付宝网关等云端服务，提高您的编程效率。</p><p>官方地址：<a href="https://www.cpolar.com/">https://www.cpolar.com/</a></p><br><h2 id="MacOS安装"><a class="header-anchor" href="#MacOS安装"></a>MacOS安装</h2><p>在Mac系统上需通过Homebrew包管理器来安装cpolar内网穿透。</p><h3 id="1-安装homebrew"><a class="header-anchor" href="#1-安装homebrew"></a>1. 安装homebrew</h3><p>Homebrew是一款Mac OS下的套件管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-安装cpolar"><a class="header-anchor" href="#2-安装cpolar"></a>2. 安装cpolar</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap probezy/core &amp;&amp; brew install cpolar</span><br></pre></td></tr></table></figure><h3 id="3-token验证"><a class="header-anchor" href="#3-token验证"></a>3. token验证</h3><p>登录cpolar官网，点击左侧的验证，查看自己的认证token，之后将token贴在命令行里。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><h3 id="4-安装服务"><a class="header-anchor" href="#4-安装服务"></a>4. 安装服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cpolar service install</span><br></pre></td></tr></table></figure><h3 id="5-启动服务"><a class="header-anchor" href="#5-启动服务"></a>5. 启动服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 启动服务</span><br><span class="line">sudo cpolar service start</span><br><span class="line">// 停止服务</span><br><span class="line">sudo cpolar service stop</span><br></pre></td></tr></table></figure><p>启动和停止服务时，因为是sudo操作，需要输入os系统用户的密码。</p><h3 id="6-安装完成"><a class="header-anchor" href="#6-安装完成"></a>6. 安装完成</h3><p>在浏览器上访问本地9200端口【127.0.0.1:9200】，使用cpolar邮箱账号登录cpolar web UI管理界面，即可开始使用cpolar。</p><br><h2 id="使用内网穿透"><a class="header-anchor" href="#使用内网穿透"></a>使用内网穿透</h2><h3 id="创建隧道"><a class="header-anchor" href="#创建隧道"></a>创建隧道</h3><p>在<code>隧道管理-创建隧道</code>下，输入自定义的<code>隧道名称</code>、<code>本地地址</code>(即端口)，点击创建。</p><p><img src="/2023/08/09/cpolar-use/image-20230809100428209.png" alt="image-20230809100428209"></p><h3 id="启用隧道"><a class="header-anchor" href="#启用隧道"></a>启用隧道</h3><p>在<code>隧道管理-隧道列表</code>下点击启动。</p><p><img src="/2023/08/09/cpolar-use/image-20230809101114072.png" alt="image-20230809101114072"></p><h3 id="访问外网"><a class="header-anchor" href="#访问外网"></a>访问外网</h3><p>在<code>状态-在线隧道列表</code>下，可以查询对应隧道的公网地址。</p><p><img src="/2023/08/09/cpolar-use/image-20230809101043029.png" alt="image-20230809101043029"></p><br><h2 id="使用注意点"><a class="header-anchor" href="#使用注意点"></a>使用注意点</h2><ol><li>cpolar在启动服务后，会默认开启所有隧道，可以通过配置关闭此功能。</li><li>创建的http协议隧道，默认会开启http和https两种协议，可以在创建时的高级选项中选择。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 内网穿透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpolar </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2023/08/08/markdown-syntax/"/>
      <url>/2023/08/08/markdown-syntax/</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown语法参考地址：</strong></p><p><a href="https://www.markdownguide.org/basic-syntax/">https://www.markdownguide.org/basic-syntax/</a></p><h4 id="符号原样输出"><a class="header-anchor" href="#符号原样输出"></a>符号原样输出</h4><p>在符号前加 \</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\*</span><br><span class="line">\\</span><br></pre></td></tr></table></figure><p>\* 就是展示 *、\\ 就是展示 \</p><p><strong>\可以转义的字符如下：</strong></p><table><thead><tr><th>Character</th><th>Name</th></tr></thead><tbody><tr><td>\</td><td>backslash</td></tr><tr><td>`</td><td>backtick (see also <a href="https://www.markdownguide.org/basic-syntax/#escaping-backticks">escaping backticks in code</a>)</td></tr><tr><td>*</td><td>asterisk</td></tr><tr><td>_</td><td>underscore</td></tr><tr><td>{ }</td><td>curly braces</td></tr><tr><td>[ ]</td><td>brackets</td></tr><tr><td>&lt; &gt;</td><td>angle brackets</td></tr><tr><td>( )</td><td>parentheses</td></tr><tr><td>#</td><td>pound sign</td></tr><tr><td>+</td><td>plus sign</td></tr><tr><td>-</td><td>minus sign (hyphen)</td></tr><tr><td>.</td><td>dot</td></tr><tr><td>!</td><td>exclamation mark</td></tr><tr><td>|</td><td>pipe (see also <a href="https://www.markdownguide.org/extended-syntax/#escaping-pipe-characters-in-tables">escaping pipe in tables</a>)</td></tr></tbody></table><h4 id="标题"><a class="header-anchor" href="#标题"></a>标题</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1级标题 （需要在行开头）</span></span><br><span class="line"><span class="section">## 2级标题</span></span><br></pre></td></tr></table></figure><h4 id="加粗"><a class="header-anchor" href="#加粗"></a>加粗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**粗体**</span></span><br></pre></td></tr></table></figure><h4 id="斜体"><a class="header-anchor" href="#斜体"></a>斜体</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br></pre></td></tr></table></figure><h4 id="加粗斜体"><a class="header-anchor" href="#加粗斜体"></a>加粗斜体</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*加粗斜体*</span>**</span></span><br></pre></td></tr></table></figure><h4 id="引用"><a class="header-anchor" href="#引用"></a>引用</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 文本引用  （需要在行开头）</span></span><br></pre></td></tr></table></figure><blockquote><p>文本引用（需要在行开头）</p></blockquote><h4 id="多级引用"><a class="header-anchor" href="#多级引用"></a>多级引用</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 一级引用</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; 二级引用，并且二级引用被包含在上面的一级引用中</span><br></pre></td></tr></table></figure><blockquote><p>一级引用</p><blockquote><p>二级引用，并且二级引用被包含在上面的一级引用中</p></blockquote></blockquote><h4 id="有序列表"><a class="header-anchor" href="#有序列表"></a>有序列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表1</span><br><span class="line"><span class="bullet">2.</span> 列表2</span><br></pre></td></tr></table></figure><ol><li>列表1</li><li>列表2</li></ol><h4 id="无序列表"><a class="header-anchor" href="#无序列表"></a>无序列表</h4><p>使用 - 、* 、+ 均可，但不能在一个列表中交叉使用多个符号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 列表1</span><br><span class="line"><span class="bullet">-</span> 列表2</span><br><span class="line"><span class="bullet">-</span> 列表2-1</span><br></pre></td></tr></table></figure><ul><li><p>列表1</p></li><li><p>列表2</p><ul><li>列表2-1</li></ul></li></ul><p>在列表中添加其他元素，同时在后文中还得保持列表的连续性。可以使用4个空格或者一个tab实现。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 一级列表</span><br><span class="line"><span class="bullet">2.</span> 二级列表</span><br><span class="line">   <span class="strong">**加粗文本**</span>展示。</span><br><span class="line"><span class="bullet">3.</span> 三级列表</span><br><span class="line"><span class="bullet">4.</span> 四级列表</span><br></pre></td></tr></table></figure><ol><li><p>一级列表</p></li><li><p>二级列表</p><p><strong>加粗文本</strong>展示。</p></li><li><p>三级列表</p></li><li><p>四级列表</p></li></ol><h4 id="图片"><a class="header-anchor" href="#图片"></a>图片</h4><p>格式：![图片名称](图片地址)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">这是图片的名称</span>](<span class="link">markdown-syntax/dfaf7298546f2e9c2482f713ef2c12c2.jpeg</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/markdown-syntax/dfaf7298546f2e9c2482f713ef2c12c2.jpeg" alt="这是图片的名称"></p><h4 id="代码"><a class="header-anchor" href="#代码"></a>代码</h4><p>`代码`-&gt;<code>代码</code></p><h4 id="代码块"><a class="header-anchor" href="#代码块"></a>代码块</h4><p>```回车键，创建代码块，再在代码块里面输入内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是代码块里面的内容</span><br></pre></td></tr></table></figure><p>在Typora中可以在输入三个<code>\\\</code>后，输入代码块的编程语言，再按回车，代码块会对编程语言的内容自动做颜色区分。</p><p>```shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;这是shell脚本&#x27;</span><br></pre></td></tr></table></figure><h4 id="标尺线"><a class="header-anchor" href="#标尺线"></a>标尺线</h4><p>使用 *** 、--- 都可以展示出如下效果。</p><hr><h4 id="链接"><a class="header-anchor" href="#链接"></a>链接</h4><p>格式：[链接地址名称](链接地址 &quot;链接标题提示&quot;)</p><blockquote><p>&quot;链接标题提示&quot;作用：当用户将鼠标悬停在链接上时，它将作为工具提示出现。<em>它不是必须的</em>。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">这是我的博客主页</span>](<span class="link">https://wangfarui.github.io &quot;博客主页的标题&quot;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://wangfarui.github.io" title="博客主页的标题">这是我的博客主页</a></p><br><p><strong>快速转换URL地址或者Email地址，使用<code>&lt;&gt;</code>标记。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;https://wangfarui.github.io&gt;</span></span><br><span class="line"><span class="language-xml">&lt;wray20156294@gmail.com&gt;</span></span><br></pre></td></tr></table></figure><p>URL地址：<a href="https://wangfarui.github.io">https://wangfarui.github.io</a></p><p>Email地址：<a href="mailto:wray20156294@gmail.com">wray20156294@gmail.com</a></p><br><p><strong>格式化链接</strong></p><p>链接的标题支持格式化，在链接标题的前后使用<code>加粗</code>、<code>斜体</code>、<code>代码</code>等效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是加粗的链接[<span class="string">**加粗URL**</span>](<span class="link">https://wangfarui.github.io</span>)</span><br><span class="line"></span><br><span class="line">这是斜体的链接[<span class="string">*斜体URL*</span>](<span class="link">https://wangfarui.github.io</span>)</span><br><span class="line"></span><br><span class="line">这是标题格式化为代码的链接[<span class="string">`代码URL`</span>](<span class="link">https://wangfarui.github.io</span>)</span><br></pre></td></tr></table></figure><p>这是加粗的链接<a href="https://wangfarui.github.io"><strong>加粗URL</strong></a></p><p>这是斜体的链接<a href="https://wangfarui.github.io"><em>斜体URL</em></a></p><p>这是标题格式化为代码的链接<a href="https://wangfarui.github.io"><code>代码URL</code></a></p><blockquote><p>💡提示：markdown的链接地址不支持中间带有空格，如果地址中的确含有空格，需要使用<code>%20</code>转换，或者使用html的&lt;a&gt;标签。</p></blockquote><h4 id="表格"><a class="header-anchor" href="#表格"></a>表格</h4><p>基础表格</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table><p>排版表格</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here's this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table><h4 id="任务列表"><a class="header-anchor" href="#任务列表"></a>任务列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] Write the press release</span><br><span class="line"><span class="bullet">-</span> [ ] Update the website</span><br><span class="line"><span class="bullet">-</span> [ ] Contact the media</span><br></pre></td></tr></table></figure><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> Write the press release</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> Update the website</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> Contact the media</li></ul><h4 id="表情Emoji"><a class="header-anchor" href="#表情Emoji"></a>表情Emoji</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:bulb:</span><br><span class="line">:+1:</span><br><span class="line">:joy:</span><br></pre></td></tr></table></figure><p>💡 👍 😂</p><h4 id="下标"><a class="header-anchor" href="#下标"></a>下标</h4><p>在markdown中使用 <code>~x~</code> 表示，但是并不是所用markdown都支持。</p><p>可以使用html元素标签：&lt;sub&gt;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是水：H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>O</span><br></pre></td></tr></table></figure><p>这是水：H<sub>2</sub>O</p><h4 id="上标"><a class="header-anchor" href="#上标"></a>上标</h4><p>在markdown中使用 <code>^x^</code> 表示，但是并不是所用markdown都支持。</p><p>可以使用html元素标签：&lt;sup&gt;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是x的平方：X<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是x的平方：X<sup>2</sup></p><h4 id="删除线"><a class="header-anchor" href="#删除线"></a>删除线</h4><p>使用<code>~~删除内容~~</code>表示。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后面是一段删除的内容：~~无用信息~~</span><br></pre></td></tr></table></figure><p>后面是一段删除的内容：<s>无用信息</s></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的安装与学习</title>
      <link href="/2023/07/28/hexo-study/"/>
      <url>/2023/07/28/hexo-study/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a class="header-anchor" href="#环境准备"></a>环境准备</h2><ol><li>Git</li><li>Node.js</li></ol><h2 id="安装Hexo"><a class="header-anchor" href="#安装Hexo"></a>安装Hexo</h2><p>采用全局安装脚手架方式，因此在命令行的任意路径下，执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure><blockquote><p>💡 <strong>提示</strong>：之所以使用<code>sudo</code>，是因为在安装hexo时需要访问/usr/local目录，会提示权限拒绝的错误。</p><p><img src="/2023/07/28/hexo-study/image-20230728143731663.png" alt="image-20230728143731663"></p></blockquote><p>这样，Hexo就算安装完成了!</p><h2 id="使用Hexo"><a class="header-anchor" href="#使用Hexo"></a>使用Hexo</h2><h3 id="初始化Hexo项目工程"><a class="header-anchor" href="#初始化Hexo项目工程"></a>初始化Hexo项目工程</h3><p>创建这个项目，主要是用于本地编写博客、配置博客网站、发布博客。</p><p>创建命令：<code> hexo init [folder]</code></p><p>其中的<code>folder</code>表示项目的目录名称，可以任意取名。</p><h3 id="Hexo配置"><a class="header-anchor" href="#Hexo配置"></a>Hexo配置</h3><p>Hexo主要有两个配置文件，其名称都是 <code>_confi.yml</code> 。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>进入刚初始化的项目目录中，Hexo项目的目录结构如下：</p><p><img src="/2023/07/28/hexo-study/image-20230728174345074.png" alt="image-20230728174345074"></p><h4 id="站点配置文件"><a class="header-anchor" href="#站点配置文件"></a>站点配置文件</h4><p>参考地址：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p><p>根目录下的<code>_config.yml</code>文件配置信息大致如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>title</code></td><td style="text-align:left">网站标题</td></tr><tr><td style="text-align:left"><code>subtitle</code></td><td style="text-align:left">网站副标题</td></tr><tr><td style="text-align:left"><code>description</code></td><td style="text-align:left">网站描述</td></tr><tr><td style="text-align:left"><code>keywords</code></td><td style="text-align:left">网站的关键词。支持多个关键词。</td></tr><tr><td style="text-align:left"><code>author</code></td><td style="text-align:left">您的名字</td></tr><tr><td style="text-align:left"><code>language</code></td><td style="text-align:left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td style="text-align:left"><code>timezone</code></td><td style="text-align:left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><p>其中，<code>description</code> 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code> 参数用于主题显示文章的作者。</p><p>扩展配置：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>theme</code></td><td style="text-align:left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td style="text-align:left"><code>theme_config</code></td><td style="text-align:left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td></tr><tr><td style="text-align:left"><code>deploy</code></td><td style="text-align:left">部署部分的设置</td></tr><tr><td style="text-align:left"><code>meta_generator</code></td><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table><h3 id="Hexo部署"><a class="header-anchor" href="#Hexo部署"></a>Hexo部署</h3><p>在部署前，先说明几个Hexo常用命令。</p><p>参考地址：<a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></p><table><thead><tr><th>命令</th><th>简写命令</th><th>作用</th></tr></thead><tbody><tr><td>hexo new <title></title></td><td></td><td>新建一篇文章。title表示文件名，当文件名有空格时，需要使用双引号括起来。</td></tr><tr><td>hexo clean</td><td></td><td>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</td></tr><tr><td>hexo server</td><td>hexo s</td><td>启动服务器。默认情况下，访问网址为： http://localhost:4000/。</td></tr><tr><td>hexo generate</td><td>hexo g</td><td>生成静态文件。</td></tr><tr><td>hexo deploy</td><td>hexo d</td><td>部署网站。</td></tr></tbody></table><p><strong>部署前提</strong>：</p><ol><li>修改配置文件</li><li>安装部署发布插件</li></ol><p><strong>修改配置文件</strong>：</p><p>以发布到github为例，在部署之前，需要修改<code>站点配置文件</code>，按照如下配置修改即可，其中repo指向自己的github地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line"> <span class="attr">repo:</span> <span class="string">git@github.com:wangfarui/wangfarui.github.io.git</span></span><br><span class="line"> <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p><code>deploy.branch</code>表示发布的分支。</p><blockquote><p>💡<strong>提示</strong>：<code>repo</code>指向的git仓库必须要是名为<code>username.github.io</code>的仓库，<code>username</code>就是自己github的帐号名。</p></blockquote><p><strong>安装部署发布插件</strong>：</p><p>在需要部署的<strong>项目路径下执行</strong>如下命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>平常部署</strong>一般分为三部曲：</p><ol><li><code>hexo s</code>本地运行调试；</li><li><code>hexo g</code>生成静态文件；</li><li><code>hexo d</code>部署网站，发布到指定服务器（例如github）。</li></ol><p>依次执行成功后，浏览器访问<code>username.github.io</code>，就可以看到自己的博客了。</p><h2 id="常见问题"><a class="header-anchor" href="#常见问题"></a>常见问题</h2><p><strong>一. hexo d时报错ERROR Deployer not found: git</strong></p><p>按照错误提示，理解应该是需要安装<code>hexo-deployer-git</code>插件，但自己明明已经安装了。</p><p>最后发现是安装插件的路径不对，一定要在<strong>项目路径下执行</strong>。</p><br><p><strong>二. 使用Typora上传图片，以及hexo不显示图片问题</strong></p><p>解决步骤如下：</p><ol><li><p>修改站点配置文件<code>_config.yml </code>的<code>post_asset_folder</code>属性为true；</p></li><li><p>修改Typora设置，将<code>图像</code>的文件保存路径改为如下配置；<img src="/2023/07/28/hexo-study/image-20230807181343466.png" alt="image-20230807181343466"></p></li><li><p>安装插件，用于hexo g生成静态文件时，将图片资源更新到文章目录下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li></ol><br><p><strong>三. Typora的emoji表情符不能被hexo识别问题</strong></p><p>根据查资料了解，是因为hexo默认的md渲染器是 <code>hexo-renderer-marked</code>，这个默认渲染器不支持emoji功能，同时也不支持扩展。</p><p>因此，需要更换一个渲染器<code>hexo-renderer-markdown-it</code>，它支持扩展，再安装emoji的扩展包就可以正常识别表情符了。</p><p>解决步骤：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 1. 卸载默认渲染器 并从package.json中移除</span><br><span class="line">npm un hexo-renderer-marked -S</span><br><span class="line">// 2. 安装mardown-it渲染器 并添加到package.json中</span><br><span class="line">npm i hexo-renderer-markdown-it -S</span><br><span class="line">// 3. 安装需要的插件  emoji支持表情符，task-lists支持tasks</span><br><span class="line">npm i markdown-it-emoji markdown-it-task-lists -S</span><br><span class="line">// 4. 在站点配置文件中 增加如下配置</span><br><span class="line">markdown:</span><br><span class="line">  render:</span><br><span class="line">    html: <span class="literal">true</span> <span class="comment"># 在 markdown 文本中支持 html tag 标签</span></span><br><span class="line">    xhtmlOut: <span class="literal">false</span> <span class="comment"># 需要 xtml 文档，使用 &lt;br /&gt; 替代 &lt;br&gt;</span></span><br><span class="line">    breaks: <span class="literal">false</span> <span class="comment"># 用 &lt;br&gt; 开始新的一行</span></span><br><span class="line">    linkify: <span class="literal">false</span> <span class="comment"># 自动将 可能是链接的内容转换成链接</span></span><br><span class="line">    typographer: <span class="literal">false</span> <span class="comment"># 印刷标识转换</span></span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-emoji </span><br><span class="line">    - markdown-it-task-lists</span><br><span class="line">  anchors:</span><br><span class="line">    level: 2</span><br><span class="line">    collisionSuffix: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    permalink: <span class="literal">false</span>,</span><br><span class="line">    permalinkClass: <span class="string">&#x27;header-anchor&#x27;</span></span><br><span class="line">    permalinkSymbol: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">case</span>: 0</span><br><span class="line">    separator: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>寻找markdown-it的其他扩展：</p><p><a href="https://www.npmjs.com/search?q=keywords:markdown-it-plugin">https://www.npmjs.com/search?q=keywords:markdown-it-plugin</a></p><br><p><strong>四. 网站配置了zh-Hans 仍然显示英文问题</strong></p><p>将<code>language</code>修改为<code>zh-CN</code>就可以了。感觉官方文档说的zh-Hans并没有生效。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/07/27/first-blog/"/>
      <url>/2023/07/27/first-blog/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是我的第一篇博客, 就从此开始吧~</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
