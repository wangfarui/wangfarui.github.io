<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java-JVM基础 | WrayのBlog</title><meta name="author" content="Wray"><meta name="copyright" content="Wray"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 JVM是Java进阶之路中非常重要的一步，因此写下本文，用一篇文章对JVM知识点做一个总结。 JVM知识体系比较多，本文将采用“想到什么说什么“的思维编写，个人感觉这样更容易引发学习思考，面对有难度的知识点，可以由浅入深，一点点的了解。 最后，再大概了解完JVM的所有知识点后，再做一个核心知识点总结，用于整理归纳。 JVM是什么 首先，在听到一个新单词时，不禁会产生疑问，它是什么？所以JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-JVM基础">
<meta property="og:url" content="https://blog.itwray.com/2024/06/18/java-jvm-basic/index.html">
<meta property="og:site_name" content="WrayのBlog">
<meta property="og:description" content="前言 JVM是Java进阶之路中非常重要的一步，因此写下本文，用一篇文章对JVM知识点做一个总结。 JVM知识体系比较多，本文将采用“想到什么说什么“的思维编写，个人感觉这样更容易引发学习思考，面对有难度的知识点，可以由浅入深，一点点的了解。 最后，再大概了解完JVM的所有知识点后，再做一个核心知识点总结，用于整理归纳。 JVM是什么 首先，在听到一个新单词时，不禁会产生疑问，它是什么？所以JVM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240710174022.png">
<meta property="article:published_time" content="2024-06-18T09:10:14.000Z">
<meta property="article:modified_time" content="2024-09-27T13:13:37.510Z">
<meta property="article:author" content="Wray">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240710174022.png"><link rel="shortcut icon" href="https://itwray.oss-cn-heyuan.aliyuncs.com/img/W.svg"><link rel="canonical" href="https://blog.itwray.com/2024/06/18/java-jvm-basic/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java-JVM基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-27 21:13:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 3 || hour >= 4
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="WrayのBlog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/touxiang.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.itwray.com"><i class="fa-fw fas fa-bolt-lightning"></i><span> 监控</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="WrayのBlog"><span class="site-name">WrayのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.itwray.com"><i class="fa-fw fas fa-bolt-lightning"></i><span> 监控</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java-JVM基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-18T09:10:14.000Z" title="发表于 2024-06-18 17:10:14">2024-06-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-27T13:13:37.510Z" title="更新于 2024-09-27 21:13:37">2024-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java-JVM基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1>前言</h1>
<p>JVM是Java进阶之路中非常重要的一步，因此写下本文，用一篇文章对JVM知识点做一个总结。</p>
<p>JVM知识体系比较多，本文将采用“想到什么说什么“的思维编写，个人感觉这样更容易引发学习思考，面对有难度的知识点，可以由浅入深，一点点的了解。</p>
<p>最后，再大概了解完JVM的所有知识点后，再做一个核心知识点总结，用于整理归纳。</p>
<h1>JVM是什么</h1>
<p>首先，在听到一个新单词时，不禁会产生疑问，它是什么？所以JVM是什么呢？</p>
<p>JVM全名 Java Virtual Machine ，中文名 Java虚拟机。顾名思义，它是一个虚拟化的计算机。</p>
<p>Q：<strong>JVM作为虚拟化机器，能做什么呢？</strong></p>
<p>它能执行Java字节码，将Java字节码翻译成机器代码，供操作系统执行，实现Java“一次编译，到处运行“的特性。</p>
<p>Q：<strong>出现了新单词 - Java字节码，什么是Java字节码呢？</strong></p>
<p>Java字节码（Java Bytecode）是Java编程语言编译后生成的一种中间表示形式。它是与平台无关的<strong>二进制代码</strong>，JVM能够直接理解和执行它。反过来说，Java字节码需要JVM进行解释，才能够被机器直接执行。</p>
<p>Q：<strong>Java字节码是怎么产生的呢？</strong></p>
<p>它是由Java源代码（.java文件）经过Java编译器（javac）编译后生成的，生成的文件后缀名为 .class 。</p>
<blockquote>
<p>需要注意的是，Java字节码对于JVM来说都应该被叫做 JVM字节码 ，因为.class文件是为了便于JVM识别和执行的。只是因为JVM最初是为运行Java程序而设计的，因此Java语言是第一个也是最广泛使用的编译生成JVM字节码的语言。由于Java的普及和影响力，JVM字节码通常被称为“Java字节码”。
虽然JVM最初是为Java设计的，但它已经发展成为一个多语言平台。许多其他编程语言（如Scala、Kotlin、Groovy、Clojure等）也可以编译成JVM字节码并在JVM上运行。因此，用“JVM字节码”这个术语更能反映现代JVM生态系统的多样性和广泛应用。</p>
</blockquote>
<p>Q：<strong>既然知道是通过JVM执行的Java字节码，那JVM的执行机制又是怎样的？</strong></p>
<p>这个问题有点偏面试的问法了，换成下面白话文的形式：</p>
<p>现在有如下一段代码，它是怎么运行起来的，JVM在执行Java字节码的过程中做了哪些操作？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>开发人员只看源代码的情况下，瞟一眼就知道系统执行后会输出“Hello”语句。</p>
<p>那么操作系统是如何知道要输出“Hello”语句的，就涉及到Java代码的执行过程了，执行过程一般分为编译期和运行时。</p>
<p>首先Java源代码（.java文件）经过编译器（javac）生成为Java字节码（.class文件），在 IDEA 上双击Hello.class文件，可以看到如下内容：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by   decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.itwray.study.advance.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hello</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过注释可以看出，IDEA 默认使用了 FernFlower 反编译工具将字节码文件反编译为我们看得懂的 Java 源代码。</p>
<p>那么，真实的.class文件是什么样子的呢，建议使用 Sublime Text 工具直接打开.class文件，打开后的文件内容如下：</p>
<p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240619165037574.png" alt="image-20240619165037574"></p>
<p>从右下角的 Binary 可以看出，Sublime Text 识别到.class文件为二进制文件，只不过在展示时将其转换为了十六进制。</p>
<p>有了字节码文件后，就可以启动JVM运行字节码文件了（启动方式的本质是使用<code>java</code>命令工具）。</p>
<p>JVM在运行时的执行过程如下：</p>
<ol>
<li><strong>类加载</strong>：通过类加载器加载Hello类。</li>
<li><strong>字节码验证</strong>：验证Hello.class文件的合法性。</li>
<li><strong>内存分配</strong>：在堆上为Hello类的对象分配内存。</li>
<li><strong>解释执行</strong>：JVM解释执行Hello的main方法中的字节码指令。</li>
<li><strong>即时编译</strong>：如果main方法是热点代码，JIT编译器将其编译为本地机器码，提升执行效率。</li>
<li><strong>输出结果</strong>：调用本地方法（java.io.FileOutputStream#writeBytes），通过JNI与操作系统交互，输出“Hello”到控制台。</li>
</ol>
<p>看完JVM的执行机制，突然发现了很多新词汇，在一个一个分析之前，需要先了解了解JVM的组成部分。</p>
<h1>JVM的组成</h1>
<p>Q：<strong>JVM的组成部分有哪些？</strong></p>
<p>JVM大致可以分为类加载器、运行时数据区、执行引擎三个部分，下面是它的组成图。</p>
<p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240624172938.png" alt="20240624172938"></p>
<p>其实在执行引擎之后还有两个组成部分，分别是本地方法接口（JNI）和本地方法库（Native Method Libraries）。可以从上图看出，JVM分析字节码文件的执行过程大致就是按照它的组成部分从上往下执行的。</p>
<p>类加载器是JVM运行Java程序的第一关，主要负责加载类文件（.class文件），如果类文件加载失败，就不会进入到运行时数据区和执行引擎了。类加载器将类文件加载到内存中后，会经过加载、连接、初始化三个主要阶段。</p>
<p>运行时数据区负责存储类的元数据、对象实例、方法调用信息和线程执行状态等。方法区存储类信息和静态数据，堆存储对象实例，Java虚拟机栈和本地方法栈分别管理方法调用和本地方法调用的状态信息，程序计数器记录当前执行的字节码指令地址。这些区域协同工作，确保Java程序能够高效、正确地执行。</p>
<p>执行引擎负责执行Java字节码，将Java字节码指令转换为机器指令，并执行这些指令。它的主要职责包括解释执行、即时编译（JIT）、垃圾回收、以及各种优化技术。</p>
<p>总结：在JVM中，类加载器负责加载类文件并生成<code>Class</code>对象，而为Class对象分配内存空间和初始化是由运行时数据区中的方法区完成的。执行引擎负责解释执行字节码或将其编译为本地机器码并执行。这些组件协同工作，确保类文件被正确加载、分配内存、初始化并执行。</p>
<h1>类加载机制</h1>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<h2 id="类加载时机"><a class="header-anchor" href="#类加载时机"></a>类加载时机</h2>
<p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240710161054762.png" alt="image-20240710161054762"></p>
<h2 id="类加载过程"><a class="header-anchor" href="#类加载过程"></a>类加载过程</h2>
<h3 id="加载"><a class="header-anchor" href="#加载"></a>加载</h3>
<p>加载阶段负责<strong>将类文件从不同来源（如本地文件系统、网络等）加载到内存中，并生成类的<code>Class</code>对象</strong>。这个阶段包括以下步骤：</p>
<ul>
<li><strong>查找并加载类的二进制数据</strong>：类加载器首先在类路径（classpath）中查找类文件。如果找不到，会继续使用其他方式（如网络下载或自定义加载器）查找类文件。</li>
<li><strong>生成类的<code>Class</code>对象</strong>：将加载的类文件的二进制数据解析为JVM内部数据结构，并创建对应的<code>Class</code>对象。</li>
</ul>
<p>Q：<strong>查找类文件的依据是什么？或者说JVM使用什么数据查找的类文件？</strong></p>
<p>类加载器根据类的全限定名称来查找类文件。全限定名称包括包名和类名，例如：<code>com.example.MyClass</code>。</p>
<p>类的全限定名称通常映射到文件路径。例如：类<code>com.example.MyClass</code>映射到文件路径<code>com/example/MyClass.class</code>。</p>
<p>Q：<strong>加载类文件的来源一般有哪些？</strong></p>
<ul>
<li>Classpath：
<ul>
<li>本地文件系统：通常类文件会放在本地文件系统的特定目录中，这些目录通过classpath设置。</li>
<li>JAR文件：类文件可以打包在JAR文件中，通过classpath包含这些JAR文件。</li>
</ul>
</li>
<li>网络：类加载器可以从网络上加载类文件，特别是自定义的类加载器可以从指定的URL或远程服务器上加载类文件。</li>
<li>内存：类文件可以直接从内存中加载。例如，一些框架会生成类文件的字节码并直接加载到JVM中。</li>
<li>其他存储：类文件可以存储在数据库中，某些类加载器可以从数据库中读取和加载类文件。</li>
</ul>
<p>Q：<strong>类加载器有哪些？</strong></p>
<p>以Java 8为例，类加载器一般分为4种：（前三个<code>ClassLoader</code>为内置类加载器）</p>
<ol>
<li>引导类加载器（Bootstrap ClassLoader）：加载核心Java类库（通常位于&lt;JAVA_HOME&gt;/lib目录下），如java.lang.*包中的类。</li>
<li>扩展类加载器（Extension ClassLoader）：加载扩展库（通常位于&lt;JAVA_HOME&gt;/lib/ext目录下）的类。</li>
<li>应用程序类加载器（AppClassLoader）：加载应用程序类路径（classpath）中的类，这是最常用的类加载器。</li>
<li>自定义类加载器：用户可以定义自己的类加载器，以便从特定位置或以特定方式加载类。</li>
</ol>
<p>Q：<strong>怎么确定类文件应该由哪个类加载器加载呢？</strong></p>
<p><code>ClassLoader</code>采用双亲委派模型搜索类和资源，<code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。委派机制如下：</p>
<p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240627173246953.png" alt="image-20240627173246953"></p>
<p>并且，双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<p>Java内置的三个类加载器就是按照 BootstrapClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader 的层级设计的，BootstrapClassLoader作为顶层ClassLoader，是没有父类加载器的。</p>
<p>如果在代码中获取<code>ExtClassLoader</code>的parent ClassLoader，也会输出为空，因为BootstrapClassLoader是由C++实现的，这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p>
<p>提示：双亲委派模型并非是Java强制的约束，只是一种官方推荐的方式，在自定义类加载器中，可以重写<code>C lassLoad</code>的<code>loadClass</code>方法改为不采用双亲委派模型的方式。不过为了避免类重复加载以及Java核心API的安全，一般不建议重写<code>loadClass</code>方法，而是重写<code>findClass</code>方法实现自定义类的加载机制。</p>
<p>Q：<strong>类加载器是怎么解析的类文件的二进制数据呢？</strong></p>
<p>这个问题涉及到类文件的详细结构，后面单独出章节分析。目前只需要记住类文件的组成结构有如下部分：魔数（Magic Number）、版本号（Version Number）、常量池（Constant Pool）、访问标志（Access Flags）、类索引、父类索引和接口索引集合、字段表（Fields）、方法表（Methods）、属性表（Attributes）。</p>
<p>并且，这个组成结构的顺序是固定的，下面是一个类文件的字节码结构组成部分：(u后面的数字表示占用的字节数)</p>
<figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ClassFile</span> {</span><br><span class="line">    <span class="selector-tag">u4</span> <span class="selector-tag">magic</span>;                           <span class="comment">// 魔数</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">minor_version</span>;                   <span class="comment">// 次版本号</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">major_version</span>;                   <span class="comment">// 主版本号</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">constant_pool_count</span>;             <span class="comment">// 常量池计数</span></span><br><span class="line">    <span class="selector-tag">cp_info</span> <span class="selector-tag">constant_pool</span><span class="selector-attr">[constant_pool_count-1]</span>; <span class="comment">// 常量池</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">access_flags</span>;                    <span class="comment">// 访问标志</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">this_class</span>;                      <span class="comment">// 类索引</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">super_class</span>;                     <span class="comment">// 父类索引</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">interfaces_count</span>;                <span class="comment">// 接口计数</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">interfaces</span><span class="selector-attr">[interfaces_count]</span>;    <span class="comment">// 接口索引集合</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">fields_count</span>;                    <span class="comment">// 字段计数</span></span><br><span class="line">    <span class="selector-tag">field_info</span> <span class="selector-tag">fields</span><span class="selector-attr">[fields_count]</span>;    <span class="comment">// 字段表</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">methods_count</span>;                   <span class="comment">// 方法计数</span></span><br><span class="line">    <span class="selector-tag">method_info</span> <span class="selector-tag">methods</span><span class="selector-attr">[methods_count]</span>; <span class="comment">// 方法表</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">attributes_count</span>;                <span class="comment">// 属性计数</span></span><br><span class="line">    <span class="selector-tag">attribute_info</span> <span class="selector-tag">attributes</span><span class="selector-attr">[attributes_count]</span>; <span class="comment">// 属性表</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Q：<strong>创建的<code>Class</code>对象被存储到哪了？</strong></p>
<p>在类加载阶段，生成的<code>Class</code>对象被存放在JVM的<strong>方法区</strong>中。方法区是JVM运行时数据区的一部分，用于存储类的元数据、常量、静态变量和即时编译器编译后的代码等。</p>
<p>而<code>Class</code>在运行时被实例化的对象则是存放在<strong>堆</strong>中，通过这个对象实例可以访问到类的元数据（即<code>Object#getClass()</code>方法）。</p>
<h3 id="连接"><a class="header-anchor" href="#连接"></a>连接</h3>
<p>类连接主要包括三个子步骤：验证（Verification）、准备（Preparation）和解析（Resolution）。这些步骤确保类文件格式正确，分配必要的内存，并将符号引用转换为直接引用。</p>
<h4 id="验证"><a class="header-anchor" href="#验证"></a>验证</h4>
<p>验证阶段中<strong>JVM执行了一系列详细的验证规则，以确保类文件的格式和内容符合JVM规范</strong>，从而保证运行时的安全性和稳定性。验证规则主要由四部分组成：</p>
<ol>
<li><strong>文件格式验证</strong>：确保类文件的格式正确。
<ul>
<li><strong>魔数</strong>：类文件的前四个字节是否为<code>0xCAFEBABE</code>。</li>
<li><strong>版本号</strong>：主次版本号是否在当前JVM的处理范围之内。例如，使用JDK8 javac编译的字节码文件，是不能在JAVA7 java命令下运行的。</li>
<li><strong>常量池</strong>：检查常量池中的每个常量项是否符合类型和格式的要求。例如，<code>CONSTANT_Class_info</code>项的格式是否正确。</li>
<li><strong>常量池索引</strong>：确保常量池中的索引是有效的，不超出常量池的边界。</li>
</ul>
</li>
<li><strong>元数据验证</strong>：确保类文件的元数据（类的结构信息）符合JVM规范。
<ul>
<li><strong>类声明</strong>：检查类的访问标志（如<code>public</code>, <code>final</code>, <code>abstract</code>等）是否合法，确保不能同时使用互斥的标志。</li>
<li><strong>父类和接口</strong>：检查类的父类是否存在并且可访问，确保类实现的接口合法。</li>
<li><strong>字段和方法</strong>：检查字段和方法的声明是否合法，包括访问修饰符、类型、名称等。</li>
<li><strong>方法签名</strong>：确保方法的签名合法，包括参数和返回值类型是否合法。</li>
</ul>
</li>
<li><strong>字节码验证</strong>：确保类文件中的字节码正确。
<ul>
<li><strong>数据流分析</strong>：
<ul>
<li>检查局部变量和操作数栈的使用是否合法，确保操作数栈的深度不超过最大限制。</li>
<li>确保所有变量在使用前已经初始化。</li>
<li>确保方法调用的参数类型和数量正确。</li>
</ul>
</li>
<li><strong>控制流分析</strong>：
<ul>
<li>确保所有的跳转指令跳转到有效的字节码位置，不会跳转到中间的指令或无效的位置。</li>
<li>确保异常处理块（<code>try-catch-finally</code>）的范围合法，不会跨越方法边界。</li>
<li>确保方法中的所有路径都正确处理了异常，确保异常处理器的类型和捕获类型匹配。</li>
</ul>
</li>
</ul>
</li>
<li><strong>符号引用验证</strong>：确保常量池中的符号引用能够被解析为合法的直接引用。
<ul>
<li><strong>类引用</strong>：检查常量池中的类引用是否合法，确保引用的类存在并且可访问。</li>
<li><strong>字段引用</strong>：检查常量池中的字段引用是否合法，确保引用的字段在相应的类或接口中存在并且可访问。</li>
<li><strong>方法引用</strong>：检查常量池中的方法引用是否合法，确保引用的方法在相应的类或接口中存在并且可访问。</li>
</ul>
</li>
</ol>
<h4 id="准备"><a class="header-anchor" href="#准备"></a>准备</h4>
<p>准备阶段主要是<strong>为类的所有静态变量分配内存，并将其初始化为默认值</strong>。</p>
<p><strong>准备阶段与初始化阶段的区别</strong></p>
<ul>
<li><strong>准备阶段</strong>：分配静态变量的内存并将其初始化为默认值。这个过程只涉及默认值的设置，不执行任何用户代码（如静态初始化块和静态变量的显式赋值）。</li>
<li><strong>初始化阶段</strong>：执行类的静态初始化块和静态变量的显式赋值。这个过程是在准备阶段之后进行的，确保所有静态变量已经分配好内存并设置了默认值。</li>
</ul>
<p>注意：</p>
<ul>
<li>这些内存都是在方法区进行分配的，如果是JDK8及以后，方法区的实现是元空间。</li>
<li>类变量此时的初始化是指默认值初始化，而不是用户定义的赋值。默认值如下：
<ul>
<li>整数类型（如<code>int</code>、<code>short</code>、<code>byte</code>、<code>long</code>）：默认值为<code>0</code>。</li>
<li>浮点类型（如<code>float</code>、<code>double</code>）：默认值为<code>0.0</code>。</li>
<li>字符类型（<code>char</code>）：默认值为<code>\u0000</code>（null字符）。</li>
<li>布尔类型（<code>boolean</code>）：默认值为<code>false</code>。</li>
<li>引用类型（如对象引用）：默认值为<code>null</code>。（引用类型包括String、Integer、枚举等）</li>
</ul>
</li>
<li>如果类变量被 final 关键字修饰，那就需要根据变量类型决定其何时被初始化。如果是基本类型和字符串常量，则在准备阶段就会被初始化赋值；如果是引用类型（包括Integer、枚举、自定义类等），则还是在初始化阶段被赋值，准备阶段仍为null。</li>
</ul>
<h4 id="解析"><a class="header-anchor" href="#解析"></a>解析</h4>
<p>解析阶段是<strong>Java虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>
<p><strong>符号引用</strong>：<strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</strong>。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p>
<p><strong>直接引用</strong>：<strong>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</strong>。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
<p>在解析阶段，因为需要将符号引用替换为直接引用，所以在此阶段可能会抛出各种异常，例如：</p>
<ul>
<li>ClassNotFoundException：无法找到所需的类或接口。</li>
<li>NoSuchFieldError：无法找到所需的字段。</li>
<li>NoSuchMethodError：无法找到所需的方法。</li>
<li>IllegalAccessError：类或接口、字段、方法解析时，发现不具备访问权限。</li>
<li>IncompatibleClassChangeError：解析过程中发现类的结构与预期不符。</li>
</ul>
<p>Q：<strong>用一句话总结连接过程三个阶段主要做了什么。</strong></p>
<p>验证阶段确保类文件的字节码是否符合JVM规范，准备阶段就是为类变量分配内存并初始化为默认值的过程，解析阶段是JVM将常量池中的符号引用替换为直接引用的过程。</p>
<p>Q：<strong>这三个阶段是按照顺序执行的吗？</strong></p>
<p>从类加载过程来说，是顺序执行的。但对《Java虚拟机规范》而言，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。顺序按部就班地开始表示这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p>
<p>验证阶段保证了字节码的合法和安全，如果验证失败，整个类加载过程就会被中断，所以验证阶段是第一步。</p>
<p>准备阶段为静态变量分配内存并设置默认值，解析阶段是将常量池的符号引用替换为直接引用。从语义上来看，两个阶段在部分情况下可以并行执行，但是在JVM的实际实现中，为了保证类加载过程的逻辑清晰和实现简单，所以这两个阶段在实际情况下还是按照顺序执行的。</p>
<p>而至于为什么要把准备阶段放在解析阶段之前，主要是因为在解析过程中可能需要访问或验证静态变量的类型和内存布局。如果准备阶段未完成，这些信息可能不完整或不可用。所以解析阶段依赖于准备阶段。</p>
<h3 id="初始化"><a class="header-anchor" href="#初始化"></a>初始化</h3>
<p>初始化阶段是类加载过程的最后一个步骤，它的<strong>主要任务是执行类的初始化逻辑，即执行类构造器&lt;clinit&gt;()方法的过程</strong>。</p>
<p>&lt;clinit&gt;()并不是程序中编写的构造方法（实例的构造方法在JVM视角中称为&lt;init&gt;()方法），<strong>它是javac编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {}块）中语句 合并产生的</strong>，编译器收集的顺序是由语句在源文件中出现的顺序决定的。</p>
<p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问（不能直接使用变量名访问，但可以使用&lt;类名.变量名&gt;的方式访问）。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">        System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">      	System.out.println(InitializeDemo.i); <span class="comment">// 这句编译可以通过，并且可执行输出为0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>&lt;clinit&gt;方法与类的构造方法不同，它不需要显式地调用父类&lt;clinit&gt;()方法，Java虚拟机会保证在子类的&lt;clinit&gt;()方法执行前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在Java虚拟机中第一个被执行的&lt;clinit&gt;()方法的类型肯定是java.lang.Object。</p>
<p>由于父类的&lt;clinit&gt;()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。例如如下示例中，输出的结果为2。</p>
<p>&lt;clinit&gt;()方法对于类或接口不是必需的，如果一个类中没有静态语句块和类变量赋值操作，那么javac编译器可以不为这个类生成&lt;clinit&gt;()方法。</p>
<p>接口虽然不能定义静态语句块，但可以有变量赋值操作，它属于类变量赋值操作。但接口与类不同，在初始化阶段，子接口不会先执行父接口的&lt;clinit&gt;()方法，只有当父接口定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也会执行接口的&lt;clinit&gt;()方法。</p>
<p>每个类的&lt;clinit&gt;()方法在类加载过程中只会执行一次，它通过对&lt;clinit&gt;()方法加锁实现，确保多线程环境中只会有其中一个线程去执行&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程的&lt;clinit&gt;()方法执行完毕。如果在类初始化过程中出现异常，该异常都会被封装成<code>ExceptionInInitializerError</code>异常抛出。</p>
<p>类的初始化阶段是惰性的，即在首次使用该类时才会触发。触发情况有如下几种：</p>
<ul>
<li>当创建类的新实例时（使用<code>new</code>关键字）。</li>
<li>当访问类的静态字段或调用静态方法时。</li>
<li>当反射机制调用类的方法时（例如，<code>Class.forName</code>）。</li>
<li>当初始化一个类的子类时，父类会先被初始化。</li>
<li>当虚拟机启动时，用户指定的主类会首先被初始化。</li>
</ul>
<p>因为初始化是惰性的，也间接说明了<strong>类在经过加载、连接阶段后，并不一定会马上执行初始化阶段</strong>。常见情况有如下几种：</p>
<ol>
<li>
<p>通过反射查询类信息，但不实际使用</p>
<p>使用反射机制查询类的信息，例如获取类的元数据（字段、方法等），这会触发类的加载和解析，但不会触发初始化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"Example"</span>, <span class="literal">false</span>, Test.class.getClassLoader());</span><br><span class="line">        <span class="comment">// 仅查询类信息，不触发初始化</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>仅仅解析类而未实际访问</p>
<p>某些情况下，JVM在运行过程中可能会预解析类以提高性能，但如果这些类没有被实际使用，则不会进入初始化阶段。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Class&lt;?&gt; clazz = Example.class;  <span class="comment">// 仅解析类，不触发初始化</span></span><br><span class="line">        System.out.println(<span class="string">"Main method"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>引用常量</p>
<p>使用类的常量字段（<code>final static</code> 修饰的基本类型或字符串）时，只会触发类的加载和解析，不会触发初始化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONST</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"Example class static block"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Example.CONST;  <span class="comment">// 不会触发初始化</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h2 id="类加载器"><a class="header-anchor" href="#类加载器"></a>类加载器</h2>
<p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
<h3 id="类与类加载器"><a class="header-anchor" href="#类与类加载器"></a>类与类加载器</h3>
<p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<p>换一句话说就是：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">myLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="literal">null</span>) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myLoader.loadClass(<span class="string">"com.itwray.study.advance.jvm.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">        <span class="comment">// 输出结果：class com.itwray.study.advance.jvm.ClassLoaderTest</span></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        <span class="comment">// 输出结果：false</span></span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> com.itwray.study.advance.jvm.ClassLoaderTest);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="双亲委派模型"><a class="header-anchor" href="#双亲委派模型"></a>双亲委派模型</h3>
<p>JVM中内置了三个<code>ClassLoader</code>：</p>
<ul>
<li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li>
<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JAVA_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li>
<li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向开发者的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240627173246953.png" alt="image-20240627173246953"></p>
<p>上图展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents DelegationModel）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p>双亲委派模型的好处是当一个类处于包含多个类加载器的JVM环境下时，可以保证加载出来的都是同一个类。即一个全限定名的类，在一个JVM下加载多次得到的Class类对象是相等的。</p>
<p>例如，手写一个rt.jar类库下的<code>java.lang.String</code>类，当通过<code>Class.forName()</code>方法加载时，并没有执行手写的String类的static块代码，说明没有加载这个类，而是加载的rt.jar类库下的String类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"custom String static method"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        Class&lt;?&gt; stringClass = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        System.out.println(stringClass.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>双亲委派模型的实现位于java.lang.ClassLoader的loadClass()方法中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码来自jdk8</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) {</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">              <span class="comment">// 如果父类加载器抛出ClassNotFoundException，说明父类加载器无法完成加载请求</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 在父类加载器无法加载时，再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (resolve) {</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="模块化下的类加载器"><a class="header-anchor" href="#模块化下的类加载器"></a>模块化下的类加载器</h2>
<p>JDK 9 之后为了适应模块化的发展，类加载器做了如下变化：</p>
<ul>
<li>仍维持三层类加载器和双亲委派的架构，但扩展类加载器被平台类加载器所取代；</li>
<li>当平台及应用程序类加载器收到类加载请求时，要首先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载；</li>
<li>启动类加载器、平台类加载器、应用程序类加载器全部继承自 <code>java.internal.loader.BuiltinClassLoader</code> ，BuiltinClassLoader 中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</li>
</ul>
<p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240710173108681.png" alt="image-20240710173108681"></p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>JVM类加载机制是Java程序运行的基础，它通过加载、连接（验证、准备、解析）和初始化阶段将类文件动态加载到内存中，并通过双亲委派模型确保了类加载的安全性和一致性。</p>
<h1>运行时数据区</h1>
<p>运行时数据区隶属于Java 内存区域的一部分，主要讲述Java虚拟机对于内存区域的划分，这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/image-20240712152559344.png" alt="image-20240712152559344"></p>
<p>其中方法区和堆属于所有线程共享的数据区，而虚拟机栈、本地方法栈、程序计数器是线程隔离的数据区，也就是说隔离的数据区保证每个线程下都有对应的虚拟机栈、本地方法栈和程序计数器。</p>
<h2 id="程序计数器"><a class="header-anchor" href="#程序计数器"></a>程序计数器</h2>
<p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</p>
<p>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="Java虚拟机栈"><a class="header-anchor" href="#Java虚拟机栈"></a>Java虚拟机栈</h2>
<p>Java虚拟机栈（Java Virtual Machine Stack）又称为JVM栈，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>
<p>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<h2 id="本地方法栈"><a class="header-anchor" href="#本地方法栈"></a>本地方法栈</h2>
<p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<p>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="Java堆"><a class="header-anchor" href="#Java堆"></a>Java堆</h2>
<p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的内存区域，它可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。</p>
<p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。</p>
<p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>
<h2 id="方法区"><a class="header-anchor" href="#方法区"></a>方法区</h2>
<p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>JDK 8 以后的方法区实现已经不再是永久代（Permanent Generation）了，而是使用元空间（Metaspace）来实现。</p>
<p>方法区也是可以存在垃圾收集的行为的，不过这个区域的回收效果一般微乎其微。因此，如果方法区无法满足新的内存分配需求时，同样会抛出 OutOfMemoryError 异常。</p>
<p>运行时常量池（Runtime Constant Pool）也是方法区的一部分，用于存放常量池表（Constant Pool Table），常量池表中存放了编译期生成的各种符号字面量和符号引用。</p>
<h1>字节码执行引擎</h1>
<p>JVM字节码执行引擎是Java虚拟机的核心组件之一，它负责执行已加载到内存中的Java字节码，并将其转换为具体的机器指令以执行程序。执行引擎的主要任务包括解释执行字节码、JIT编译、垃圾回收和线程调度等。</p>
<h2 id="解释执行字节码"><a class="header-anchor" href="#解释执行字节码"></a>解释执行字节码</h2>
<p>JVM字节码是一种与平台无关的中间表示形式。解释执行是将字节码逐条转换为相应的机器指令并执行。</p>
<p>字节码解释器：</p>
<ul>
<li>JVM内置的字节码解释器逐条读取字节码指令并执行相应的操作。</li>
<li>解释执行通常较慢，因为每条指令都需要解析和解释。</li>
</ul>
<h2 id="JIT（Just-In-Time）编译"><a class="header-anchor" href="#JIT（Just-In-Time）编译"></a>JIT（Just-In-Time）编译</h2>
<p>为了提高执行效率，JVM使用即时编译技术，将热点代码（被频繁执行的代码）编译为本地机器码，直接在硬件上运行。</p>
<ul>
<li>即时编译器（JIT Compiler）：
<ul>
<li><strong>C1编译器</strong>：注重编译速度，用于编译简单和不太频繁的代码。</li>
<li><strong>C2编译器</strong>：注重优化性能，用于编译频繁执行的热点代码。</li>
</ul>
</li>
<li><strong>热点探测</strong>：JVM通过计数器统计方法的调用次数或循环次数，以识别热点代码。</li>
<li><strong>编译优化</strong>：包括内联、循环展开、逃逸分析等，进一步提高执行效率。</li>
</ul>
<h2 id="垃圾回收（Garbage-Collection）"><a class="header-anchor" href="#垃圾回收（Garbage-Collection）"></a>垃圾回收（Garbage Collection）</h2>
<p>JVM自动管理内存分配和回收，执行引擎中的垃圾回收器负责清理不再使用的对象，释放内存。</p>
<ul>
<li>垃圾回收算法：
<ul>
<li><strong>标记-清除算法</strong>：标记所有可达对象，清除未标记对象。</li>
<li><strong>复制算法</strong>：将存活对象复制到新空间，清空旧空间。</li>
<li><strong>标记-压缩算法</strong>：标记所有可达对象，将存活对象压缩到一端，清除其他空间。</li>
</ul>
</li>
<li>垃圾回收器：
<ul>
<li><strong>Serial GC</strong>：单线程垃圾回收器，适用于小型应用。</li>
<li><strong>Parallel GC</strong>：多线程垃圾回收器，适用于多核处理器。</li>
<li><strong>CMS GC</strong>：并发标记-清除垃圾回收器，减少停顿时间。</li>
<li><strong>G1 GC</strong>：分代垃圾回收器，平衡停顿时间和吞吐量。</li>
</ul>
</li>
</ul>
<h2 id="线程管理"><a class="header-anchor" href="#线程管理"></a>线程管理</h2>
<p>JVM执行引擎负责管理Java线程的生命周期，包括线程的创建、调度和销毁。</p>
<ul>
<li>线程调度：
<ul>
<li>JVM使用操作系统的线程调度机制来管理Java线程。</li>
<li>线程的状态包括新建、就绪、运行、阻塞、等待和终止。</li>
</ul>
</li>
<li>同步和并发：
<ul>
<li>JVM提供了关键字<code>synchronized</code>和<code>volatile</code>，以及<code>java.util.concurrent</code>包，支持多线程编程和并发控制。</li>
</ul>
</li>
</ul>
<h2 id="方法调用和返回"><a class="header-anchor" href="#方法调用和返回"></a>方法调用和返回</h2>
<p>执行引擎负责处理Java方法的调用和返回，包括静态方法、实例方法、构造方法等。</p>
<ul>
<li>方法调用：
<ul>
<li><strong>静态绑定</strong>：在编译时确定调用的方法（如静态方法和私有方法）。</li>
<li><strong>动态绑定</strong>：在运行时根据对象的实际类型确定调用的方法（如实例方法）。</li>
</ul>
</li>
<li><strong>方法返回</strong>：处理方法的返回值和返回指令，管理方法调用栈帧的创建和销毁。</li>
</ul>
<h2 id="异常处理"><a class="header-anchor" href="#异常处理"></a>异常处理</h2>
<p>执行引擎处理Java程序中的异常，包括捕获和抛出异常。</p>
<ul>
<li><strong>异常捕获</strong>：使用<code>try-catch</code>块捕获异常。</li>
<li><strong>异常抛出</strong>：使用<code>throw</code>语句抛出异常。</li>
<li><strong>异常处理机制</strong>：遍历调用栈，查找匹配的异常处理器。</li>
</ul>
<h2 id="本地方法调用"><a class="header-anchor" href="#本地方法调用"></a>本地方法调用</h2>
<p>JVM执行引擎通过本地方法接口（JNI）调用本地代码，实现与平台相关的功能。</p>
<ul>
<li><strong>JNI（Java Native Interface）</strong>：允许Java程序调用本地C/C++代码。</li>
<li><strong>本地方法库</strong>：加载和执行本地方法库（如<code>.dll</code>或<code>.so</code>文件）。</li>
</ul>
<h2 id="总结-2"><a class="header-anchor" href="#总结-2"></a>总结</h2>
<p>JVM字节码执行引擎主要包括以下功能：</p>
<ol>
<li><strong>解释执行字节码</strong>：逐条解释和执行字节码指令。</li>
<li><strong>JIT编译</strong>：将热点代码编译为本地机器码，提高执行效率。</li>
<li><strong>垃圾回收</strong>：自动管理内存，回收不再使用的对象。</li>
<li><strong>线程管理</strong>：管理Java线程的生命周期和调度。</li>
<li><strong>方法调用和返回</strong>：处理方法的调用、执行和返回。</li>
<li><strong>异常处理</strong>：捕获和处理Java异常。</li>
<li><strong>本地方法调用</strong>：通过JNI调用本地代码。</li>
</ol>
<h1>参考</h1>
<ul>
<li>《深入理解Java虚拟机》（第三版）</li>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/class-file-structure.html">https://javaguide.cn/java/jvm/class-file-structure.html</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/9229.html">https://coolshell.cn/articles/9229.html</a></li>
<li><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/class-file-jiegou.html">https://javabetter.cn/jvm/class-file-jiegou.html</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.itwray.com">Wray</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.itwray.com/2024/06/18/java-jvm-basic/">https://blog.itwray.com/2024/06/18/java-jvm-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.itwray.com" target="_blank">WrayのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240710174022.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/30/java-jvm-classFileStructure/" title="Java-JVM类文件结构"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240729163843.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java-JVM类文件结构</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/04/springdoc-hello/" title="再见SpringFox，你好SpringDoc"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240304173959.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">再见SpringFox，你好SpringDoc</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/30/java-jvm-classFileStructure/" title="Java-JVM类文件结构"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240729163843.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-30</div><div class="title">Java-JVM类文件结构</div></div></a></div><div><a href="/2024/07/03/java-jvm-readClassFile/" title="Java-“手撕”Class文件结构"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240801110726.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-03</div><div class="title">Java-“手撕”Class文件结构</div></div></a></div><div><a href="/2023/09/26/aop-aspectj-execution/" title="AspectJ之Execution表达式"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/space-needle-8027331_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-26</div><div class="title">AspectJ之Execution表达式</div></div></a></div><div><a href="/2023/09/20/arthas-use/" title="记录一次使用Arthas的过程"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/night-view-8306605_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-20</div><div class="title">记录一次使用Arthas的过程</div></div></a></div><div><a href="/2023/10/07/java-io-resource/" title="Java获取资源文件的输入流"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/trees-8458467_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Java获取资源文件的输入流</div></div></a></div><div><a href="/2023/10/07/java-project-structure/" title="IDEA Java项目的目录结构为什么要是 src/main/java 形式?"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/sunset-8283538_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">IDEA Java项目的目录结构为什么要是 src/main/java 形式?</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/touxiang.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Wray</div><div class="author-info__description">记录生活的点点滴滴<br>Keep track of my life</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wangfarui" target="_blank" title="Github"><i class="fab fa-github" style="color: #f1f2f4;"></i></a><a class="social-icon" href="mailto:wray20156294@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #f26522;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">JVM是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JVM的组成</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-number">4.1.</span> <span class="toc-text">类加载时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.2.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.2.3.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">类与类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8B%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">模块化下的类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">5.2.</span> <span class="toc-text">Java虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">5.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%A0%86"><span class="toc-number">5.4.</span> <span class="toc-text">Java堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">5.5.</span> <span class="toc-text">方法区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">6.1.</span> <span class="toc-text">解释执行字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JIT%EF%BC%88Just-In-Time%EF%BC%89%E7%BC%96%E8%AF%91"><span class="toc-number">6.2.</span> <span class="toc-text">JIT（Just-In-Time）编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88Garbage-Collection%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">垃圾回收（Garbage Collection）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">线程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="toc-number">6.5.</span> <span class="toc-text">方法调用和返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.6.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">6.7.</span> <span class="toc-text">本地方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">6.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/echart-uni-20241015/" title="记录一次在uni-app中使用echarts的坑"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/20241015213053.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记录一次在uni-app中使用echarts的坑"></a><div class="content"><a class="title" href="/2024/10/15/echart-uni-20241015/" title="记录一次在uni-app中使用echarts的坑">记录一次在uni-app中使用echarts的坑</a><time datetime="2024-10-15T12:26:07.000Z" title="发表于 2024-10-15 20:26:07">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/13/rocketmq-springboot-simple/" title="RocketMQ 5.x在SpringBoot中的上手使用过程"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/20241013131831.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ 5.x在SpringBoot中的上手使用过程"></a><div class="content"><a class="title" href="/2024/10/13/rocketmq-springboot-simple/" title="RocketMQ 5.x在SpringBoot中的上手使用过程">RocketMQ 5.x在SpringBoot中的上手使用过程</a><time datetime="2024-10-13T05:13:01.000Z" title="发表于 2024-10-13 13:13:01">2024-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/23/fail2ban-use/" title="Fail2Ban使用心得"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/20241015213235.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Fail2Ban使用心得"></a><div class="content"><a class="title" href="/2024/09/23/fail2ban-use/" title="Fail2Ban使用心得">Fail2Ban使用心得</a><time datetime="2024-09-23T04:23:29.000Z" title="发表于 2024-09-23 12:23:29">2024-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/26/spring-boot-redis-use/" title="SpringBoot集成Redis使用心得"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240826154118.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot集成Redis使用心得"></a><div class="content"><a class="title" href="/2024/08/26/spring-boot-redis-use/" title="SpringBoot集成Redis使用心得">SpringBoot集成Redis使用心得</a><time datetime="2024-08-26T07:27:17.000Z" title="发表于 2024-08-26 15:27:17">2024-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/03/java-jvm-readClassFile/" title="Java-“手撕”Class文件结构"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240801110726.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java-“手撕”Class文件结构"></a><div class="content"><a class="title" href="/2024/07/03/java-jvm-readClassFile/" title="Java-“手撕”Class文件结构">Java-“手撕”Class文件结构</a><time datetime="2024-07-03T03:31:38.000Z" title="发表于 2024-07-03 11:31:38">2024-07-03</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 - 2024 By Wray</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>鄂ICP备2024050235号-1</span></a> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=42018502007471" rel="noreferrer" target="_blank"><img class="icp-icon" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/beian.png"><span>鄂公网安备42018502007471</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liElrglVY7VkALhS',
      clientSecret: 'be255ab0fc6f3cd6212bab51c445b209672284f7',
      repo: 'wangfarui.github.io',
      owner: 'wangfarui',
      admin: ['wangfarui'],
      id: '92a1aba09e0372e3ad1a99afd3da71a3',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>