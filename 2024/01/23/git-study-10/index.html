<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git学习-Git内部原理 | WrayのBlog</title><meta name="author" content="Wray"><meta name="copyright" content="Wray"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第十章学习 Git 内部工作原理和实现方式。">
<meta property="og:type" content="article">
<meta property="og:title" content="Git学习-Git内部原理">
<meta property="og:url" content="https://blog.itwray.com/2024/01/23/git-study-10/index.html">
<meta property="og:site_name" content="WrayのBlog">
<meta property="og:description" content="第十章学习 Git 内部工作原理和实现方式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://itwray.oss-cn-heyuan.aliyuncs.com/img/field-8419729_1920.jpg">
<meta property="article:published_time" content="2024-01-23T09:02:49.000Z">
<meta property="article:modified_time" content="2024-09-27T13:14:24.205Z">
<meta property="article:author" content="Wray">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://itwray.oss-cn-heyuan.aliyuncs.com/img/field-8419729_1920.jpg"><link rel="shortcut icon" href="https://itwray.oss-cn-heyuan.aliyuncs.com/img/W.svg"><link rel="canonical" href="https://blog.itwray.com/2024/01/23/git-study-10/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git学习-Git内部原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-27 21:14:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 3 || hour >= 4
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="WrayのBlog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/touxiang.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://status.itwray.com"><i class="fa-fw fas fa-bolt-lightning"></i><span> 监控</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="WrayのBlog"><span class="site-name">WrayのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://status.itwray.com"><i class="fa-fw fas fa-bolt-lightning"></i><span> 监控</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Git学习-Git内部原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-23T09:02:49.000Z" title="发表于 2024-01-23 17:02:49">2024-01-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-27T13:14:24.205Z" title="更新于 2024-09-27 21:14:24">2024-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Git/">Git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Git学习-Git内部原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="底层命令与上层命令"><a class="header-anchor" href="#底层命令与上层命令"></a>底层命令与上层命令</h2>
<p>Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统， 所以它还包含了一部分用于完成底层工作的子命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“上层（porcelain）”命令。</p>
<p>前面的章节中，探讨的都是上层命令，而在本章中，我们将主要面对底层命令。 因为，底层命令得以让你窥探 Git 内部的工作机制，也有助于说明 Git 是如何完成工作的，以及它为何如此运作。 多数底层命令并不面向最终用户：它们更适合作为新工具的组件和自定义脚本的组成部分。</p>
<p>当在一个新目录或已有目录执行 <code>git init</code> 时，Git 会创建一个 <code>.git</code> 目录。 这个目录包含了几乎所有 Git 存储和操作的东西。 如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。 本章探讨的所有内容，均位于这个目录内。 新初始化的 <code>.git</code> 目录的典型结构如下：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -F1</span></span><br><span class="line">config</span><br><span class="line">description</span><br><span class="line">HEAD</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></tbody></table></figure>
<p><code>description</code> 文件仅供 GitWeb 程序使用，我们无需关心。 <code>config</code> 文件包含项目特有的配置选项。 <code>info</code> 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 <code>.gitignore</code> 文件中的忽略模式（ignored patterns）。 <code>hooks</code> 目录包含客户端或服务端的钩子脚本（hook scripts）。</p>
<p>剩下的四个条目很重要：<code>HEAD</code> 文件、（尚待创建的）<code>index</code> 文件，和 <code>objects</code> 目录、<code>refs</code> 目录。 它们都是 Git 的核心组成部分。 <code>objects</code> 目录存储所有数据内容；<code>refs</code> 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针； <code>HEAD</code> 文件指向目前被检出的分支；<code>index</code> 文件保存暂存区信息。</p>
<h2 id="Git-对象"><a class="header-anchor" href="#Git-对象"></a>Git 对象</h2>
<p>Git 是一个内容寻址文件系统，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。</p>
<p>在一个 Git 版本库（尽量使用刚初始化的新版本库）下，用 <code>git hash-object</code> 创建一个新的数据对象并将它手动存入 Git 数据库中：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">'test content'</span> | git hash-object -w --stdin</span></span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></tbody></table></figure>
<p>在这种最简单的形式中，<code>git hash-object</code> 会接受你传给它的东西，而它只会返回可以存储在 Git 仓库中的唯一键。 <code>-w</code> 选项会指示该命令不要只返回键，还要将该对象写入数据库中。 最后，<code>--stdin</code> 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。</p>
<p>此命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。</p>
<p>使用 <code> find .git/objects -type f</code> 查看 Git 存储数据。</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find .git/objects -<span class="built_in">type</span> f</span></span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></tbody></table></figure>
<p>如果你再次查看 <code>objects</code> 目录，那么可以在其中找到一个与新内容对应的文件。 这就是开始时 Git 存储内容的方式——一个文件对应一条内容， 以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p>
<p>一旦你将内容存储在了对象数据库中，那么可以通过 <code>cat-file</code> 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 <code>cat-file</code> 指定 <code>-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span></span><br><span class="line">test content</span><br></pre></td></tr></tbody></table></figure>
<p>同样可以将这些操作应用于文件中的内容。 例如，可以对一个文件进行简单的版本控制。 首先，创建一个新文件并将其内容存入数据库：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">'version 1'</span> &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git hash-object -w test.txt</span></span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></tbody></table></figure>
<p>接着，向文件里写入新内容，并再次将其存入数据库：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">'version 2'</span> &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git hash-object -w test.txt</span></span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br></pre></td></tr></tbody></table></figure>
<p>对象数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find .git/objects -<span class="built_in">type</span> f</span></span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></tbody></table></figure>
<p>现在可以在删掉 <code>test.txt</code> 的本地副本，然后用 Git 从对象数据库中取回它的第一个版本：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br><span class="line">version 1</span><br></pre></td></tr></tbody></table></figure>
<p>或者第二个版本：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span></span><br><span class="line">version 2</span><br></pre></td></tr></tbody></table></figure>
<p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为 <strong>数据对象（blob object）</strong>。 利用 <code>git cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span></span><br><span class="line">blob</span><br></pre></td></tr></tbody></table></figure>
<h3 id="树对象"><a class="header-anchor" href="#树对象"></a>树对象</h3>
<p>树对象（tree object）解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 <strong>所有内容均以树对象和数据对象的形式存储</strong>，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p>
<p>使用 <code>git cat-file -p main^{tree}</code> 命令，查看项目 main 分支下最新树对象。</p>
<p><img src="/2024/01/23/git-study-10/image-20240130152921901.png" alt="image-20240130152921901"></p>
<p>其中 lib 表示一个指针，其指向的是另一个树对象，通过 <code>git cat-file -p &lt;SHA-1&gt;</code> 查看树对象下的对象结构。</p>
<p><img src="/2024/01/23/git-study-10/image-20240130153109433.png" alt="image-20240130153109433"></p>
<p>通过 <code>git update-index</code> 命令，可以直接从底层创建树对象。通常情况下，Git 根据某一时刻暂存区（即 index 区域）所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录（某个时间段内）一系列的树对象。</p>
<p>可以通过底层命令 <code>git update-index</code> 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。 利用该命令，可以把 <code>test.txt</code> 文件的首个版本人为地加入一个新的暂存区。 必须为上述命令指定 <code>--add</code> 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）； 同样必需的还有 <code>--cacheinfo</code> 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。 同时，需要指定文件模式、SHA-1 与文件名：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git update-index --add --cacheinfo 100644 \</span></span><br><span class="line"><span class="language-bash">  83baae61804e65cc73a7201a7252750c76066a30 test.txt</span></span><br></pre></td></tr></tbody></table></figure>
<p>指定的文件模式为 <code>100644</code>，表明这是一个普通文件。 其他选择包括：<code>100755</code>，表示一个可执行文件；<code>120000</code>，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p>
<p>通过 <code>git write-tree</code> 命令将暂存区内容写入一个树对象。</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git write-tree</span></span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span></span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</span><br></pre></td></tr></tbody></table></figure>
<p><code>git write-tree</code> 返回的 SHA-1 值是当前目录下的树对象值，通过 <code>git cat-file</code> 查看树对象，可以发现 test.txt 被添加到当前树对象下了，其 SHA-1 值就是 <code>git update-index</code> 指定的值。</p>
<p>再次进行操作，添加一个新文件，并对 test.txt 文件做修改后再暂存。</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">'new file'</span> &gt; new.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git update-index --add --cacheinfo 100644 \</span></span><br><span class="line"><span class="language-bash">  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git update-index --add new.txt</span></span><br></pre></td></tr></tbody></table></figure>
<p>暂存区现在包含了 <code>test.txt</code> 文件的新版本，和一个新文件：<code>new.txt</code>。 记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git write-tree</span></span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span></span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></tbody></table></figure>
<p>我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（<code>1f7a7a</code>）是先前值的“第二版”。</p>
<h3 id="提交对象"><a class="header-anchor" href="#提交对象"></a>提交对象</h3>
<p>树对象的操作中，会出现不同版本的快照，每个快照会对应不用的 SHA-1 哈希值，在没有提交之前，是无法记录这些快照在什么时刻保存的，以及为什么保存这些快照的。</p>
<p>通过 <code>git commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">'commit-tree 1'</span> | git commit-tree 2ed7</span> </span><br><span class="line">b4f6196421ede1205a6e8affdba8a23b741e762a</span><br></pre></td></tr></tbody></table></figure>
<p>由于创建时间和作者数据不同，你现在会得到一个不同的散列值。 请将本章后续内容中的提交和标签的散列值替换为你自己的校验和。 现在可以通过 <code>git cat-file</code> 命令查看这个新提交对象：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p b4f619</span></span><br><span class="line">tree 2ed706a25355ec1a647e0d54971bcc3426f6cfb6</span><br><span class="line">author Wray &lt;wray20156294@gmail.com&gt; 1706601067 +0800</span><br><span class="line">committer Wray &lt;wray20156294@gmail.com&gt; 1706601067 +0800</span><br><span class="line"></span><br><span class="line">commit-tree 1</span><br></pre></td></tr></tbody></table></figure>
<p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照； 然后是可能存在的父提交（前面描述的提交对象并不存在任何父提交）； 之后是作者/提交者信息（依据你的 <code>user.name</code> 和 <code>user.email</code> 配置来设定，外加一个时间戳）； 留空一行，最后是提交注释。</p>
<p>将 <code>2ed7</code> 树对象指定父对象为 <code>f9bba3</code> ，将提交记录挂载到父提交记录上。</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">'commit-tree 1'</span> | git commit-tree 2ed7 -p f9bba34</span></span><br><span class="line">3ffffc279924563d89505e654eb42bb8daa64a60</span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>git log</code> 查看 <code>3ffffc</code> 下的提交日志。</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --<span class="built_in">stat</span> 3ffffc</span></span><br><span class="line">commit 3ffffc279924563d89505e654eb42bb8daa64a60</span><br><span class="line">Author: Wray &lt;wray20156294@gmail.com&gt;</span><br><span class="line">Date:   Tue Jan 30 15:54:31 2024 +0800</span><br><span class="line"></span><br><span class="line">    commit-tree 1</span><br><span class="line"></span><br><span class="line"> pro.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">commit f9bba34686b949ce2e359bdfbdc7c855d32dc811 (HEAD -&gt; main)</span><br><span class="line">Author: Wray &lt;wray20156294@gmail.com&gt;</span><br><span class="line">Date:   Tue Jan 30 15:29:08 2024 +0800</span><br><span class="line"></span><br><span class="line">    new lib dir</span><br><span class="line"></span><br><span class="line"> lib/a         | 1 +</span><br><span class="line"> lib/print.out | 1 +</span><br><span class="line"> test.txt      | 1 +</span><br><span class="line"> 3 files changed, 3 insertions(+)</span><br><span class="line"></span><br><span class="line">commit 46eee871bcaa6acbc3568b2e1af69fa5bca2500c</span><br><span class="line">Author: Wray &lt;wray20156294@gmail.com&gt;</span><br><span class="line">Date:   Tue Jan 23 16:13:14 2024 +0800</span><br><span class="line"></span><br><span class="line">    commit 1</span><br><span class="line"></span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></tbody></table></figure>
<p>可以发现，在没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。 这就是每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。</p>
<p>这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 <code>.git/objects</code> 目录下。</p>
<h2 id="Git-引用"><a class="header-anchor" href="#Git-引用"></a>Git 引用</h2>
<p>如果你对仓库中从一个提交（比如 <code>1a410e</code>）开始往前的历史感兴趣，那么可以运行 <code>git log 1a410e</code> 这样的命令来显示历史，不过你需要记得 <code>1a410e</code> 是你查看历史的起点提交。 如果我们有一个文件来保存 SHA-1 值，而该文件有一个简单的名字， 然后用这个名字指针来替代原始的 SHA-1 值的话会更加简单。</p>
<p>在 Git 中，这种简单的名字被称为“引用（references，或简写为 refs）”。 你可以在 <code>.git/refs</code> 目录下找到这类含有 SHA-1 值的文件。 在目前的项目中，这个目录没有包含任何文件，但它包含了一个简单的目录结构：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find .git/refs</span></span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find .git/refs -<span class="built_in">type</span> f</span></span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>git update-ref</code> 更新引用，若想在第二个提交上创建一个分支，可以这么做：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git update-ref refs/heads/test cac0ca</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个分支将只包含从第二个提交开始往前追溯的记录：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline <span class="built_in">test</span></span></span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></tbody></table></figure>
<h3 id="HEAD文件"><a class="header-anchor" href="#HEAD文件"></a>HEAD文件</h3>
<p>现在的问题是，当你执行 <code>git branch &lt;branch&gt;</code> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p>
<p>HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的指针。</p>
<h3 id="标签引用"><a class="header-anchor" href="#标签引用"></a>标签引用</h3>
<p>前面我们刚讨论过 Git 的三种主要的对象类型（<strong>数据对象</strong>、<strong>树对象</strong> 和 <strong>提交对象</strong> ），然而实际上还有第四种。 <strong>标签对象（tag object）</strong> 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p>
<h3 id="远程引用"><a class="header-anchor" href="#远程引用"></a>远程引用</h3>
<p>如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 <code>refs/remotes</code> 目录下。 例如，你可以添加一个叫做 <code>origin</code> 的远程版本库，然后把 <code>master</code> 分支推送上去：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin git@github.com:schacon/simplegit-progit.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br><span class="line">Counting objects: 11, done.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (7/7), 716 bytes, done.</span><br><span class="line">Total 7 (delta 2), reused 4 (delta 1)</span><br><span class="line">To git@github.com:schacon/simplegit-progit.git</span><br><span class="line">  a11bef0..ca82a6d  master -&gt; master</span><br></pre></td></tr></tbody></table></figure>
<p>此时，如果查看 <code>refs/remotes/origin/master</code> 文件，可以发现 <code>origin</code> 远程版本库的 <code>master</code> 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 <code>master</code> 分支所对应的 SHA-1 值：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .git/refs/remotes/origin/master</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></tbody></table></figure>
<p>远程引用和分支（位于 <code>refs/heads</code> 目录下的引用）之间最主要的区别在于，远程引用是只读的。 虽然可以 <code>git checkout</code> 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 <code>commit</code> 命令来更新远程引用。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p>
<h2 id="包文件"><a class="header-anchor" href="#包文件"></a>包文件</h2>
<p>Git 仓库最初的时候，Git 对同一个文件的不同版本会保留源文件，而不是只完整保存其中一个，再保存另一个对象与之前版本的差异内容。</p>
<p>但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。</p>
<p>Git 是如何做到这点的？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。 你可以查看包文件，观察它是如何节省空间的。 <code>git verify-pack</code> 这个底层命令可以让你查看已打包的内容。</p>
<h2 id="引用规范"><a class="header-anchor" href="#引用规范"></a>引用规范</h2>
<p>现在想要添加一个远程仓库：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin https://github.com/schacon/simplegit-progit</span></span><br></pre></td></tr></tbody></table></figure>
<p>运行上述命令会在你仓库中的 <code>.git/config</code> 文件中添加一个小节， 并在其中指定远程版本库的名称（<code>origin</code>）、URL 和一个用于获取操作的 <strong>引用规范（refspec）</strong>：</p>
<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote "origin"]</span></span><br><span class="line">	<span class="attr">url</span> = https://github.com/schacon/simplegit-progit</span><br><span class="line">	<span class="attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></tbody></table></figure>
<p>引用规范的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成， 其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用； <code>&lt;dst&gt;</code> 是本地跟踪的远程引用的位置。 <code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p>
<p>默认情况下，引用规范由 <code>git remote add origin</code> 命令自动生成， Git 获取服务器中 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code> 中。 所以，如果服务器上有一个 <code>master</code> 分支，你可以在本地通过下面任意一种方式来访问该分支上的提交记录：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> origin/master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> remotes/origin/master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> refs/remotes/origin/master</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 <code>refs/remotes/origin/master</code>。</p>
<p>如果想让 Git 每次只拉取远程的 <code>master</code> 分支，而不是所有分支， 可以把（引用规范的）获取那一行修改为只引用该分支：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/master:refs/remotes/origin/master</span><br></pre></td></tr></tbody></table></figure>
<p>这仅是针对该远程版本库的 <code>git fetch</code> 操作的默认引用规范。 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规范。 若要将远程的 <code>master</code> 分支拉到本地的 <code>origin/mymaster</code> 分支，可以运行：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin master:refs/remotes/origin/mymaster</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="传输协议"><a class="header-anchor" href="#传输协议"></a>传输协议</h2>
<p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p>
<h3 id="哑协议"><a class="header-anchor" href="#哑协议"></a>哑协议</h3>
<p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p>
<h3 id="智能协议"><a class="header-anchor" href="#智能协议"></a>智能协议</h3>
<p>智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p>
<p>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</p>
<p>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续传输的数据。</p>
<h2 id="维护与数据恢复"><a class="header-anchor" href="#维护与数据恢复"></a>维护与数据恢复</h2>
<p>有的时候，你需要对仓库进行清理——使它的结构变得更紧凑，或是对导入的仓库进行清理，或是恢复丢失的内容。</p>
<h3 id="维护"><a class="header-anchor" href="#维护"></a>维护</h3>
<p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。 大多数时候，这个命令并不会产生效果。 然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 <code>git gc</code> 命令。 “gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中， 将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p>
<p>可以像下面一样手动执行自动垃圾回收：</p>
<figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git gc --auto</span></span><br></pre></td></tr></tbody></table></figure>
<p>就像上面提到的，这个命令通常并不会产生效果。 大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令。 你可以通过修改 <code>gc.auto</code> 与 <code>gc.autopacklimit</code> 的设置来改动这些数值。</p>
<h3 id="数据恢复"><a class="header-anchor" href="#数据恢复"></a>数据恢复</h3>
<p>在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支， 亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？</p>
<p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。 当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 引用日志（reflog）也可以通过 <code>git update-ref</code> 命令更新，我们在 <em>Git 引用</em> 有提到使用这个命令而不是是直接将 SHA-1 的值写入引用文件中的原因。</p>
<h3 id="移除对象"><a class="header-anchor" href="#移除对象"></a>移除对象</h3>
<p>Git 有很多很棒的功能，但是其中一个特性会导致问题，<code>git clone</code> 会下载整个项目的历史，包括每一个文件的每一个版本。 如果所有的东西都是源代码那么这很好，因为 Git 被高度优化来有效地存储这种数据。 然而，如果某个人在之前向项目添加了一个大小特别大的文件，即使你将这个文件从项目中移除了，每次克隆还是都要强制的下载这个大文件。 之所以会产生这个问题，是因为这个文件在历史中是存在的，它会永远在那里。</p>
<p><strong>警告：这个操作对提交历史的修改是破坏性的。</strong> 它会从你必须修改或移除一个大文件引用最早的树对象开始重写每一次提交。 如果你在导入仓库后，在任何人开始基于这些提交工作前执行这个操作，那么将不会有任何问题——否则， 你必须通知所有的贡献者他们需要将他们的成果变基到你的新提交上。</p>
<p>必须使用 <code>git rm --cached</code> 命令来移除文件，而不是通过类似 <code>rm file</code> 的命令——因为你需要从索引中移除它，而不是磁盘中。 还有一个原因是速度—— Git 在运行过滤器时，并不会检出每个修订版本到磁盘中，所以这个过程会非常快。</p>
<h2 id="环境变量"><a class="header-anchor" href="#环境变量"></a>环境变量</h2>
<p>Git 总是在一个 <code>bash</code> shell 中运行，并借助一些 shell 环境变量来决定它的运行方式。 有</p>
<h3 id="全局行为"><a class="header-anchor" href="#全局行为"></a>全局行为</h3>
<p>像通常的程序一样，Git 的常规行为依赖于环境变量。</p>
<p><strong><code>GIT_EXEC_PATH</code></strong> 决定 Git 到哪找它的子程序 （像 <code>git-commit</code>, <code>git-diff</code> 等等）。 你可以用 <code>git --exec-path</code> 来查看当前设置。</p>
<p>通常不会考虑修改 <strong><code>HOME</code></strong> 这个变量（太多其它东西都依赖它），这是 Git 查找全局配置文件的地方。 如果你想要一个包括全局配置的真正的便携版 Git， 你可以在便携版 Git 的 shell 配置中覆盖 <code>HOME</code> 设置。</p>
<p><strong><code>PREFIX</code></strong> 也类似，除了用于系统级别的配置。 Git 在 <code>$PREFIX/etc/gitconfig</code> 查找此文件。</p>
<p>如果设置了 <strong><code>GIT_CONFIG_NOSYSTEM</code></strong>，就禁用系统级别的配置文件。 这在系统配置影响了你的命令，而你又无权限修改的时候很有用。</p>
<p><strong><code>GIT_PAGER</code></strong> 控制在命令行上显示多页输出的程序。 如果这个没有设置，就会用 <code>PAGER</code> 。</p>
<p><strong><code>GIT_EDITOR</code></strong> 当用户需要编辑一些文本（比如提交信息）时， Git 会启动这个编辑器。 如果没设置，就会用 <code>EDITOR</code> 。</p>
<h3 id="版本库位置"><a class="header-anchor" href="#版本库位置"></a>版本库位置</h3>
<p>Git 用了几个变量来确定它如何与当前版本库交互。</p>
<p><strong><code>GIT_DIR</code></strong> 是 <code>.git</code> 目录的位置。 如果这个没有设置， Git 会按照目录树逐层向上查找 <code>.git</code> 目录，直到到达 <code>~</code> 或 <code>/</code>。</p>
<p><strong><code>GIT_CEILING_DIRECTORIES</code></strong> 控制查找 <code>.git</code> 目录的行为。 如果你访问加载很慢的目录（如那些磁带机上的或通过网络连接访问的），你可能会想让 Git 早点停止尝试，尤其是 shell 构建时调用了 Git 。</p>
<p><strong><code>GIT_WORK_TREE</code></strong> 是非空版本库的工作目录的根路径。 如果指定了 <code>--git-dir</code> 或 <code>GIT_DIR</code> 但未指定 <code>--work-tree</code>、<code>GIT_WORK_TREE</code> 或 <code>core.worktree</code>，那么当前工作目录就会视作工作树的顶级目录。</p>
<p><strong><code>GIT_INDEX_FILE</code></strong> 是索引文件的路径（只有非空版本库有）。</p>
<p><strong><code>GIT_OBJECT_DIRECTORY</code></strong> 用来指定 <code>.git/objects</code> 目录的位置。</p>
<p><strong><code>GIT_ALTERNATE_OBJECT_DIRECTORIES</code></strong> 一个冒号分割的列表（格式类似 <code>/dir/one:/dir/two:…</code>）用来告诉 Git 到哪里去找不在 <code>GIT_OBJECT_DIRECTORY</code> 目录中的对象。 如果你有很多项目有相同内容的大文件，这个可以用来避免存储过多备份。</p>
<h3 id="路径规则"><a class="header-anchor" href="#路径规则"></a>路径规则</h3>
<p>所谓 “pathspec” 是指你在 Git 中如何指定路径，包括通配符的使用。 它们会在 <code>.gitignore</code> 文件中用到，命令行里也会用到（<code>git add *.c</code>）。</p>
<p><strong><code>GIT_GLOB_PATHSPECS</code></strong> 和 <strong><code>GIT_NOGLOB_PATHSPECS</code></strong> 控制通配符在路径规则中的默认行为。 如果 <code>GIT_GLOB_PATHSPECS</code> 设置为 1, 通配符表现为通配符（这是默认设置）; 如果 <code>GIT_NOGLOB_PATHSPECS</code> 设置为 1,通配符仅匹配字面。意思是 <code>*.c</code> 只会匹配 <em>文件名是</em> “*.c” 的文件，而不是以 <code>.c</code> 结尾的文件。 你可以在各个路径规范中用 <code>:(glob)</code> 或 <code>:(literal)</code> 开头来覆盖这个配置，如 <code>:(glob)*.c</code> 。</p>
<p><strong><code>GIT_LITERAL_PATHSPECS</code></strong> 禁用上面的两种行为；通配符将不能用，前缀覆盖也不能用。</p>
<p><strong><code>GIT_ICASE_PATHSPECS</code></strong> 让所有的路径规范忽略大小写。</p>
<h3 id="提交"><a class="header-anchor" href="#提交"></a>提交</h3>
<p>Git 提交对象的创建通常最后是由 <code>git-commit-tree</code> 来完成， <code>git-commit-tree</code> 用这些环境变量作主要的信息源。 仅当这些值不存在才回退到预置的值。</p>
<p><strong><code>GIT_AUTHOR_NAME</code></strong> 是 “author” 字段的可读名字。</p>
<p><strong><code>GIT_AUTHOR_EMAIL</code></strong> 是 “author” 字段的邮件。</p>
<p><strong><code>GIT_AUTHOR_DATE</code></strong> 是 “author” 字段的时间戳。</p>
<p><strong><code>GIT_COMMITTER_NAME</code></strong> 是 “committer” 字段的可读名字。</p>
<p><strong><code>GIT_COMMITTER_EMAIL</code></strong> 是 “committer” 字段的邮件。</p>
<p><strong><code>GIT_COMMITTER_DATE</code></strong> 是 “committer” 字段的时间戳。</p>
<p>如果 <code>user.email</code> 没有配置， 就会用到 <strong><code>EMAIL</code></strong> 指定的邮件地址。 如果 <em>这个</em> 也没有设置， Git 继续回退使用系统用户和主机名。</p>
<h3 id="网络"><a class="header-anchor" href="#网络"></a>网络</h3>
<p>Git 使用 <code>curl</code> 库通过 HTTP 来完成网络操作， 所以 <strong><code>GIT_CURL_VERBOSE</code></strong> 告诉 Git 显示所有由那个库产生的消息。 这跟在命令行执行 <code>curl -v</code> 差不多。</p>
<p><strong><code>GIT_SSL_NO_VERIFY</code></strong> 告诉 Git 不用验证 SSL 证书。 这在有些时候是需要的， 例如你用一个自己签名的证书通过 HTTPS 来提供 Git 服务， 或者你正在搭建 Git 服务器，还没有安装完全的证书。</p>
<p>如果 Git 操作在网速低于 <strong><code>GIT_HTTP_LOW_SPEED_LIMIT</code></strong> 字节／秒，并且持续 <strong><code>GIT_HTTP_LOW_SPEED_TIME</code></strong> 秒以上的时间，Git 会终止那个操作。 这些值会覆盖 <code>http.lowSpeedLimit</code> 和 <code>http.lowSpeedTime</code> 配置的值。</p>
<p><strong><code>GIT_HTTP_USER_AGENT</code></strong> 设置 Git 在通过 HTTP 通讯时用到的 user-agent。 默认值类似于 <code>git/2.0.0</code> 。</p>
<h3 id="比较和合并"><a class="header-anchor" href="#比较和合并"></a>比较和合并</h3>
<p><strong><code>GIT_DIFF_OPTS</code></strong> 这个有点起错名字了。 有效值仅支持 <code>-u&lt;n&gt;</code> 或 <code>--unified=&lt;n&gt;</code>，用来控制在 <code>git diff</code> 命令中显示的内容行数。</p>
<p><strong><code>GIT_EXTERNAL_DIFF</code></strong> 用来覆盖 <code>diff.external</code> 配置的值。 如果设置了这个值， 当执行 <code>git diff</code> 时，Git 会调用该程序。</p>
<p><strong><code>GIT_DIFF_PATH_COUNTER</code></strong> 和 <strong><code>GIT_DIFF_PATH_TOTAL</code></strong> 对于 <code>GIT_EXTERNAL_DIFF</code> 或 <code>diff.external</code> 指定的程序有用。 前者表示在一系列文件中哪个是被比较的（从 1 开始），后者表示每批文件的总数。</p>
<p><strong><code>GIT_MERGE_VERBOSITY</code></strong> 控制递归合并策略的输出。 允许的值有下面这些：</p>
<ul>
<li>0 什么都不输出，除了可能会有一个错误信息。</li>
<li>1 只显示冲突。</li>
<li>2 还显示文件改变。</li>
<li>3 显示因为没有改变被跳过的文件。</li>
<li>4 显示处理的所有路径。</li>
<li>5 显示详细的调试信息。</li>
</ul>
<p>默认值是 2。</p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>本章讨论了很多底层命令，这些命令比我们在本书其余部分学到的高层命令来得更原始，也更简洁。 从底层了解 Git 的工作原理有助于更好地理解 Git 在内部是如何运作的，也方便你能够针对特定的工作流写出自己的工具和脚本。</p>
<p>作为一套内容寻址文件系统，Git 不仅仅是一个版本控制系统，它同时是一个非常强大且易用的工具。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.itwray.com">Wray</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.itwray.com/2024/01/23/git-study-10/">https://blog.itwray.com/2024/01/23/git-study-10/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.itwray.com" target="_blank">WrayのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Git/">Git</a></div><div class="post_share"><div class="social-share" data-image="https://itwray.oss-cn-heyuan.aliyuncs.com/img/field-8419729_1920.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/04/springdoc-hello/" title="再见SpringFox，你好SpringDoc"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240304173959.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">再见SpringFox，你好SpringDoc</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/22/git-study-9/" title="Git学习-Git与其他系统"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/christmas-8453168_1920.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git学习-Git与其他系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/22/git-commands-reset/" title="Git-reset命令"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/field-8419729_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">Git-reset命令</div></div></a></div><div><a href="/2023/10/13/git-study-1/" title="Git学习-起步(1)"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/bird-8376009_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-13</div><div class="title">Git学习-起步(1)</div></div></a></div><div><a href="/2023/12/07/git-study-2/" title="Git学习-Git基础(2)"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/lighthouse-8415024_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-07</div><div class="title">Git学习-Git基础(2)</div></div></a></div><div><a href="/2023/12/12/git-study-3/" title="Git学习-Git分支(3)"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/mountain-8445543_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-12</div><div class="title">Git学习-Git分支(3)</div></div></a></div><div><a href="/2023/12/15/git-study-4/" title="Git学习-Git服务器(4)"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/mountain-8451604_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-15</div><div class="title">Git学习-Git服务器(4)</div></div></a></div><div><a href="/2023/12/17/git-study-5/" title="Git学习-分布式Git(5)"><img class="cover" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/roofs-8449752_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-17</div><div class="title">Git学习-分布式Git(5)</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/touxiang.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Wray</div><div class="author-info__description">记录生活的点点滴滴<br>Keep track of my life</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wangfarui" target="_blank" title="Github"><i class="fab fa-github" style="color: #f1f2f4;"></i></a><a class="social-icon" href="mailto:wray20156294@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #f26522;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4%E4%B8%8E%E4%B8%8A%E5%B1%82%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">底层命令与上层命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">Git 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">树对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">提交对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">Git 引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAD%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">HEAD文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">标签引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">远程引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">包文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">5.</span> <span class="toc-text">引用规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.</span> <span class="toc-text">传输协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%91%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.1.</span> <span class="toc-text">哑协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.2.</span> <span class="toc-text">智能协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-number">7.</span> <span class="toc-text">维护与数据恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4"><span class="toc-number">7.1.</span> <span class="toc-text">维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-number">7.2.</span> <span class="toc-text">数据恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.3.</span> <span class="toc-text">移除对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">8.</span> <span class="toc-text">环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.1.</span> <span class="toc-text">全局行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%BA%93%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.2.</span> <span class="toc-text">版本库位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%99"><span class="toc-number">8.3.</span> <span class="toc-text">路径规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4"><span class="toc-number">8.4.</span> <span class="toc-text">提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">8.5.</span> <span class="toc-text">网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%92%8C%E5%90%88%E5%B9%B6"><span class="toc-number">8.6.</span> <span class="toc-text">比较和合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/echart-uni-20241015/" title="记录一次在uni-app中使用echarts的坑"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/20241015213053.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记录一次在uni-app中使用echarts的坑"></a><div class="content"><a class="title" href="/2024/10/15/echart-uni-20241015/" title="记录一次在uni-app中使用echarts的坑">记录一次在uni-app中使用echarts的坑</a><time datetime="2024-10-15T12:26:07.000Z" title="发表于 2024-10-15 20:26:07">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/13/rocketmq-springboot-simple/" title="RocketMQ 5.x在SpringBoot中的上手使用过程"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/20241013131831.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ 5.x在SpringBoot中的上手使用过程"></a><div class="content"><a class="title" href="/2024/10/13/rocketmq-springboot-simple/" title="RocketMQ 5.x在SpringBoot中的上手使用过程">RocketMQ 5.x在SpringBoot中的上手使用过程</a><time datetime="2024-10-13T05:13:01.000Z" title="发表于 2024-10-13 13:13:01">2024-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/23/fail2ban-use/" title="Fail2Ban使用心得"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/pic/20241015213235.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Fail2Ban使用心得"></a><div class="content"><a class="title" href="/2024/09/23/fail2ban-use/" title="Fail2Ban使用心得">Fail2Ban使用心得</a><time datetime="2024-09-23T04:23:29.000Z" title="发表于 2024-09-23 12:23:29">2024-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/26/spring-boot-redis-use/" title="SpringBoot集成Redis使用心得"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240826154118.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot集成Redis使用心得"></a><div class="content"><a class="title" href="/2024/08/26/spring-boot-redis-use/" title="SpringBoot集成Redis使用心得">SpringBoot集成Redis使用心得</a><time datetime="2024-08-26T07:27:17.000Z" title="发表于 2024-08-26 15:27:17">2024-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/03/java-jvm-readClassFile/" title="Java-“手撕”Class文件结构"><img src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/20240801110726.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java-“手撕”Class文件结构"></a><div class="content"><a class="title" href="/2024/07/03/java-jvm-readClassFile/" title="Java-“手撕”Class文件结构">Java-“手撕”Class文件结构</a><time datetime="2024-07-03T03:31:38.000Z" title="发表于 2024-07-03 11:31:38">2024-07-03</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 - 2024 By Wray</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>鄂ICP备2024050235号-1</span></a> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=42018502007471" rel="noreferrer" target="_blank"><img class="icp-icon" src="https://itwray.oss-cn-heyuan.aliyuncs.com/img/beian.png"><span>鄂公网安备42018502007471</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liElrglVY7VkALhS',
      clientSecret: 'be255ab0fc6f3cd6212bab51c445b209672284f7',
      repo: 'wangfarui.github.io',
      owner: 'wangfarui',
      admin: ['wangfarui'],
      id: '99c2524d21e21e7482dd1064a90784e7',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>